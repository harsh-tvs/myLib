type Query {
  #
  _empty: String

  #
  serviceProvider(id: Int, status: Int): ServiceProvider

  #
  allServiceProviders(status: Int): [ServiceProvider!]!

  #
  deviceModel(
    id: Int
    model_name: String
    devicetype: String
    status: Int
  ): DeviceModel

  #
  allDeviceModels(manufacturerId: Int, status: Int): [DeviceModel!]!

  #
  checkDeviceModelName(
    deviceModelId: Int
    manufacturerId: Int!
    model_name: String!
  ): String!

  #
  deviceDetail(
    serial_num: String
    imei_num: String
    uniqueDeviceId: String
  ): DeviceDetail

  #
  deviceDetail1(
    serial_num: String
    imei_num: String
    uniqueDeviceId: String
  ): DeviceDetail

  #
  allDeviceDetails(ownerLoginId: Int, status: Int): [DeviceDetail!]!

  #
  allDeviceDetails1(ownerLoginId: Int, status: Int): [DeviceDetail!]!

  #
  getAllDeviceDetailsAPI(status: DeviceStatus): [DeviceDetailResponse!]!

  #
  getDeviceCountByDeviceModel(
    superAdminLoginId: Int!
  ): [DeviceCountByDeviceModel!]!

  #
  getAllDeviceDetailsByLoginId(
    #
    loginId: Int!

    # Available account types are PA
    accountType: String!

    #
    deviceModelId: Int!

    #
    status: Int
  ): [DeviceDetail!]!

  #
  getActivationStatus(vin: String!): activationStatus

  #
  countryById(country_id: Int!): CountryModel

  #
  allCountries: [CountryModel!]!

  #
  stateByZoneId(zone_id: Int!): StateModel

  #
  allStatesByCountryId(country_id: Int!): [StateModel!]!

  #
  simDetail(
    id: Int
    phoneNumber: String
    simNumber: String
    status: Int
  ): SimDetail

  #
  simDetail1(
    id: Int
    phoneNumber: String
    simNumber: String
    status: Int
  ): SimDetail

  #
  allSimDetails(
    ownerLoginId: Int!
    serviceProviderId: Int
    status: Int
  ): [SimDetail!]!

  #
  allSimDetails1(
    ownerLoginId: Int!
    serviceProviderId: Int
    status: Int
  ): [SimDetail!]!

  #
  getAllSimDetailsAPI(status: SimStatus): [SimDetailResponse!]!

  #
  getSimCountByOperator(superAdminLoginId: Int!): [SimCountByOperator!]!

  #
  checkSimNumber(simNumber: String!): String!

  #
  checkPhoneNumber(phoneNumber: String!): String!

  #
  loginDetail(loginId: Int, username: String, status: Int): Login

  #
  allLoginDetails(status: Int): [Login!]!

  #
  login(username: String!, password: String!, accountType: String): AuthPayload

  # This API is used to generate OTP for new login.
  newLoginWithOTP(
    username: String!
    password: String!
    accountType: String
    isResend: Boolean!
  ): newLoginWithOTPResponse

  # This API is used logout and delete token.
  logoutAuthTokenAPI(
    # Token generated for the login.
    token: String!

    #
    loginId: Int!
  ): logoutResponse!

  # This API is used logout from all instance of a client.
  # LoginId is loginId of the login should be expired.
  logoutAuthTokenAllClientsAPI(loginId: Int!): Boolean!

  #
  generateAuthTokenAPI(
    username: String!
    password: String!
    hours: Int
  ): AuthToken

  #
  generateLoginOTP(username: String!, password: String!): Boolean!

  #
  generateLoginOTPForDriver(contactNumber: String!): Boolean

  #
  validateOTP(OTP: String!, username: String!): AuthPayload

  #
  validatingOTP(
    OTP: Int!
    username: String!
    accountType: String
  ): validateOtpResponse

  #
  refreshToken(refreshToken: String!): AuthPayload

  #
  createTimeLimitedLogin(
    username: String!
    password: String!
    portalURL: String!
    hours: Int!
    accountType: String
  ): AuthPayload

  # This API generates a token for a time period of requested timestamp. Need business admin token in the header.
  # Token is generated for the login under business admin.
  getClientLoginToken(
    # Id here is client Id
    id: Int!

    # toTimestamp is GMT timestamp(in seconds). Timestamp passed should be greater than current timestamp.
    toTimestamp: String
  ): AuthPayload

  # This API generates a token for a time period of requested timestamp. Need business admin token in the header.
  # Token is generated for the login under business admin. Business admin token must be saved in redis.
  getLoginTokenAPI(
    # LoginId here is login Id.
    loginId: Int!

    # toTimestamp is GMT timestamp(in seconds). Timestamp passed should be greater than current timestamp.
    toTimestamp: String
  ): AuthPayload

  #
  checkUsername(loginId: Int, username: String!): String!

  #
  createLiveLocationSharingToken(
    hours: Int!
    uniquedeviceid: String!
    apiUri: String!
    httpUri: String!
    title: String!
  ): liveLocSharingToken!

  #
  sendSmsAndEmail(
    phoneNumber: [String]!
    email: [String]!
    shareLink: String!
    vehicleNumber: String!
  ): Boolean!

  #
  getGstDetails(gstNumber: String!): GSTDetails

  #
  getPartnerDomainConfig(loginId: Int!): String!

  #
  partnerDetail(
    id: Int
    businessName: String
    email: String
    contactNumber: String
    loginId: Int
    panNumber: String
  ): PartnerDetail

  #
  allPartnerDetails(status: Int): [PartnerDetail!]!

  #
  checkBusinessName(id: Int, businessName: String!): String!

  #
  checkPartnerContactNumber(id: Int, contactNumber: String!): String!

  #
  checkPartnerPanNumber(id: Int, panNumber: String!): String!

  #
  checkPartnerEmail(id: Int, email: String!): String!

  #
  getManufacturer(
    id: Int
    manufacturerName: String
    manufacturerCode: String
    status: Int
  ): Manufacturer

  #
  getAllManufacturer(status: Int): [Manufacturer!]!

  #
  checkManufacturerCode(manufacturerCode: String!): String!

  #
  checkManufacturerName(manufacturerName: String!): Int!

  #
  checkManufacturerContactNumber(contactNumber: String!): Int!

  #
  checkManufacturerEmail(email: String!): Int!

  #
  getManufacturerPartnerAssignDetail(
    manufacturerId: Int!
    partnerLoginId: Int!
  ): ManufacturerPartnerAssign

  #
  getAllManufacturerPartnerAssignDetails(
    partnerLoginId: Int!
    status: Int
  ): [ManufacturerPartnerAssign!]!

  #
  getDeviceModelPartnerAssignDetail(
    deviceModelId: Int!
    manufacturerId: Int!
    partnerLoginId: Int!
  ): DeviceModelPartnerAssign

  #
  getAllDeviceModelPartnerAssignDetails(
    partnerLoginId: Int!
    manufacturerId: Int!
    status: Int
  ): [DeviceModelPartnerAssign!]!

  #
  getAllDeviceModelPartnerAssignDetailsForSubscription(
    partnerLoginId: Int!
  ): [DeviceModelPartnerAssign!]!

  #
  devicePartnerAssignDetail(
    id: Int
    uniqueDeviceId: String
    partnerLoginId: Int
  ): DevicePartnerAssign

  #
  allDevicePartnerAssignDetails(
    partnerLoginId: Int
    status: Int
  ): [DevicePartnerAssign!]!

  #
  getPartnerDeviceStockByDeviceModel(
    partnerLoginId: Int!
  ): [PartnerDeviceStockDetail!]!

  #
  getAllAssignedDevicesToClient(clientLoginId: Int!): [DevicePartnerAssign!]

  #
  checkDeviceAvailableForSubscription(
    partnerLoginId: Int!
    deviceList: [DeviceListInput!]!
    deviceModelId: Int!
  ): [DeviceAvailabilityVerification!]!

  #
  getClientDeviceStock(clientLoginId: Int!): ClientDeviceStock!

  #
  simPartnerAssignDetail(id: Int, simId: Int): SimPartnerAssign

  #
  allSimPartnerAssignDetails(
    partnerLoginId: Int
    status: Int
  ): [SimPartnerAssign!]!

  #
  getPartnerSimStockByServiceProvider(
    partnerLoginId: Int!
  ): [PartnerSimStockDetail!]!

  #
  getAllAssignedSimToClient(clientLoginId: Int!): [SimPartnerAssign!]

  #
  checkSimAvailableForSubscription(
    partnerLoginId: Int!
    simList: [SimListInput!]!
    serviceProviderId: Int!
  ): [SimAvailabilityVerification!]!

  #
  clientDetail(
    id: Int
    loginId: Int
    clientName: String
    email: String
    contactNumber: String
    partnerLoginId: Int
    status: Int
  ): ClientDetail

  #
  allClientDetails(
    partnerLoginId: Int
    resellerLoginId: Int
    planId: Int
    status: Int
    superAdmin: Boolean
  ): [ClientDetail!]!

  #
  allClientDetails1(
    partnerLoginId: Int
    resellerLoginId: Int
    planId: Int
    status: Int
    superAdmin: Boolean
  ): [ClientDetail!]!

  #
  allClientDetailsAPI: [ClientDetail!]!

  #
  checkClientName(id: Int, clientName: String!): String!

  #
  checkClientGST(GST: String!, clientLoginId: Int): String!

  #
  checkClientPAN(PAN: String!): String!

  #
  checkClientContactNumber(id: Int, contactNumber: String!): String!

  #
  checkClientPanNumber(id: Int, clientLoginId: Int, panNumber: String!): String!

  #
  checkClientEmail(id: Int, email: String!): String!

  #
  getClientSOCThreshold(clientId: Int!): ClientSOC

  #
  getClientOfflineCondition(clientLoginId: Int!): clientOffline

  # Get vehicle details of a single vehicle
  getVehicleDetail(
    # Id of the vehicle
    entityId: Int

    # Number of the vehicle
    vehicleNumber: String

    # Unique of the device.
    deviceUniqueId_fk: String

    # Id of the sim
    simId: Int

    # Status of the vehicle
    status: Int
  ): VehicleDetail

  # This API is used to check clientLoginid for Aggrement
  CheckClientLoginId(clientName: String): Boolean!

  # Get the vehicle details using vehcile number. Exposed to client.
  getVehicleDetailAPI(
    # Vehicle plate number.
    vehicleNumber: String!
  ): VehicleDetail!

  #
  getAllVehicleDetails(
    # LoginId of the client
    clientLoginId: Int

    # Status of the vehicle
    status: [Int!]

    # obdOnly need to be true if device is OBD.
    obdOnly: Boolean
  ): [VehicleDeviceDetail!]!

  #
  getAllVehicleDetailsByClient(
    # LoginId of the client
    clientLoginId: Int

    # Status of the vehicle
    status: [Int!]
  ): [VehicleDeviceDetailClient!]!

  #
  getAllVehicleDetailsByUniqueDeviceId(
    clientLoginId: Int
    uniqueDeviceId: String!
  ): [VehicleDeviceDetails]!

  # Get vehicle details of the Active vehicles.
  getAllActiveVehicleDetails(
    # LoginId of the client
    clientLoginId: Int

    # Status of the vehicle
    status: [Int!]

    # obdOnly need to be true if device is OBD.
    obdOnly: Boolean
  ): [VehicleDeviceDetail!]!

  # Check whether vehicle number already exists or no.
  checkVehicleNumber(
    # Vehicle plate number.
    vehicleNumber: String!
  ): String!

  # Check if engine number already exists or no.
  checkEngineNumber(
    # EngineNumber
    engineNumber: String!
  ): String!

  # Check if chassis number already exists or no.
  checkChassisNumber(chassisNumber: String!): String!

  # Registered vehicle details.
  getRegisteredVehicleDetail(
    # LoginId of the client.
    clientLoginId: Int!

    # Device unique id's
    uniqueDeviceIdList: [String!]!
  ): [VehicleDataForInvoice!]!

  # All the vehicle details with respect to status
  getAllVehicleDetailsByStatus(
    # Add  partnerlogin id to get the all vehicles under partner.
    partnerLoginId: Int

    # Add  resellerlogin id to get the all vehicles under reseller.
    resellerloginId: Int

    # Add  clientLogin id to get the all vehicles under
    clientLoginId: Int

    # Add  deviceUniqueId to get the associated vehicle details.
    deviceUniqueId: String

    # Add  status to get the all vehicles under that status of added login Id.
    status: Int

    # Add  superadmin to get the all vehicles under superadmin.
    superadmin: Boolean
  ): [VehicleDeviceDetails!]!

  # Get all the vehicle details of particular status under client. Clinet login id is fetched from token
  getAllVehicleDetailsAPI(
    # Array of status.Only particular status vehicles will be fecthed.
    status: [STATUS]
  ): [VehicleDeviceDetail!]!

  # Get the total number of vehicles with respect to status under login id
  getVehicleCountByStatus(
    # Loginid of Partner.
    partnerLoginId: Int

    # Loginid of  Reseller.
    resellerloginId: Int

    # Loginid of  Client.
    clientLoginId: Int
  ): VehicleCount!

  # CLient login id need to be published to affect the changes made in the vehicle data.
  publishMQTTUsingClientLoginId(
    # LoginId of the client.
    clientLoginId: Int!
  ): Boolean!

  #
  getVehicleCountByApproveStatus: Boolean!

  #
  getOnBoardedVehicleDetail(vehicleNumber: String!): boardedVehicleDetails!

  #
  getVehicleMMTC(
    clientLoginId: Int!
    deviceModel: DeviceModels!
    serviceProvider: ServiceProviders!
  ): vehicleMMMTCResponse!

  #
  fetchAllActiveExcavatorsOfClient(clientLoginId: Int!): [Excavator]!

  #
  fetchAllTrucksOfClient(clientLoginId: Int!): [Truck]!

  #
  getVehicleDetailByIMEI(imei_num: String!): UserVehicle

  #
  Alert(id: Int, alertName: String, valueStatus: Int): Alerts

  #
  allAlerts(status: Int): [Alerts!]!

  #
  getAssignedAlerts(
    id: Int
    clientLoginId: Int
    alertId: Int
  ): ClientAlertAssignDetail

  #
  getAllAssignedAlertsToClient(clientLoginId: Int!): [ClientAlertAssignDetail!]

  #
  getAlertConfig(
    uniqueDeviceId: String
    alertType: String!
    areaId: Int
    tripId: Int
    routeId: Int
  ): AlertConfig

  #
  getAlertsConfig(vehicleNumber: String!, alertType: ALERT!): ALERTCONFIGS!

  #
  getAllAlertsConfig(vehicleNumber: String!): ALERTCONFIG!

  #
  getAllConfiguredDevices(
    clientLoginId: Int!
    alertType: String!
    areaId: Int
    routeId: Int
    uniqueId: String
    enabledOnly: Boolean
  ): [AlertConfig!]

  #
  getAllDeviceConfigurationByAlertType(
    clientLoginId: Int!
    alertType: String!
    getEnabled: Boolean!
  ): [DeviceConfigurationData!]

  #
  getConfiguredSpeedLimit(uniqueDeviceId: String!): DeviceData

  #
  getAssociatedLoginIdsOfVehicle(uniqueDeviceId: String!): LoginIds!

  #
  getAllAlertsParameters(
    model: String
    alert_parameter: String
  ): alertParametersResponse

  #
  getConditionalAlertConfig(
    vin: String!
    alert_parameter: String!
    enabled: Boolean
  ): getConditionalAlertConfigData

  #
  getOverspeedThreshold(vin: String!, app_user_id: String!): overSpeedRes

  #
  roleDetail(clientLoginId: Int!, roleName: String!, status: Int): Roles

  #
  allRolesDetails(clientLoginId: Int!, status: Int): [Roles!]!

  #
  groupDetail(clientLoginId: Int!, id: Int!, status: Int): Groups

  #
  getGroupIdByGroupName(groupName: String!): Groups

  #
  allGroupsDetails(clientLoginId: Int!, status: Int): [Groups!]!

  #
  getAllGroupsForRMS: RMSGroupDetails!

  #
  getAllTalukGroups(districtIds: [Int]!): TalukGroup!

  #
  getAllVillageGroups(talukIds: [Int]!): VillageGroup!

  #
  getAllGroups: [GroupDetail]

  #
  checkGroupName(groupName: String!, clientLoginId: Int!): String!

  #
  userDetail(id: Int, clientLoginId: Int, loginId: Int, status: Int): UserDetail

  #
  allUserDetails(clientLoginId: Int, status: Int): [UserDetail!]!

  #
  getAllUserIdNew(clientLoginId: Int): [UserIdNew!]

  #
  getSubloginDetails(subLoginId: Int, status: Int): [SubloginData!]!

  #
  checkSubClientName(userName: String!): String!

  #
  driverDetail(id: Int!, driverName: String, license: String): Driver

  #
  allDrivers(clientLoginId: Int, userLoginId: Int, status: Int): [Driver!]!

  #
  getDriverDetails(clientLoginId: Int, uniqueDeviceId: String): DriverDetails

  #
  getDriverDetail(clientLoginId: Int, imei_num: String): DriverDetail

  #
  getDriverByDriverLogin: Driver

  #
  checkLicenseNumber(license: String!): String!

  #
  checkContactNumber(contactNumber: String!): String!

  #
  getMinioFileURL(bucketName: String!, fileName: String!): FileDetails

  #
  getAllDriverDetails(clientLoginId: Int): [DriverDetail]

  #
  getMostOnDutyDriver(clientLoginId: Int): [OnDutyDriver]

  #
  vehicleGroupAssignDetail(groupId: Int, vehicleId: Int): VehicleGroupAssign

  #
  allVehicleGroupAssignDetails(
    groupId: Int
    status: Int
    vehicleId: Int
  ): [VehicleGroupAssign!]!

  #
  featureDetail(featureName: String!, status: Int): Features

  #
  allFeatures(status: Int): [Features!]!

  #
  allFeatureRoleAssignDetails(roleId: Int, status: Int): [FeatureRoleAssign!]!

  #
  getReportField(fieldId: String!, status: Int): ReportField

  #
  getAllReportField(status: Int): [ReportField!]!

  #
  getReportType(reportTypeId: String!, status: Int): ReportType

  #
  getAllReportType(status: Int): [ReportType!]!

  #
  getAvailableReportField(category: Int!, status: Int): AvailReportField

  #
  getAllCategory(status: Int): [AvailReportField!]!

  #
  getReportBuilder(
    clientLoginId: Int!
    reportName: String!
    status: Int
  ): ReportBuilder

  #
  getAllReportBuilder(clientLoginId: Int!, status: Int): [ReportBuilder!]

  # This API fetches client/partner and report type need be sent to client or clients under a partner login.
  # Possible are daily or weekly.
  getReportAutomation(
    # Client/partner login id
    loginId: Int!

    # Report name
    reportName: String!

    # Status of the report
    status: Int
  ): ReportAutomation

  # This API fetches all the clients and report type need be sent to client. Possible are daily or weekly.
  getAllReportAutomation(
    # LoginId of the client or partner
    loginId: Int

    # Type of the report to pushed to client.
    reportType: String

    # Status of the configuration.
    status: Int
  ): [ReportAutomation!]

  #
  getDefaultReportBuilder(
    reportName: String!
    status: Int
  ): DefaultReportBuilder

  #
  getAllDefaultReportBuilder(status: Int): [DefaultReportBuilder!]!

  #
  getPlans(partnerLoginId: Int, id: Int!, status: Int): Plans

  #
  getAllPlans(partnerLoginId: Int!, status: Int): [Plans!]!

  #
  getBillingMode(billingMode: String, id: Int!, status: Int): BillingMode

  #
  getAllBillingMode: [BillingMode!]!

  #
  getAllBillingModeForBillingFrequency(status: Int!): [BillingMode!]!

  #
  getBillingFrequency(frequency: String!, status: Int): BillingFrequency

  #
  getAllBillingFrequency(billingModeId: Int!): [BillingFrequency!]!

  #
  getBillingLogic(id: Int!, billingLogic: String, status: Int): BillingLogic

  #
  getAllBillingLogic(billingModeId: Int!): [BillingLogic!]!

  #
  getAccessoryType(id: Int, accessoryName: String, status: Int): AccessoryType

  #
  getAllAccessoryTypes(status: Int): [AccessoryType!]!

  #
  getAccessoryTypePartnerAssignDetail(
    accessoryTypeId: Int!
    manufacturerId: Int!
    partnerLoginId: Int!
  ): AccessoryTypePartnerAssign

  #
  getAllAccessoryTypePartnerAssignDetails(
    partnerLoginId: Int!
    manufacturerId: Int!
    status: Int
  ): [AccessoryTypePartnerAssign!]!

  #
  getAllAccessoryTypePartnerAssignDetailsForSubscription(
    partnerLoginId: Int!
  ): [AccessoryTypePartnerAssign!]!

  #
  getAccessoryDetail(serialNumber: Int, uniqueAccessoryId: String): Accessory

  #
  getAllAccessoryDetails(
    ownerLoginId: Int
    accessoryTypeId: Int
    status: Int
  ): [Accessory!]!

  #
  getAccessoryPartnerAssignDetail(
    id: Int
    uniqueAccessoryId: String
    partnerLoginId: Int
  ): AccessoryPartnerAssign

  #
  getAllAccessoryPartnerAssignDetails(
    partnerLoginId: Int
    status: Int
  ): [AccessoryPartnerAssign!]!

  #
  getPartnerAccessoryStockByAccessoryType(
    partnerLoginId: Int!
  ): [PartnerAccessoryStockDetail!]!

  #
  getAllAssignedAccessoryToClient(
    clientLoginId: Int!
  ): [AccessoryPartnerAssign!]

  #
  checkAccessoryAvailableForSubscription(
    partnerLoginId: Int!
    serialNumberList: [AccessoryListInput!]!
    accessoryTypeId: Int!
  ): [AccessoryAvailabilityVerification!]!

  #
  getSubscriptions(
    id: Int
    subscriptionBillId: Int
    partnerLoginId: Int
    clientLoginId: Int
    status: Int
  ): Subscriptions

  #
  getAllSubscriptions(
    partnerLoginId: Int!
    clientLoginId: Int
    billingDay: Int
    status: [Int!]
  ): [Subscriptions!]!

  #
  getAreaType(areaTypeName: String, id: Int!, status: Int): AreaType

  #
  getAllAreaType: [AreaType!]!

  # Fetches the deteails of AOI(Stop).
  getAreaDetails(
    # Area id of the existing area.
    id: Int!

    # Status of the area. Optional
    status: Int
  ): Area

  # Gets all the areas of client and its subClients
  getAllAreaDetails(
    # Login ID of the client
    clientLoginId: Int!
  ): [Area!]!

  # Gets all the areas based on pluscode
  getAllAreas(
    # pluscode
    pluscode: String!
  ): [Area!]!

  # Gets all the areas of client and its subClients.ClientLoginId is fetched from token. Exposed to client.
  getAllAreaDetailsAPI: [AreaResponse!]!

  # Get all the area details of the client and its sublogins. ClientLoginId is fetched from token. Exposed to client
  getAllAreaGeofenceAPI: [AreaGeoFenceResponse!]!

  #
  getAreasForUniqueIds(uniqueIds: [String!]!): [AreaVehicleAssociation!]!

  #
  getAreaIdByName(areaName: String!): Int

  #
  getRouteAssociatedAreas(routeId: Int!): [Area]!

  #
  getGeofenceListOld(userId: String!): getGeofenceListResponseOld!

  #
  getGeofenceList(
    userId: String!
    vin: String!
    geofenceId: Int
  ): getGeofenceListResponse

  #
  getVinDetails(vin: String!): vinDetailsResponse

  #
  getUserDetails(app_user_id: String!): getUserDetailsResponse!

  #
  getUserDetailsByMobileNumber(
    mobile_number: String!
    iso_code: ISO_CODES!
  ): getUserDetailsByMobileNumberResponse

  #
  redisScript: redisResponse

  #
  getRoute(id: Int!, status: Int): Route

  #
  getAllRoutes(clientLoginId: Int!): [Route!]!

  #
  getRoutesForUniqueIds(uniqueIds: [String!]!): [RouteVehicleAssociation!]!

  #
  getSubscriptionInventoryAssign(
    subscriptionId: Int!
    clientLoginId: Int
    status: Int
  ): SubscriptionInventoryAssign

  #
  getDeviceService(uniqueDeviceId: String!): DeviceService

  #
  getAllDeviceService: [DeviceService!]!

  #
  getAllDeviceServiceDetailsForBilling(
    billingStartedFrom: String!
    billingPayTill: String!
    uniqueDeviceId: String!
  ): [DeviceService!]!

  # Get trip by id
  getTrip(
    # Unique trip id
    tripId: Int!
  ): Trip

  # Get list of trips
  getAllTrips(
    # Logged in client's id
    clientLoginId: Int!

    # Status code of the trip, such as 3 for Deleted trips
    status: Int

    # Vehicle's unique id
    uniqueDeviceId: String

    # Cursor value for pagination
    cursor: String

    # Page length limit for pagination
    limit: Int
  ): TripConnection!

  #
  getAllTripsWithStudents(
    clientLoginId: Int!
    fromDateTs: String
    toDateTs: String
    uniqueDeviceId: String
  ): [TripStudentsDetail]

  #
  getSubTripForInProgressTrip(tripId: Int!): SubTrip

  #
  getSubTrip(subTripId: Int!): SubTrip

  #
  getAllSubTrips(tripId: Int!, status: Int, uniqueDeviceId: String): [SubTrip]!

  # Get WSO Trip details
  getWSOTrip(
    # Trip's area id
    areaId: Int!

    # Trip unique id
    tripId: Int!
  ): WSOTrip

  # Get trip details
  getTripsDetails(
    # Filters to query trips
    filters: TripFilters
  ): [Trip]!

  #
  getAllWayPointsOfActiveTrips: [wayPointTrips!]!

  #
  getAllTripsDetails(imeiNumber: String!): [TripDetails!]!

  #
  getScheduledStatus(tripId: Int!): TripScheduleStatus!

  #
  getTripEdits(tripId: Int!): Edits!

  # Get all student's details
  getAllStudents(
    # Client's login id
    clientLoginId: Int

    # Student's pickup trip id
    pickupTripId: [Int]

    # Student's drop trip id
    dropTripId: [Int]

    # Student's pickup vehicle id
    pickupVehicleId: Int

    # Student's drop vehicle id
    dropVehicleId: Int

    # Parent login id
    parentLoginId: Int

    # Student's school id
    schoolId: Int

    # Student's AOI pickup id
    aoiPickup: Int

    # Student's AOI drop id
    aoiDrop: Int

    # Student's status
    status: Int

    # Student's RFID
    rfid: String

    # Student's drop route id
    dropRouteId: Int

    # Student's pickup route id
    pickupRouteId: Int
  ): [Student]!

  # RFID validation check
  checkRFID(
    # RFID to check
    rfid: String!
  ): String!

  # Get student details
  getStudent(
    # RFID of student
    rfid: String

    # Student unique id
    studentId: Int

    # School's student unique id
    schoolStudentId: String
  ): Student

  #
  getUnassignedStudents(clientLoginId: Int!): [Student]!

  #
  getStudentsForStop(clientLoginId: Int!, areaId: Int!): [Student]!

  #
  getAllParentsLoginTime(clientLoginId: Int!): [parentLoginDetails]!

  #
  getSchoolRoute(id: Int!, status: Int): SchoolRoute

  #
  getAllSchoolRoute(clientLoginId: Int!, routeType: String): [SchoolRoute!]!

  #
  getSchoolArea(id: Int!, status: Int): SchoolArea

  #
  getAllSchoolArea(clientLoginId: Int!, areaType: String): [SchoolArea!]!

  #
  getSchoolTrip(id: Int!, status: Int): SchoolTrip

  #
  getAllSchoolTrip(clientLoginId: Int!, tripType: String): [SchoolTrip!]!

  #
  getLicenseType(id: Int!, status: Int): LicenseType

  #
  getAllLicenseType(status: Int): [LicenseType!]!

  #
  getResellerDomainConfig(loginId: Int!): String!

  #
  getResellerDetails(
    id: Int
    email: String
    contactNumber: String
    loginId: Int
    panNumber: String
  ): ResellerDetails

  #
  getAllResellerDetails(status: Int): [ResellerDetails!]!

  #
  checkResellerName(id: Int, resellerName: String!): String!

  #
  checkResellerContactNumber(id: Int, contactNumber: String!): String!

  #
  checkResellerPanNumber(id: Int, panNumber: String!): String!

  #
  checkResellerEmail(id: Int, email: String!): String!

  #
  getLicenseTypeResellerAssignDetails(
    licenseTypeId: Int!
    resellerLoginId: Int!
  ): LicenseTypeResellerAssign

  #
  getAllLicenseTypeResellerAssignDetails(
    resellerLoginId: Int!
    status: Int
  ): [LicenseTypeResellerAssign!]!

  #
  getDeviceModelResellerAssignDetails(
    deviceModelId: Int!
    resellerLoginId: Int!
  ): DeviceModelResellerAssign

  #
  getAllDeviceModelResellerAssignDetails(
    resellerLoginId: Int!
    status: Int
  ): [DeviceModelResellerAssign!]!

  #
  getPurchaseRequestInfo(id: Int!): PurchaseRequest

  #
  getAllPurchaseRequestInfo(
    resellerLoginId: Int
    status: Int
  ): [PurchaseRequest!]!

  #
  deviceResellerAssignDetail(
    id: Int
    uniqueDeviceId: String
    resellerLoginId: Int
  ): DeviceResellerAssign

  #
  allDeviceResellerAssignDetails(
    resellerLoginId: Int
    purchaseRequestId: Int
    status: Int
  ): [DeviceResellerAssign!]!

  #
  getResellerDeviceStockByDeviceModel(
    resellerLoginId: Int!
  ): [ResellerDeviceStockDetail!]!

  #
  getAllAssignedDevicesToResellerClient(
    clientLoginId: Int!
  ): [DeviceResellerAssign!]

  #
  checkDeviceAvailableForAssignment(
    deviceModelId: Int!
    deviceList: [DeviceListInput!]!
  ): [DeviceAvailabilityVerification!]!

  #
  checkDeviceAvailableForResellerSubscription(
    resellerLoginId: Int!
    deviceList: [DeviceListInput!]!
    deviceModelId: Int!
  ): [DeviceAvailabilityVerification!]!

  #
  simResellerAssignDetail(id: Int, simId: Int): SimResellerAssign

  #
  allSimResellerAssignDetails(
    resellerLoginId: Int
    status: Int
  ): [SimResellerAssign!]!

  #
  getResellerSimStockByServiceProvider(
    resellerLoginId: Int!
  ): [ResellerSimStockDetail!]!

  #
  getAllAssignedSimToResellerClient(clientLoginId: Int!): [SimResellerAssign!]

  #
  checkSimAvailableForResellerSubscription(
    resellerLoginId: Int!
    simList: [SimListInput!]!
    serviceProviderId: Int!
  ): [SimAvailabilityVerification!]!

  #
  getResellerSubscriptions(
    id: Int
    resellerLoginId: Int
    clientLoginId: Int
    status: Int
  ): ResellerSubscriptions

  #
  getAllResellerSubscriptions(
    resellerLoginId: Int!
    clientLoginId: Int
    billingDay: Int
    status: Int
  ): [ResellerSubscriptions!]!

  #
  getResellerLicenseInventory(
    id: Int
    licenseTypeId: Int
    resellerLoginId: Int
    status: Int
  ): ResellerLicenseInventory

  #
  getAllResellerLicenseInventory(
    resellerLoginId: Int!
    licenseTypeId: Int!
    status: Int
  ): [ResellerLicenseInventory!]!

  #
  getLicenseResellerAssignDetails(
    resellerLicenseInventoryId: Int
    resellerLoginId: Int
    clientLoginId: Int
    status: Int
  ): LicenseResellerAssign

  #
  getAllLicenseResellerAssignDetails(
    resellerLoginId: Int
    clientLoginId: Int
    status: Int
  ): [LicenseResellerAssign!]!

  #
  getResellerSubscriptionInventoryAssign(
    subscriptionId: Int!
  ): ResellerSubscriptionInventoryAssign

  #
  getSMSPurchaseHistory(
    id: Int
    fromLoginId: Int
    fromAccountType: String
    toLoginId: Int!
    toAccountType: String
  ): SMSPurchaseHistory

  #
  getallSMSPurchaseHistory(
    id: Int
    toLoginId: [Int!]!
    fromAccountType: String
    fromTimestamp: String!
    toTimestamp: String!
  ): [SMSPurchaseHistory!]!

  #
  getallsmss(loginId: Int): [data!]!

  #
  getAllSMSBalanceDetails(
    fromLoginId: Int
    fromAccountType: String
    toLoginId: Int
    toAccountType: String
  ): [smsBalance!]!

  #
  getSMSBalanceDetails(
    fromLoginId: Int
    fromAccountType: String
    toLoginId: Int
    toAccountType: String
  ): smsBalance

  #
  getObdDescription(obdName: String, pid: String): [obdDescription!]!

  #
  getAllObdDescriptions: [obdDescription!]!

  #
  TestgetSMSPurchaseHistory(
    id: Int
    fromLoginId: Int
    fromAccountType: String
    toLoginId: Int!
    toAccountType: String
  ): SMS111PurchaseHistory

  #
  getAllDevicePackets(
    deviceUniqueId: [String!]!
    clientLoginId: Int!
    fromDate: String!
    toDate: String!
  ): [deviceCount!]!

  #
  getNoOfDaysOfAllDevices(
    deviceUniqueId: [String!]!
    clientLoginId: Int!
    year: Int!
    month: Int!
  ): [tableData!]!

  #
  getAllPIAndInvoice(
    clientLoginId: Int
    partnerLoginId: Int
    paymentStatus: [Int!]
  ): [invoiceDetail!]!

  #
  getPIAndInvoiceDetail(id: Int!): invoiceDetail

  #
  getInvoiceDetails(id: Int!, isInvoice: Boolean!): InvoiceDetails

  #
  getInvoiceDownloadDetails(id: Int!, isInvoice: Boolean!): String!

  #
  getInvoiceIdsByStatus(paymentStatus: Int!): [InvoiceIds]!

  #
  getAllPartnerPIAndInvoice(
    clientLoginId: Int
    partnerLoginId: Int
    paymentStatus: [Int!]
  ): [invoiceDetail!]!

  #
  getAllClientCredits(status: Int): [clientCredits!]!

  #
  getClientCredit(clientLoginId: Int!): clientCredits

  #
  getAllBillingHistory(clientLoginId: Int!, year: Int!): [billingHistory!]!

  #
  getAllSchools(clientLoginId: Int!): [School]!

  #
  getSchool(clientLoginId: Int!, schoolId: Int!): School

  #
  getAllPartnerSubscriptions(
    partnerLoginId: Int
    status: [Int]
    deviceModelId: Int
  ): [PartnerSubscription]

  #
  getPartnerSubscriptions(id: Int!): PartnerSubscription

  #
  getSchoolMasterAlerts: [schoolAlerts!]!

  #
  getAllSchoolAlertsAssigned(
    clientLoginId: Int!
    status: Boolean
  ): [assignedSchoolAlerts!]!

  # Get all device tracking data based on clientLogin Id
  getAllDeviceLocationsForClient(
    # Client's login id
    clientLoginId: Int!
  ): [DeviceTrackingDataNew]!

  #
  getClientEmailLimit(loginId: Int!, id: Int): ClientEmailDetail

  #
  getAllClientEmailLimit: [ClientEmailDetail!]!

  #
  getSalesPerson(id: Int!): SalesPerson

  #
  getAllSalesPerson(
    clientLoginId: Int
    partnerLoginId: Int
    status: Int
  ): [SalesPerson!]

  # Search trips
  searchTrips(
    # Field to query by
    field: TripSearchFields!

    # Search terms
    searchTerms: [String!]!

    # Cursor value for pagination
    cursor: String

    # Result limit
    limit: Int
  ): SearchTripsConnection!

  #
  getDeviceSimMapped(vehicleIdentificationNumber: String!): deviceSimMapped

  #
  getAllDeviceSimMapped(
    vehicleIdentificationNumber: String
    clientLoginId: Int
    serviceProvider: ServiceProviders
    deviceModel: DeviceModels
  ): [deviceSimMapped!]!

  # Send maintenance reminder to the vehicles of a perticular client
  remindVehiclesMaint(clientLoginId: Int!): Boolean!

  # Get vehicle reminder details of a perticular client
  getVehiclesMaintDetails(clientLoginId: Int!): [VehicleMaintDetail]

  # Get list of icons for a particular client, if no loginId provided, return default list of icons
  getIcons(loginId: Int): [Icon]

  #
  getAllIcons(loginId: Int): [Icon]

  #
  getClientPids(clientLoginId: Int!): [Pid]

  #
  getSparePartReplacementHistory(clientLoginId: Int!): [SparePartReplacements]

  #
  getVehicleSerialNumbers(
    superadmin: Int
    partnerLoginId: Int
    resellerloginId: Int
  ): [vehicleInfo]

  #
  getVehicleSpareParts(
    clientLoginId: Int!
    uniqueDeviceId: String!
  ): VehicleSpareParts

  #
  getSparePartHistoryForAdmin(
    superadmin: Int
    partnerLoginId: Int
    resellerloginId: Int
  ): [SparePartReplacements]

  #
  getEmailTemplate(clientLoginId: Int, alertName: String): [EmailTemplate]

  #
  getEmailConfig(clientLoginId: Int!): EmailConfigs

  #
  getEmailidsForAlerts(id: Int!): EmailidsForAlerts

  #
  getAllEmailIdsForAlerts(id: Int, type: Int, status: Int): [EmailidsForAlerts!]

  #
  uploads: [File]

  #
  sendEmail(
    # Comma separated emails
    emailList: String!

    #
    subject: String!

    #
    message: String!
  ): String!

  #
  getSensorsConfiguration(
    clientLoginId: Int!
    sensorType: String
  ): [SensorsConfig]

  #
  getCommonField(commonFieldId: String!, status: Int): CommonFields

  #
  getAllCommonFields(status: Int): [CommonFields!]!

  #
  getConfiguredGraphsOfClient: [GraphData]

  #
  districtById(district_id: Int!): DistrictModel

  #
  allDistricts: [DistrictModel!]!

  #
  getClientVehicles(
    district_id: [Int]!
    taluk_id: [Int]
    village_id: [Int]
  ): [ClientVehicleData]

  #
  getAllClientVehicles(
    district_id: [Int]
    taluk_id: [Int]
    panchayat_id: [Int]
    village_id: [Int]
  ): [ClientVehicleData]

  #
  getAssignedDistrictToUser(clientLoginId: Int): [DistrictDetails]

  #
  talukById(district_id: [Int]!): [TalukModel]!

  #
  allTaluks: [TalukModel!]!

  #
  getAllTaluks(district_id: [Int]): [TalukModel!]!

  #
  villageById(panchayat_id: [Int]!): [VillageModel]!

  #
  allVillages: [VillageModel!]!

  #
  getAllVillages(panchayat_id: [Int]): [VillageModel!]!

  #
  panchayatById(taluk_id: [Int!]): [PanchayatModel!]!

  #
  getAllPanchayat(taluk_id: [Int]): [PanchayatModel!]!

  #
  fetchAllReportsOfClient(clientLoginId: Int!): [ClientReportAssign!]!

  #
  getAirtelPlans(serialNumber: Int, uniqueAccessoryId: String): [AirtelPlans]

  #
  getAirtelSimDetails(
    #
    simFilterType: simFilterType!

    # 1)If simFilterType is MSISDN then mobile number is to be passed  2) If SIM_NO Then sim number needs to be passed
    filterValue: String!
  ): [AirtelSimDetails]

  #
  getAllWppStaticData: [WppStaticData]

  #
  fetchAreaDetails(areaId: Int!): AreaInfo

  #
  getAllSharedLiveLocation(
    vin: String!
    app_user_id: String!
    request_id: Int
    from_time: String
    to_time: String
  ): getAllSharedLiveLocationResponse

  #
  getShareLinkShortnerUrl(shorten_token: String!): sharedLiveShortLinkDetails

  #
  fetchEmergencyContacts(
    vin: String
    app_user_id: String!
    emergency_contact_id: Int
  ): fetchEmergencyContactsResponse

  #
  getOfflineMaps(vin: String): offlineMapsResponse

  #
  getHomeChargerDetails(vin: String!): HomeChargerDetailsResponse

  #
  _: String!

  #
  domainConfiguration(domain: String!): DomainConfiguration

  #
  userConfiguration(loginId: Int): UserConfiguration

  #
  _dummy: String

  #
  getTravelHistory(
    uniqueId: String!
    from: String!
    to: String!
    simplify: Boolean
    snapToRoad: Boolean
  ): TravelHistory!

  #
  getTimeRangeLocationData(
    uniqueId: String!
    from: String!
    to: String!
  ): [RawLocationData!]!

  # Exposed to Aquila 4.x, will force fetch from geo-backend if not in cache/db
  getAddressForCoordinate(input: CoordinateInput!): PlusCodeAddress!

  # Fetch addresses for Plus codes from cache/db, 'Unnamed Location' if not
  getAddressesForPlusCodes(plusCodes: [String!]!): [PlusCodeAddress!]!

  # Fetch addresses for Coordinates from cache/db, 'Unnamed Location' if not
  getAddressesForCoordinates(input: [CoordinateInput!]!): [PlusCodeAddress!]!

  #
  placesSearch(
    # The place name to search for. Partial name search is also allowed.
    text: String!

    # How many results to return, Defaults to 5. Min 1, Max 20.
    size: Int

    # focus will return results ordered by closeness to provided coordinate
    focus: CoordinateInput
  ): [PlaceFeature]!

  # Fetch route with distance and time from geo-backend for a series of points
  getRouteDetails(input: [RouteCoordinateInput!]!): RouteDetails!

  #
  getRouteDetailsWithMap(
    input: [RouteCoordinateInput!]!
    mapType: mapType!
  ): RouteDetails!

  #
  getReverseGeocodeWithPlusCode(plusCode: String!): PlusCodeAddress!

  #
  getPublicDownloadURL(bucketName: String!, filename: String!): String!

  #
  parseExcelToJSON(input: FileInput!, expectedColumns: [String!]!): ParsedData!

  #
  generateExcelFromJSON(input: Data!, outputFileName: String): DownloadFile!

  #
  getAllSubTripAlerts(tripId: Int!, clientLoginId: Int): [TripAlert]!

  #
  getAllAlertsByClientLogin(
    clientLogin: Int!
    from: String
    to: String
  ): [Alert!]!

  #
  getAllAlertsByUniqueId(uniqueId: String!, from: String, to: String): [Alert!]!

  #
  getAllAlertsByAlertType(
    clientLogin: Int!
    alertType: String!
    from: String
    to: String
  ): [Alert!]!

  #
  getAllRecordsByUniqueIdsAndTimeRangeAndAlertType(
    uniqueIds: [String!]!
    alerttype: String!
    from_ts: String!
    to_ts: String!
  ): [Alert!]!

  #
  getAllAlerts(
    vin: String!
    app_user_id: [String]!
    startDateTime: String
    endDateTime: String
    alerttype: alerttype
  ): allAlertResponse

  #
  getTrackingHistory(
    vin: String!
    from_ts: String!
    to_ts: String!
  ): testTrackingHistory

  #
  getOverspeedInstancesByTripId(tripId: Int!): [OverspeedInstance]

  #
  getTrackNontrackVehiclesCount(clientLoginId: Int!): trackVehiclesCount!

  #
  getDayWiseReport(
    uniqueId: String!
    startTime: String!
    endTime: String!
    timezone: String
  ): [DayWiseReportObject!]!

  #
  getConsolidatedReport(
    uniqueId: String!
    start_ts: String!
    end_ts: String!
    timezone: String
  ): ConsolidatedReportObject

  #
  getCategoryOneReport(
    clientLoginId: Int!
    customReportName: String!
    uniqueId: String!
    start_ts: String!
    end_ts: String!
    timezone: String
    offset: Int
  ): [CategoryOneObject]

  #
  getOBDReport(
    clientLoginId: Int!
    uniqueId: String!
    start_ts: String!
    end_ts: String!
    timezone: String
  ): [CategoryOBDObject!]!

  #
  getCategoryTwoReport(
    clientLoginId: Int!
    reportType: String
    customReportName: String!
    uniqueId: String!
    start_ts: String!
    end_ts: String!
    timezone: String
  ): [CategoryTwoObject]

  #
  getCategoryThreeReport(
    clientLoginId: Int!
    customReportName: String!
    uniqueId: String!
    start_ts: String!
    end_ts: String!
    timezone: String
  ): CategoryThreeObject

  #
  getConsolidatedData(
    uniqueId: String!
    start_ts: String!
    end_ts: String!
    timezone: String
  ): CategoryThreeObject

  #
  getReportPagination(
    clientLoginId: Int!
    category: Int!
    reportType: String
    customReportName: String!
    uniqueId: String!
    start_ts: String!
    end_ts: String!
    timezone: String
    previousDist: Float
    offset: Int
  ): reportPagination

  #
  getReportDownloadLink(
    clientLoginId: Int!
    category: Int!
    reportType: String
    customReportName: String!
    uniqueIds: [String!]!
    start_ts: String!
    end_ts: String!
    timezone: String
    fileType: fileTypes
    offset: Int
  ): reportDownloadLink

  #
  getKmSummary(
    # UTC time
    from_ts: String!

    # UTC time
    to_ts: String!

    #
    frequency: KMFREQUENCY

    #
    timezone: String
  ): [dailyDistance]

  #
  getFleetDownloadLink(timeRange: TimeRange!): DownloadLink

  #
  getCurrentTrackinfo(
    clientLoginId: Int
    partnerLoginId: Int
    superAdminLogin: Boolean
  ): [currentTrackinfoObj]

  #
  getIdleCurrentTrackinfo(
    clientLoginId: Int
    partnerLoginId: Int
    superAdminLogin: Boolean
  ): [idleCurrentTrackinfoObj]

  #
  getVehicleAnayticData(
    clientLoginId: Int
    timestamp: String
  ): [vehicleAnayticDataObj]

  #
  getNumberOfPackets(
    uniqueIds: [String]!
    from_ts: String!
    to_ts: String!
  ): [NumberOfPackets]

  #
  getSMSHistory(from_ts: String!, to_ts: String!): fetchSmsDataReponse

  #
  getWhatsappHistory(from_ts: String!, to_ts: String!): fetchwhatsappDataReponse

  #
  getEmailHistory(from_ts: String!, to_ts: String!): fetchEmailDataReponse

  #
  getLatestLocation(uniqueId: String!): LocationData

  #
  getLatestDeviceData(uniqueId: String!): LatestData

  #
  getOBDFleetHealth(clientLoginId: Int!): HealthDistribution

  #
  getCurrentSummaryDetails(
    partnerLoginId: Int
    clientLoginId: Int
    uniqueId: String
  ): [getCurrentSummaryData]

  #
  getOverspeedDetails(
    uniqueIds: [String]!
    startTime: String
    endTime: String
    fileType: fileTypes
    speedLimit: Int!
    timezone: String
  ): [getOverspeedData]

  #
  getWeeklySummary(
    startDate: String!
    endDate: String!
    vehicleNumber: String!
  ): getWeeklySummaryData

  #
  getRMSFleetAnalytics(
    uniqueIds: [String]
    timeRange: TimeRange!
  ): RMSFleetAnalytics

  #
  getWPPTrendAndSales(uniqueIds: [String!]!, timeRange: TimeRange!): WPPTrend

  #
  getDistrictData(districtName: String!): DistrictData

  #
  getTalukData(talukName: String!): TalukData

  #
  getTPMSaggregates(from_ts: String!, to_ts: String!): [TPMSaggregates]

  #
  getTPMSalerts(from_ts: String!, to_ts: String!): [TPMSalerts]

  #
  getAlertHistory(
    alerttype: AlertTypeMaster!
    tripid: Int
    areaId: Int
    vehicleId: Int
  ): [alertHistory]!

  #
  getParkingStatus(deviceId: String!): Boolean!

  #
  getWPPSalesReport(
    uniqueIds: [String!]!
    timeRange: TimeRange
    start_ts: String
    end_ts: String
    threshold: Int
  ): WPPSalesReport

  #
  getDispenseSummaryReport(
    uniqueIds: [String!]!
    timeRange: TimeRange
    start_ts: String
    end_ts: String
  ): DispenseSummary

  #
  getTdsReport(
    uniqueIds: [String!]!
    timeRange: TimeRange
    start_ts: String
    end_ts: String
  ): [TdsReportData]

  #
  getTDSQualityReport(
    uniqueIds: [String!]!
    timeRange: TimeRange
    start_ts: String
    end_ts: String
  ): [TDSQualityReport]

  #
  getWPPDownTimeReport(
    timeRange: TimeRange
    start_ts: String
    end_ts: String
  ): [DownTimeReport]

  #
  getWPPVillageData(uniqueId: String!, villageName: String!): VillageData

  #
  getWPPData(
    districtIds: [Int]
    talukIds: [Int]
    panchayatIds: [Int]
    villageIds: [Int]
    uniqueIds: [String]
    start_ts: String
    end_ts: String
  ): WppData

  #
  getWPPStatistics(
    districtIds: [Int]
    talukIds: [Int]
    panchayatIds: [Int]
    villageIds: [Int]
    uniqueIds: [String]
    start_ts: String
    end_ts: String
  ): talukDataParam

  #
  getDistrictWPPAndRMSData(
    districtIds: [Int]
    talukIds: [Int]
    panchayatIds: [Int]
    villageIds: [Int]
    uniqueIds: [String]
  ): DistrictData

  #
  getRMSAndWPP(timeLine: String!, type: String!): [[String]]

  #
  getTripCountReport(start_ts: String!, end_ts: String!): [TripCount]

  #
  getReportDetails(
    clientLoginId: Int!
    category: Int!
    reportType: String
    uniqueIds: [String!]
    start_ts: String!
    end_ts: String!
  ): reportPagination

  #
  getReportData(
    category: Int!
    reportType: String
    vin: String!
    start_ts: String!
    end_ts: String!
  ): reportPagination

  #
  getPreProcessedReportDownloadLink(
    clientLoginId: Int!
    category: Int!
    reportType: String
    customReportName: String!
    uniqueIds: [String!]!
    start_ts: String!
    end_ts: String!
    timezone: String
    fileType: fileTypes
    offset: Int
  ): reportDownloadLink

  #
  wppPdfDownloadReport(
    uniqueIds: [String!]!
    start_ts: String!
    end_ts: String!
    reportName: String!
    threshold: Int
  ): wppPdfDownloadLink

  #
  getChargeHistoryNew(
    #
    vin: String!

    # Date Format is YYYY-MM-DD HH:mm:ss
    startDateTime: String

    # Date Format is YYYY-MM-DD HH:mm:ss
    endDateTime: String

    #
    no_of_records: Int
  ): ChargeHistoryResponseNew!

  #
  homeChargerChargingHistory(
    #
    vin: String!

    # Date Format is DD/MM/YYYY hh:mm:ss In UTC
    from_date: String

    # Date Format is DD/MM/YYYY hh:mm:ss In UTC
    to_date: String
  ): HCChargingHistoryResponse!

  #
  getChargeHistory(
    #
    vin: String!

    # Date Format is YYYY-MM-DD HH:mm:ss
    startDateTime: String!

    # Date Format is YYYY-MM-DD HH:mm:ss
    endDateTime: String!
  ): ChargeHistoryResponse!

  #
  getTripPoints(
    #
    vin: String!

    # Date Format is YYYY-MM-DD HH:mm:ss
    startDateTime: String!

    # Date Format is YYYY-MM-DD HH:mm:ss
    endDateTime: String!
  ): tripHistory!

  #
  getChargeSummary(
    #
    vin: String!

    # Date Format is YYYY-MM-DD HH:mm:ss
    startDateTime: String!

    # Date Format is YYYY-MM-DD HH:mm:ss
    endDateTime: String!
  ): chargeSummaryresponse!

  #
  getTripHistory(
    vin: String!
    start_datetime: String!
    end_datetime: String!
  ): tripDataResponse

  #
  getTripHistoryNew(
    vin: String!
    start_datetime: String
    end_datetime: String
    no_of_records: Int
  ): tripDataResponseNew

  #
  getChargingStationsWithLatLong(
    #
    organizationId: Int!

    # Radius in meters and min is 10 mtr and max is 10000000 meters
    radius: Float!

    #
    latitude: Float!

    #
    longitude: Float!
  ): ChargingStationsResponse

  #
  getAllGeofenceAlerts(
    vin: String!
    userId: String!
    startDateTime: String
    endDateTime: String
    geofenceIds: [Int]
  ): allGeofenceAlertsResponse

  #
  fetchData(
    vin: String!
    start_time: String
    end_time: String
    select_fields: [String]
    where: String
  ): fetchDataReponse

  #
  getCommandList(
    vin: String
    command_display: String
    from_ts: String
    to_ts: String
  ): getCommandListResponse

  #
  getCommandStatus(
    uniqueIds: [String!]!
    command: String
    from_ts: Int
    to_ts: Int
  ): [commandStatus]

  #
  getLatestCommandStatus(uniqueId: String!, command: String!): [commandStatus]

  #
  getHomeChargerSettings(vin: String!): getHomeChargerSettingsResponse

  #
  getHomeChargerCommandStatus(
    vin: String!
    commands: [hcCommandsEnum]
  ): getHomeChargerCommandStatusResponse

  #
  getVehicleSettings(
    vin: String!
    app_user_id: String
  ): getVehicleCommandResponse

  #
  getVehicleCommandStatus(
    vin: String!
    app_user_id: String!
    commands: [vehicleCommandsEnum]
  ): getVehicleCommandStatusResponse

  #
  getAllActivitiesByUniqueId(
    uniqueId: String!
    fromTs: String!
    toTs: String!
  ): [Activity]!

  #
  getActivitySummary(
    # Vehicle Number registered in the client login
    vehicleNumber: String!

    # Start Date and Time of the activity
    startDate: String!

    # End Date and Time of the activity
    endDate: String!
  ): [CustomActivityObject]

  #
  getAllActivitiesByClientLoginId(
    clientLoginId: Int!
    fromTs: String
    toTs: String
    period: period
  ): [Activity]!

  #
  getDrivingScoreByUniqueId(uniqueId: String!): [Score]

  #
  getAllScores: [Details_Score]

  #
  getPastThreeMonthActivityDistance(uniqueId: String!): Log9Data

  #
  getAllActivitiesByDriverId(
    driverId: Int!
    fromTs: String
    toTs: String
    period: period
  ): [Activity]!

  #
  getLatestActivityByDriverId(driverId: Int): Activity

  #
  getWeeklyActivityByDriverId(driverId: Int): TotalWeeklyActivity

  #
  getVehicleDrivenHistory(
    driverId: Int!
    fromTs: String
    toTs: String
  ): [VehicleDriven]

  #
  getConfigureCommandStatus(uniqueid: String!, id: Int!): [allData]

  #
  getPidsConfigureStatus(uniqueid: String!, id: Int!): [allData2]

  #
  getTripScore(
    vin: String!
    start_datetime: String!
    end_datetime: String!
  ): tripScoreResponse

  #
  getTripScoreNew(
    vin: String!
    start_datetime: String!
    end_datetime: String!
  ): tripScoreResponse

  #
  getDriverScore(
    vin: String!
    start_datetime: String!
    end_datetime: String!
  ): driverScoreResponse

  #
  getDriverScoreNew(
    vin: String!
    start_datetime: String!
    end_datetime: String!
  ): driverScoreResponse

  #
  getChargeScore(
    vin: String!
    start_datetime: String!
    end_datetime: String!
  ): chargeScoreResponse

  #
  getChargeScoreNew(
    vin: String!
    start_datetime: String!
    end_datetime: String!
  ): chargeScoreResponse

  #
  getDayScore(
    vin: String!
    start_datetime: String!
    end_datetime: String!
  ): dayScoreResponse

  #
  getDayScoreNew(
    vin: String!
    start_datetime: String!
    end_datetime: String!
  ): dayScoreResponse

  #
  getChargingStationsAlongRoute(
    route_details: [route_Array!]
    buffer_distance: Float!
    dte: [Float!]!
    vin: String!
  ): ChargingStationsAlongRouteResponse!

  #
  getChargingStationsByKazam(
    # The latitude of the user, around which charge points are to be located.
    latitude: Float!

    # The longitude of the user, around which charge points are to be located.
    longitude: Float!

    # The radius of the sphere in kilometres from the with loc as the center, in
    # range of which Charge Points are to be located. (Default is 5km)
    radius: Float!

    # When set to true, returns the human-readable version of the address of the Charger, along with location coordinates.
    fullAddress: Boolean
  ): getChargeStationsResponse

  #
  getTransactionsByKazam(
    vin: String!
    app_user_id: String!
    host_id: String!
    start_time: String!
    end_time: String!
  ): getTransactionsResponse

  #
  getLatestTransactionsByKazam(
    vin: String!
    app_user_id: String!
    device_id: String!
  ): getLatestTransactionsResponse

  #
  getTransactionDetailsByKazam(
    vin: String!
    app_user_id: String!
    txn_id: String!
  ): getTransactionDetailsResponse

  #
  getDeviceStateByKazam(
    vin: String!
    app_user_id: String!
    device_id: String!
  ): getDeviceStateResponse

  #
  enableDeviceByKazam(
    vin: String!
    app_user_id: String!
    device_id: String!
  ): enableDeviceResponse

  #
  disableDeviceByKazam(
    vin: String!
    app_user_id: String!
    device_id: String!
  ): disableDeviceResponse

  #
  getTariffDetailsByKazam(
    vin: String!
    app_user_id: String!
    tariff_id: String!
  ): getTariffDetailsResponse

  #
  getCurrentWeatherData(
    lat: Float!
    lon: Float!
    units: unitsEnum!
    lang: enumLang
  ): currentWeatherDataResponse

  #
  getHourlyForecastData(
    lat: Float!
    lon: Float!
    units: unitsEnum!
    lang: enumLang
  ): HourlyForecastDataResponse

  #
  getCityData(id: Int, lang: enumLang): HourlyForecastDataResponse

  #
  getCricketMatchList(
    # Page number for request
    paged: Int

    # Number of competition to list in each api request
    per_page: Int

    # yyyy-mm-dd
    from_time: String

    # yyyy-mm-dd
    to_time: String

    #
    timezone: String

    #
    status: statusEnum

    #
    vin: String
  ): getCrricketMatchResponse

  #
  getFootballMatchList(
    # Page number for request
    paged: Int

    # Number of competition to list in each api request
    per_page: Int

    # yyyy-mm-dd
    from_time: String

    # yyyy-mm-dd
    to_time: String

    #
    timezone: String

    #
    status: footballStatusEnum

    #
    vin: String
  ): getFootballMatchListResponse

  #
  startTransactionByKazam(
    vin: String!
    app_user_id: String!
    device_id: String!
    txn_id: String!
    connector_id: Int
    start_time: String!
    duration: Int!
    user_id: String!
    usage_limit: Float
  ): startTransactionResponse

  #
  stopTransactionByKazam(
    vin: String!
    app_user_id: String!
    device_id: String!
    connector_id: Int!
  ): stopTransactionResponse

  #
  configDeviceByKazam(
    vin: String!
    app_user_id: String!
    device_id: String!
    host_id: String
    device_group: String
    location: String
    rate: Int
    theft_state: Int
  ): configDeviceResponse

  #
  configDeviceThresoldByKazam(
    vin: String!
    app_user_id: String!
    device_id: String!
    cp_cmd: Int
    vthresh: Int
  ): configDeviceThresoldResponse

  #
  getCurrentAirPollutionData(
    lat: Float!
    lon: Float!
    vin: String
  ): CurrentAirPollutionDataResponse

  #
  getDailyWeatherForecastData(
    lat: Float!
    lon: Float!
    days: Int
    vin: String
    units: unitsEnum!
    lang: enumLang
  ): getDailyWeatherForecastDataResponse

  # if  we send request as fromTime and toTime then response will be list of
  # common shared between that time,else latest one destination will be shared
  getAllSharedDestinations(
    # userId will be phone number,taking from simDetails
    fromUserId: String!

    # vehicle Identification Number
    vin: String!

    # placeId length range should be 3 to 255
    placeId: String

    #
    no_of_records: Int
  ): AllSharedLocationsResponse

  #
  getAllFavoriteLocations(
    # userId will be phone number,taking from simDetails
    fromUserId: String!

    # vehicle Identification Number
    vin: String!

    # placeId length range should be 3 to 255
    placeId: String

    #
    no_of_records: Int
  ): allLocationResponse

  #
  getAllRecentLocations(
    # userId will be phone number,taking from simDetails
    fromUserId: String!

    # vehicle Identification Number
    vin: String!

    # placeId length range should be 3 to 255
    placeId: String

    #
    no_of_records: Int
  ): allLocationResponse

  #
  getTravelHistoryNew(
    uniqueId: String!
    from: String!
    to: String!
    simplify: Boolean
    snapToRoad: Boolean
  ): TravelHistoryNew!

  #
  getTimeRangeLocationDataNew(
    uniqueId: String!
    from: String!
    to: String!
  ): [RawLocationDataNew!]!

  #
  getApiStatistics(
    api_name: String
    vin: String
    app_user_id: String
    from_time: String
    to_time: String
  ): getApiStatResponse

  #
  fetchClusterChargeSessionSummary(
    vin: String!
    app_user_id: [String!]!
    from_time: String
    to_time: String
  ): fetchClusterChargeSessionSummaryResponse

  #
  fetchClusterCumulativeChargeSessionSummary(
    vin: String!
    app_user_id: [String!]!
  ): CumulativeChargeSessionSummaryResponse

  #
  getRideDetails(
    vin: String!
    app_user_id: String!
    type: Int!
    travelId: Int
    travelStartDateTime: String
    travelEndDateTime: String
    tourStartDateTime: String
    tourEndDateTime: String
    lastInfo: Boolean
  ): rideDetailsResponse

  #
  getVehicleOverview(
    vin: String!
    app_user_id: String!
    vehicleTypeId: Int!
  ): getVehicleOverViewResponse

  #
  getRidingPattern(
    vin: String!
    app_user_id: String!
    vehicleTypeId: Int!
  ): getRidingPatternResponse

  #
  getAllDeviceLocations(
    filters: Filters
    configs: Configs
  ): [DeviceTrackingData!]!

  #
  getDeviceLatestLocation(deviceId: String!): DeviceTrackingData!

  #
  getAllDeviceLocationsAdditionalStatuses(
    filters: Filters
    configs: Configs
  ): [DeviceTrackingData!]!

  #
  getTvsmLatestDeviceData(vin: String!): LiveDataTrackingResponse

  #
  getHomechargerLatestData(vin: String!): HomechargerDataResponse

  #
  getBatteriesLatestData(vin: String!): BatteriesLatestDataResponse

  #
  fetchClusterRideSessionSummary(
    vin: String!
    app_user_id: [String!]!
    from_time: String
    to_time: String
  ): fetchClusterRideSessionSummaryResponse

  #
  fetchClusterCumulativeRideSessionSummary(
    vin: String!
    app_user_id: [String!]!
  ): fetchClusterCumulativeRideSessionSummaryResponse
}

#
type ServiceProvider {
  #
  id: Int!

  #
  name: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type DeviceModel {
  #
  id: Int!

  #
  model_name: String!

  #
  vehicleTypeId: Int

  #
  version: Float!

  #
  devicetype: String!

  #
  description: String

  #
  series: String

  #
  theme: String

  #
  maxPrice: Int

  #
  manufacturer: Manufacturer!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type Manufacturer {
  #
  id: Int!

  #
  manufacturerName: String!

  #
  manufacturerCode: String!

  #
  email: String!

  #
  contactPerson: String!

  #
  contactNumber: String!

  #
  address: String!

  #
  city: String!

  #
  state: StateModel!

  #
  country: CountryModel!

  #
  pincode: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!

  #
  manufacturedDevices: [DeviceDetail!]
}

#
type StateModel {
  #
  zone_id: Int!

  #
  country_id: Int!

  #
  code: String!

  #
  name: String!

  #
  status: Int!
}

#
type CountryModel {
  #
  country_id: Int!

  #
  name: String!

  #
  iso_code_2: String!

  #
  iso_code_3: String!

  #
  address_format: String!

  #
  postcode_required: Int!

  #
  status: Int!

  #
  states: [StateModel!]
}

#
type DeviceDetail {
  #
  serial_num: String!

  #
  imei_num: String!

  #
  uniqueDeviceId: String!

  #
  ownerLoginId: Int

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  vehicleDetail: VehicleDetail

  #
  status: Int!

  #
  deviceModelId: DeviceModel!

  #
  manufacturer: Manufacturer!

  #
  clientName: String

  #
  clientDetails: ClientDetail

  #
  partnerDetails: PartnerDetail
}

#
type VehicleDetail {
  #
  entityId: Int!

  #
  vehicleNumber: String!

  #
  engineNumber: String

  #
  averageMileage: Int

  #
  chassisNumber: String

  #
  client: ClientDetail!

  #
  device: DeviceDetail!

  #
  sim: SimDetail!

  #
  speedSensorType: String!

  #
  speedLimit: Int!

  #
  vehicleType: String!

  #
  vehicleModel: String!

  #
  vehicleCapacity: Int

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  activatedAt: String!

  #
  deactivatedAt: String!

  #
  status: Int!

  # Invoice number (optional)
  invoiceNumber: String

  # Equipment serial number (optional)
  equipmentSerialNumber: String

  # Equipment serial number (optional)
  equipmentName: String

  # Commissioning date
  commissioningDate: Int

  #
  department: String

  #
  certificatePath: String

  #
  approveStatus: String

  #
  idlingSpeed: Int

  #
  generatorCapacity: Int

  #
  averageConsumption: Int

  #
  tankCapacity: Int

  #
  vehicleGroupAssign: String

  #
  contractorName: String

  #
  operatorName: String

  #
  operatorContactNumber: String
}

#
type ClientDetail {
  #
  id: Int!

  #
  clientName: String!

  #
  email: String

  #
  partnerLoginId: Int!

  #
  contactPerson: String!

  #
  contactNumber: String!

  #
  loginId: Int!

  #
  login: Login!

  #
  plan: Plans

  #
  address: String!

  city: String!

  #
  wallet: Int

  #
  simWallet: Int

  #
  billingMode: BillingMode!

  #
  solution: String

  #
  salesPerson: SalesPerson

  #
  state: StateModel

  #
  country: CountryModel!

  #
  countryId: Int!

  #
  pincode: Int

  #
  panNumber: String

  #
  gst: String

  #
  clientType: String!

  #
  timezone: String!

  #
  lat: Float

  #
  long: Float

  #
  weights: JSON

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  partner: PartnerDetail

  #
  reseller: ResellerDetails

  #
  licenseType: LicenseType

  #
  status: Int!

  #
  totalAssignedVehicle: Int!

  #
  totalDevices: Int!

  #
  totalRegisteredDevices: Int!

  #
  totalUnregisteredDevices: Int!

  #
  assignedFeatures: [Features!]!

  #
  type: ClientPartnerType

  #
  expiryDate: String

  #
  trackingDetails: TRACKINGDETAILS

  #
  isERP: Boolean

  #
  totalClientVehicles: Int

  #
  registrationType: String

  #
  secondaryContactName: String

  #
  secondaryContactNumber: String

  #
  secondaryEmail: String

  #
  shippingAddress: String

  #
  shippingCountry: CountryModel

  #
  shippingState: StateModel

  #
  shippingCity: String

  #
  shippingPincode: Int

  #
  minimumTrackedDays: Int!

  #
  packetThreshold: Int

  #
  prorata: Int!

  #
  addressEffectiveDate: String
}

#
type Login {
  #
  loginId: Int!

  #
  username: String!

  #
  accountType: String!

  #
  status: Int!

  #
  lastLoginTime: String
}

#
type Plans {
  #
  id: Int!

  #
  planName: String!

  #
  description: String!

  #
  featureList: [Features!]

  #
  costPerAsset: Int!

  #
  partnerLoginId: Int

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  numberOfAssociatedClient: Int!

  #
  status: Int!
}

#
type Features {
  #
  id: Int!

  #
  featureKey: String!

  #
  featureName: String!

  #
  costPerAssetPerMonth: Int!

  #
  featureDescription: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type BillingMode {
  #
  id: Int!

  #
  billingMode: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type SalesPerson {
  #
  id: Int!

  #
  name: String!

  #
  contactNumber: String!

  #
  email: String!

  #
  address: String

  #
  partnerLoginId: Int!

  #
  clientLoginId: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int
}

scalar JSON

#
type PartnerDetail {
  #
  id: Int!

  #
  businessName: String!

  #
  email: String!

  #
  contactPerson: String!

  #
  contactNumber: String!

  #
  billingMode: BillingMode!

  #
  login: Login!

  #
  address: String!

  #
  domain: String

  #
  city: String!

  #
  state: StateModel!

  #
  country: CountryModel!

  #
  pincode: Int!

  #
  panNumber: String!

  #
  partnerType: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!

  #
  clients: [ClientDetail!]

  #
  assignDevices: [DevicePartnerAssign!]

  #
  assignSIMs: [SimPartnerAssign!]

  #
  type: ClientPartnerType

  #
  SalesPerson: SalesPerson

  #
  wallet: Int

  #
  simWallet: Int

  #
  solution: Solution!

  #
  totalRegisteredVehicles: Int

  #
  deviceCount: DeviceCount

  #
  simCount: SimCount
}

#
type DevicePartnerAssign {
  #
  id: Int!

  #
  device: DeviceDetail!

  #
  partner: PartnerDetail!

  #
  deviceModel: DeviceModel!

  #
  uniqueDeviceId: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type SimPartnerAssign {
  #
  id: Int!

  #
  sim: SimDetail!

  #
  partner: PartnerDetail!

  #
  serviceProvider: ServiceProvider!

  #
  simId: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type SimDetail {
  #
  id: Int!

  #
  phoneNumber: String!

  #
  simNumber: String!

  #
  ownerLoginId: Int!

  #
  monthlyCharges: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!

  #
  serviceProviderId: Int

  #
  serviceProvider: ServiceProvider!

  #
  clientName: String

  #
  superAdmin: Boolean

  #
  clientDetails: ClientDetail

  #
  partnerDetails: PartnerDetail

  #
  vehicleDetails: VehicleDetail
}

#
enum ClientPartnerType {
  #
  DEMO

  #
  REAL
}

# The type of solution client need
enum Solution {
  #
  API

  #
  PORTAL

  #
  PORTAL_API
}

#
type DeviceCount {
  #
  totalDevices: Int!

  #
  inStockDevices: Int!

  #
  assignedToClientDevices: Int!

  #
  registeredDevices: Int!
}

#
type SimCount {
  #
  totalSims: Int!

  #
  inStockSims: Int!

  #
  assignedToClientSims: Int!

  #
  registeredSims: Int!
}

#
type ResellerDetails {
  #
  id: Int!

  #
  resellerName: String!

  #
  email: String!

  #
  contactPerson: String!

  #
  contactNumber: String!

  #
  login: Login!

  #
  address: String!

  #
  city: String!

  #
  state: StateModel!

  #
  country: CountryModel!

  #
  pincode: Int!

  #
  panNumber: String!

  #
  gst: String

  #
  freePeriod: Int

  #
  bufferPeriod: Int

  #
  discountPercentage: Int

  #
  defaultBillingFrequency: BillingFrequency

  #
  licenseExpiryPeriod: Int!

  #
  assignedDeviceModels: [DeviceModel!]!

  #
  assignedLicenseType: [LicenseType!]!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type BillingFrequency {
  #
  id: Int!

  #
  frequency: String!

  #
  billingModeId: Int!

  #
  numberOfMonths: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type LicenseType {
  #
  id: Int!

  #
  licenseType: String!

  #
  description: String!

  #
  featureList: [Features!]

  #
  maxPrice: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  numberOfAssociatedClient: Int

  #
  status: Int!
}

#
type TRACKINGDETAILS {
  #
  trackingCount: Int!

  #
  nonTrackingCount: Int!
}

#
enum DeviceStatus {
  #
  DEVICE_ADDED

  #
  ASSIGNED_TO_CLIENT

  #
  REGISTERED_TO_VEHICLE

  #
  ALL
}

#
type DeviceDetailResponse {
  #
  serial_num: String!

  #
  imei_num: String!

  #
  uniqueDeviceId: String!

  #
  ownerLoginId: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  vehicleDetail: vehicleDetailsResponse

  #
  status: String!

  #
  deviceModel: DeviceModel!

  #
  manufacturer: Manufacturer!

  #
  clientName: String
}

#
type vehicleDetailsResponse {
  #
  entityId: Int!

  #
  vehicleNumber: String!

  #
  averageMileage: Int

  #
  speedSensorType: String!

  #
  vehicleType: String!

  #
  vehicleModel: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: String!
}

#
type DeviceCountByDeviceModel {
  #
  id: Int!

  #
  model_name: String!

  #
  version: Float!

  #
  devicetype: String!

  #
  deviceCount: Int!
}

#
type activationStatus {
  #
  device_mapping: device_mapping

  #
  status: Int!

  #
  statusMessage: String!
}

#
type device_mapping {
  #
  userIds: [String!]

  #
  unitId: String!

  #
  vin: String!
}

#
enum SimStatus {
  #
  SIM_ADDED

  #
  ASSIGNED_TO_CLIENT

  #
  REGISTERED_TO_VEHICLE

  #
  ALL
}

#
type SimDetailResponse {
  #
  id: Int!

  #
  phoneNumber: String!

  #
  simNumber: String!

  #
  ownerLoginId: Int!

  #
  monthlyCharges: Int!

  #
  createdAt: String!

  #
  vehicleDetail: vehicleDetailsResponse

  #
  updatedAt: String!

  #
  status: String!

  #
  serviceProvider: ServiceProvider!

  #
  clientName: String
}

#
type SimCountByOperator {
  #
  id: Int!

  #
  name: String!

  #
  simCount: Int!
}

# Response type for login API
type AuthPayload {
  # Token generated for the login. Expire time is pre defined.
  token: String

  # Refresh token generated for the login. Expire time is greater than normal token.
  refreshToken: String

  # Login object.
  login: Login
}

# Response for logoutTokenAPI.
type newLoginWithOTPResponse {
  #
  status: Int

  #
  loginStatus: Boolean

  #
  statusMessage: String
}

# Response for logoutTokenAPI.
type logoutResponse {
  #
  token: String!
}

# Response type for generateAuthTokenAPI API
type AuthToken {
  #
  token: String
}

#
type validateOtpResponse {
  #
  token: String

  #
  refreshToken: String

  #
  login: Login

  #
  status: Int

  #
  statusMessage: String
}

#
type liveLocSharingToken {
  #
  token: String!

  #
  vehicleDetails: vehicleData
}

#
type vehicleData {
  #
  entityId: Int!

  #
  uniqueDeviceId: String!

  #
  vehicleNumber: String!

  #
  serialNum: String!
}

#
type GSTDetails {
  #
  status: String

  #
  panNumber: String

  #
  companyName: String

  #
  address: String

  #
  pinCode: String
}

#
type ManufacturerPartnerAssign {
  #
  id: Int!

  #
  manufacturer: Manufacturer!

  #
  partner: PartnerDetail!

  #
  manufacturerId: Int!

  #
  partnerLoginId: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: String!
}

#
type DeviceModelPartnerAssign {
  #
  id: Int!

  #
  manufacturer: Manufacturer!

  #
  partner: PartnerDetail!

  #
  deviceModel: DeviceModel!

  #
  deviceModelId: Int!

  #
  manufacturerId: Int!

  #
  partnerLoginId: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: String!
}

#
type PartnerDeviceStockDetail {
  #
  modelId: Int

  #
  modelName: String!

  #
  totalAssignedDevice: Int!

  #
  totalAssignedDeviceToClient: Int!

  #
  totalRegisteredDevice: Int!

  #
  availableStock: Int!
}

#
input DeviceListInput {
  #
  serial_num: String!

  #
  uniqueDeviceId: String!
}

#
type DeviceAvailabilityVerification {
  #
  serial_num: String!

  #
  uniqueDeviceId: String!
}

#
type ClientDeviceStock {
  #
  totalAssignedDevice: Int!

  #
  totalRegisteredDevice: Int!

  #
  totalUnRegisteredDevice: Int!
}

#
type PartnerSimStockDetail {
  #
  simProviderId: Int

  #
  serviceProviderName: String!

  #
  totalAssignedSim: Int!

  #
  totalAssignedSimToClient: Int!

  #
  totalRegisteredSim: Int!

  #
  availableStock: Int!
}

#
input SimListInput {
  #
  simNumber: String!
}

#
type SimAvailabilityVerification {
  #
  simNumber: String!
}

#
type ClientSOC {
  #
  threshold: Float
}

#
type clientOffline {
  #
  offlineSeconds: Int
}

#
type VehicleDeviceDetail {
  #
  entityId: Int!

  #
  vehicleNumber: String!

  #
  engineNumber: String

  #
  chassisNumber: String

  #
  deviceDetail: DeviceDetail!

  #
  simDetail: SimDetail!

  #
  vehicleGroupAssign: String

  #
  speedSensorType: String!

  #
  speedLimit: Int!

  #
  vehicleType: String!

  #
  vehicleModel: String!

  #
  vehicleMake: String

  #
  vehicleCapacity: Int

  #
  panicType: String

  #
  averageMileage: Int

  # Invoice number (optional)
  invoiceNumber: String

  # Equipment serial number (optional)
  equipmentSerialNumber: String

  # Equipment serial number (optional)
  equipmentName: String

  # Commissioning date
  commissioningDate: Int

  #
  department: String

  #
  idlingSpeed: Int

  #
  certificatePath: String

  #
  approveStatus: String

  # Initial x coordinate
  ref_x: Float

  # Initial y coordinate
  ref_y: Float

  # Initial z coordinate
  ref_z: Float

  #
  contractorName: String

  #
  operatorName: String

  #
  operatorContactNumber: String

  #
  model: String

  #
  variant: String

  #
  primary_app_user_id: String

  #
  homeChargerDetails: homeChargerDetails
}

#
type homeChargerDetails {
  #
  hc_imei: String
}

#
type VehicleDeviceDetailClient {
  #
  entityId: Int!

  #
  vehicleNumber: String!

  #
  engineNumber: String

  #
  chassisNumber: String

  #
  deviceUniqueId: String

  #
  deviceDetail: DeviceDetail!

  #
  simDetail: SimDetail!

  #
  simId: Int

  #
  speedSensorType: String!

  #
  speedLimit: Int!

  #
  vehicleType: String!

  #
  vehicleModel: String!

  #
  vehicleMake: String

  #
  vehicleCapacity: Int

  #
  averageMileage: Int
}

#
type VehicleDeviceDetails {
  #
  createdAt: String

  #
  entityId: Int!

  #
  vehicleNumber: String!

  #
  engineNumber: String

  #
  chassisNumber: String

  #
  deviceDetail: DeviceDetail!

  #
  simDetail: SimDetail!

  #
  clientName: String!

  #
  vehicleGroupAssign: String

  #
  partnerLoginId: Int

  #
  partnerName: String

  #
  speedSensorType: String!

  #
  speedLimit: Int!

  #
  vehicleType: String!

  #
  vehicleModel: String!

  #
  vehicleCapacity: Int

  #
  panicType: String

  #
  driverName: String

  # Invoice number (optional)
  invoiceNumber: String

  # Equipment serial number (optional)
  equipmentSerialNumber: String

  # Equipment serial number (optional)
  equipmentName: String

  # Commissioning date
  commissioningDate: Int

  #
  department: String

  #
  idlingSpeed: Int

  #
  certificatePath: String

  #
  approveStatus: String

  #
  timeZone: String

  #
  clientLoginId: Int

  #
  overSpeedThreshold: Float
}

#
type VehicleDataForInvoice {
  #
  entityId: Int!

  #
  vehicleNumber: String!

  #
  uniqueDeviceId: String!

  #
  createdAt: String!

  #
  activatedAt: String

  #
  deactivatedAt: String
}

#
enum STATUS {
  #
  ACTIVE

  #
  DEACTIVE

  #
  INACTIVE

  #
  SERVICE
}

#
type VehicleCount {
  #
  totalRegisteredVehicle: Int!

  #
  totalActiveVehicle: Int!

  #
  totalInActiveVehicle: Int!

  #
  totalServicedVehicle: Int!

  #
  totalDeactiveVehicle: Int!
}

#
type boardedVehicleDetails {
  #
  deviceManufacturer: String!

  #
  deviceModel: String!

  #
  deviceSerialNo: String!

  #
  deviceImeiNo: String!

  #
  simProvider: String!

  #
  simPhoneNumber: String!

  #
  vehicleNumber: String!

  #
  vehicleMake: String

  #
  vehicleModel: String!

  #
  vehicleType: String!

  #
  averageMileage: Int!
}

#
enum DeviceModels {
  #
  TS_101_Basic_Hybrid

  #
  OBD2

  #
  TS101

  #
  S101

  #
  U101

  #
  R101

  #
  TS101_Basic

  #
  TS101_Advance

  #
  S101_PLUS_1

  #
  B101V2

  #
  Bharat_101_1

  #
  RE_CONNECT_1

  #
  RE_CONNECT_2
}

#
enum ServiceProviders {
  #
  AIRTEL

  #
  IDEA

  #
  VODAFONE
}

#
type vehicleMMMTCResponse {
  #
  mmtc: Int!

  #
  subscriptionId: Int

  #
  clientLoginId: Int
}

#
type Excavator {
  #
  vehicleNumber: String!

  #
  vehicleType: String

  #
  vehicleModel: String

  #
  uniqueId: String!

  #
  phoneNumber: String

  #
  speedSensorType: String

  #
  speedLimit: Int

  #
  panicType: String

  #
  averageMileage: Float

  #
  idlingSpeed: Int

  #
  contractorName: String

  #
  vehicleGroups: [String]
}

#
type Truck {
  #
  vehicleNumber: String!

  #
  vehicleType: String

  #
  vehicleModel: String

  #
  uniqueId: String!

  #
  phoneNumber: String

  #
  speedSensorType: String

  #
  speedLimit: Int

  #
  panicType: String

  #
  averageMileage: Float

  #
  idlingSpeed: Int

  #
  contractorName: String

  #
  vehicleGroups: [String]
}

#
type UserVehicle {
  #
  vehicleNumber: String
}

#
type Alerts {
  #
  id: Int!

  #
  alertName: String!

  #
  alertType: String!

  #
  alertDescription: String!

  #
  valueType: String

  #
  valueStatus: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type ClientAlertAssignDetail {
  #
  id: Int!

  #
  alert: Alerts!

  #
  valueOption: [ValueOption!]

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type ValueOption {
  #
  id: Int

  #
  option: String
}

#
type AlertConfig {
  #
  panicType: Int

  #
  osLimit: Int

  #
  voltage: Float

  #
  areaId: Int

  #
  areaName: String

  #
  tripName: String

  #
  routeName: String

  #
  clientLoginId: Int!

  #
  uniqueDeviceId: String!

  #
  vehicleNumber: String!

  #
  fromTimestamp: String

  #
  toTimestamp: String

  #
  fromTime: Int!

  #
  toTime: Int!

  #
  haltTime: Int!

  #
  idleTime: Int!

  #
  coolantTemp: Int!

  #
  RPM: Int!

  #
  fatigueDuration: Int!

  #
  fatigueStartTime: Int!

  #
  email: String

  #
  sms: String

  #
  isEmailEnable: Boolean!

  #
  isSMSEnable: Boolean!

  #
  isAlertEnable: Boolean!

  #
  loginIds: LoginIds

  #
  minTemp: Int!

  #
  maxTemp: Int!

  #
  value: Int

  #
  userId: String

  #
  recipients: [recipientObj]
}

#
type LoginIds {
  #
  clientLoginId: Int!

  #
  userLogins: [Int]!
}

#
type recipientObj {
  #
  recipientUserId: String

  #
  email: String

  #
  phoneNumber: String
}

#
enum ALERT {
  #
  OVERSPEED

  #
  TOW

  #
  POWER

  #
  HA

  #
  HB

  #
  HC

  #
  EXT_BAT

  #
  INT_BAT

  #
  IDLE

  #
  RPM

  #
  MIL

  #
  FATIGUE

  #
  OBD_COMM_ERROR

  #
  GEOFENCE

  #
  ACCIDENT

  #
  COOLANT
}

#
type ALERTCONFIGS {
  #
  alertType: String!

  #
  alertValue: String

  #
  vehicleNumber: String!

  #
  enabled: Boolean!
}

#
type ALERTCONFIG {
  #
  vehicleNumber: String!

  #
  alertResponse: [ALERTRESPONSE!]!
}

#
type ALERTRESPONSE {
  #
  alertType: String!

  #
  alertValue: String

  #
  enabled: Boolean!
}

#
type DeviceConfigurationData {
  #
  vehicle: vehicleData

  #
  panicType: Int

  #
  osLimit: Int

  #
  voltage: Float

  #
  areaIdList: [Int!]

  #
  routeIdList: [Int!]

  #
  sms: String

  #
  email: String

  #
  isAlertEnable: Boolean!

  #
  haltTime: Int

  #
  idleTime: Int

  #
  duration: Int

  #
  fromTimestamp: String

  #
  toTimestamp: String

  #
  clientLoginId: Int

  #
  fromTime: Int

  #
  toTime: Int

  #
  minTemp: Int

  #
  maxTemp: Int

  # Start reminder FROM timestamp (epoch)
  maintRemindFromTimestamp: Int

  # Remind at distance (in km)
  maintAtDistance: Int

  # Remind at hour
  maintAtHour: Int

  # Remind at timestamp (epoch)
  maintRemindAtTimestamp: Int

  # Current distance the vehicle has run from reminder start timestamp
  maintCurrentDistance: Int

  # Current hour the vehicle has run from reminder start timestamp
  maintCurrentHour: Int

  # Flag for recurring reminders
  recurring: Boolean

  #
  noOfDays: Int

  #
  runningHrs: Float

  #
  alertSent: Int

  # Parameter for contitional based maintenance
  parametersData: [ParamData]

  #
  noResponseParameterData: [noResponseParamData]

  #
  value: Int
}

#
type ParamData {
  #
  parameter: String

  #
  pid: String

  #
  minValue: Int

  #
  maxValue: Int

  #
  isEnable: Boolean!
}

#
type noResponseParamData {
  #
  typeOfAlert: String

  #
  duration: Int

  #
  isEnable: Boolean!
}

#
type DeviceData {
  #
  Configured_Speed_Limit: Int

  #
  email: String

  #
  Phone: String

  #
  Vehicle_Number: String
}

#
type alertParametersResponse {
  #
  status: Int!

  #
  statusMessage: String!

  #
  alertParameters: [alertParameters]
}

#
type alertParameters {
  #
  id: Int

  #
  alert_parameter: String

  #
  payload_alert_parameter: String

  #
  description: String

  #
  model: String

  #
  critical_high_sms_template: String

  #
  critical_high_sms_template_id: String

  #
  critical_low_sms_tempate: String

  #
  critical_low_sms_template_id: String

  #
  low_sms_template: String

  #
  low_sms_template_id: String

  #
  high_sms_template: String

  #
  high_sms_template_id: String

  #
  critical_high_email_template: String

  #
  critical_low_email_template: String

  #
  low_email_template: String

  #
  high_email_template: String

  #
  critical_high_whatsapp_template: String

  #
  critical_low_whatsapp_template: String

  #
  low_whatsapp_template: String

  #
  high_whatsapp_template: String

  #
  critical_high_whatsapp_placeholders: String

  #
  critical_low_whatsapp_placeholders: String

  #
  low_whatsapp_placeholders: String

  #
  high_whatsapp_placeholders: String

  #
  created_at: Int

  #
  updated_at: Int

  #
  status: Boolean
}

#
type getConditionalAlertConfigData {
  #
  status: Int

  #
  statusMessage: String

  #
  alertParameters: [AlertParameters]
}

#
type AlertParameters {
  #
  alert_id: Int

  #
  vin: String

  #
  app_user_id: String

  #
  alert_parameter: String

  #
  description: String

  #
  alert_threshold_critical_high: Float

  #
  alert_threshold_high: Float

  #
  alert_threshold_low: Float

  #
  alert_threshold_critical_low: Float

  #
  created_at: String

  #
  updated_at: String

  #
  is_enabled: Boolean
}

#
type overSpeedRes {
  #
  osLimit: Int

  #
  status: Int!

  #
  statusMessage: String!
}

#
type Roles {
  #
  id: Int!

  #
  client: ClientDetail!

  #
  roleName: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!

  #
  assignedFeatures: [FeatureRoleAssign!]!
}

#
type FeatureRoleAssign {
  #
  id: Int!

  #
  feature: Features!

  #
  permission: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type Groups {
  #
  id: Int!

  #
  client: ClientDetail!

  #
  groupName: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!

  #
  assignedVehicles: [AssignedVehicleToGroup!]!
}

#
type AssignedVehicleToGroup {
  #
  entityId: Int!

  #
  vehicleNumber: String!

  #
  uniqueDeviceId: String!
}

#
type RMSGroupDetails {
  #
  groupName: String!

  #
  districtIds: [Int]

  #
  type: String
}

#
type TalukGroup {
  #
  groupName: String!

  #
  talukIds: [Int]

  #
  type: String
}

#
type VillageGroup {
  #
  groupName: String!

  #
  villageIds: [Int]

  #
  type: String
}

#
type GroupDetail {
  #
  id: Int!

  #
  groupName: String!

  #
  assignedVehicles: [vehicleDatas!]
}

#
type vehicleDatas {
  #
  vehicleNumber: String!
}

#
type UserDetail {
  #
  id: Int!

  #
  userName: String!

  #
  email: String

  #
  contactNumber: String!

  #
  login: Login!

  #
  role: Roles!

  #
  group: Groups!

  #
  client: ClientDetail!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  address: String

  #
  status: Int!
}

#
type UserIdNew {
  #
  app_user_id: String

  #
  username: String

  #
  email: String
}

#
type SubloginData {
  #
  subLoginId: Int!

  #
  subLoginName: String!

  #
  email: String

  #
  contactNumber: String!

  #
  login: Login!

  #
  role: Roles!

  #
  group: Groups!

  #
  client: ClientDetail!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type Driver {
  #
  id: Int!

  #
  driverName: String!

  #
  license: String!

  #
  countryCode: String!

  #
  contactNumber: String!

  #
  userLoginId: Int

  #
  clientLoginId: Int

  #
  vehicleNumber: String

  #
  vehicleId: Int

  #
  uniqueDeviceId: String

  #
  driverImage: String

  #
  otherDocument: String

  #
  score: Float

  #
  vehicleAssignedAt: String

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!

  #
  firstName: String!

  #
  lastName: String!

  #
  email: String

  #
  rfid: String!

  #
  vehicleType: String!

  #
  driverType: String!

  #
  licenseExpiry: String!

  #
  driverImageURL: String
}

#
type DriverDetails {
  #
  id: Int

  #
  driverName: String

  #
  license: String

  #
  contactNumber: String

  #
  vehicleNumber: String

  #
  driverImageURL: String

  #
  driverImage: String

  #
  otherDocument: String

  #
  score: Float

  #
  vehicleAssignedAt: String

  #
  status: Int
}

#
type DriverDetail {
  #
  id: Int

  #
  driverName: String

  #
  license: String

  #
  contactNumber: String

  #
  vehicleNumber: String

  #
  driverImageURL: [String]

  #
  driverImage: String

  #
  otherDocument: String

  #
  score: Float

  #
  vehicleAssignedAt: String

  #
  status: Int

  #
  loginTime: String

  #
  logOutTime: String

  #
  date: String
}

#
type FileDetails {
  #
  url: String
}

#
type OnDutyDriver {
  #
  driverId: Int

  #
  driverName: String

  #
  totalTime: String
}

#
type VehicleGroupAssign {
  #
  id: Int!

  #
  group: Groups!

  #
  vehicle: VehicleDetail!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type ReportField {
  #
  fieldId: String!

  #
  fieldName: String!

  #
  fieldType: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type ReportType {
  #
  reportTypeId: String!

  #
  reportType: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type AvailReportField {
  #
  category: Int!

  #
  availFields: String!

  #
  categorizedAvailFields: String

  #
  reportType: String

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type ReportBuilder {
  #
  fields: [Fields!]

  #
  category: Int

  #
  reportType: String

  #
  reportName: String
}

#
type Fields {
  #
  fieldId: String

  #
  fieldName: String

  #
  fieldType: String
}

# Report automation field definitions
type ReportAutomation {
  # Unique id
  id: Int!

  # Report category
  category: Int

  # Report type
  reportType: String

  # Client/Partner login
  loginId: Int!

  # Type of account
  accountType: String!

  # Report name
  reportName: String!

  # Description of the report
  reportDescription: String!

  # Report frequency. Options are daily or weekly
  frequency: String!

  # Email list to send reports to
  emails: String

  # Created at
  createdAt: String!

  # Updated at
  updatedAt: String!

  # Status
  status: Int!
}

#
type DefaultReportBuilder {
  #
  fields: [Fields!]

  #
  category: Int

  #
  reportType: String

  #
  reportName: String
}

#
type BillingLogic {
  #
  id: Int

  #
  billingLogic: String

  #
  billingModeId: Int

  #
  createdAt: String

  #
  updatedAt: String

  #
  status: Int
}

#
type AccessoryType {
  #
  id: Int!

  #
  accessoryName: String!

  #
  version: Float!

  #
  description: String

  #
  manufacturer: Manufacturer!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type AccessoryTypePartnerAssign {
  #
  id: Int!

  #
  manufacturer: Manufacturer!

  #
  partner: PartnerDetail!

  #
  accessoryType: AccessoryType!

  #
  accessoryTypeId: Int!

  #
  manufacturerId: Int!

  #
  partnerLoginId: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: String!
}

#
type Accessory {
  #
  serialNumber: Int!

  #
  uniqueAccessoryId: String!

  #
  ownerLoginId: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!

  #
  accessoryType: AccessoryType!

  #
  manufacturer: Manufacturer!
}

#
type AccessoryPartnerAssign {
  #
  id: Int!

  #
  accessory: Accessory!

  #
  partner: PartnerDetail!

  #
  accessoryType: AccessoryType!

  #
  partnerLoginId: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type PartnerAccessoryStockDetail {
  #
  accessoryTypeId: Int!

  #
  accessoryTypeName: String!

  #
  totalAssignedAccessory: Int!

  #
  totalAssignedAccessoryToClient: Int!

  #
  totalRegisteredAccessory: Int!

  #
  availableStock: Int!
}

#
input AccessoryListInput {
  #
  serialNumber: Int!

  #
  uniqueAccessoryId: String!
}

#
type AccessoryAvailabilityVerification {
  #
  serialNumber: Int!

  #
  uniqueAccessoryId: String!
}

#
type Subscriptions {
  #
  id: Int!

  #
  client: ClientDetail!

  #
  partner: PartnerDetail!

  #
  billingMode: BillingMode!

  #
  billingFrequency: BillingFrequency!

  #
  billingLogic: BillingLogic

  #
  billingDay: Int!

  #
  gst: Float!

  #
  deviceModel: DeviceModel!

  #
  deviceQuantity: Int!

  #
  unAssignedDeviceQuantity: Int

  #
  accessoryType: AccessoryType

  #
  accessoryQuantity: Int

  #
  plan: String!

  #
  unAssignedAccessoryQuantity: Int

  #
  serviceProvider: ServiceProvider

  #
  simQuantity: Int

  #
  unAssignedSimQuantity: Int

  #
  deviceModelId: Int

  #
  accessoryTypeId: Int

  #
  serviceProviderId: Int

  #
  amount: Int!

  #
  totalAmount: Int!

  #
  billingStartedFrom: String

  #
  billingPayTill: String

  #
  subscriptionInventory: SubscriptionInventoryAssign

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!

  #
  minimumAmountDue: Float!

  #
  nextPaymentDate: String

  #
  unbilledDevices: Int!

  #
  unbilledSims: Int!

  #
  unbilledAccessory: Int!

  #
  salesRemarks: String

  #
  accountsRemarks: String

  #
  invoiceDownloadLink: String

  #
  billingDetails: billingDetails
}

#
type SubscriptionInventoryAssign {
  #
  id: Int!

  #
  subscriptionId: Int!

  #
  assignedDeviceList: String!

  #
  assignedDeviceDetails: [SubDeviceDetail!]!

  #
  assignedAccessoryList: String!

  #
  assignedSimList: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  asignedSimDetails: [SubSimDetail!]!

  #
  status: Int!
}

#
type SubDeviceDetail {
  #
  serial_num: String!

  #
  imei_num: String!

  #
  uniqueDeviceId: String!

  #
  vehicleDetails: SubVehicleDetails

  #
  status: Int!
}

#
type SubVehicleDetails {
  #
  vehiclenumber: String!
}

#
type SubSimDetail {
  #
  id: Int!

  #
  phoneNumber: String!

  #
  simNumber: String!

  #
  vehicleDetails: SubVehicleDetails

  #
  status: Int!
}

#
type billingDetails {
  # paymentId will be null for sales login. And cannot be null for accounts login.
  paymentId: Int

  #
  subscriptionBillId: Int

  #
  totalAmount: Int

  #
  totalAmountWithGST: Int

  #
  totalAmountPaidGST: Int

  #
  simBill: billAmount

  #
  hardwareBill: billAmount

  #
  softwareBill: billAmount

  #
  accessoryBill: billAmount
}

#
type billAmount {
  #
  rate: Int

  #
  quantity: Int

  #
  amount: Int!

  #
  amountWithGST: Int!

  #
  amountToBePaid: Int!

  #
  amountPaidGST: Int!
}

#
type AreaType {
  #
  id: Int!

  #
  areaTypeName: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type Area {
  #
  id: Int!

  #
  areaName: String!

  #
  areaType: AreaType!

  #
  clientLoginId: Int!

  #
  geoJson: String

  #
  geoPosition: String

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!

  #
  pluscode: String
}

#
type AreaResponse {
  #
  areaId: Int!

  #
  areaName: String!

  #
  areaType: String!

  #
  geoJson: String

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type AreaGeoFenceResponse {
  #
  areaId: Int!

  #
  areaName: String!

  #
  areaType: String!

  #
  radius: Int

  #
  coordinates: [res_lat_Long!]!

  #
  geoPosition: res_lat_Long
}

#
type res_lat_Long {
  #
  lat: String!

  #
  long: String!
}

#
type AreaVehicleAssociation {
  #
  uniqueId: String!

  #
  areas: [Area]!
}

#
type getGeofenceListResponseOld {
  #
  geofences: [geofenceList!]

  #
  status: Int!

  #
  statusMessage: String
}

#
type geofenceList {
  #
  location: String!

  #
  geofenceid: Int!

  #
  areaType: String

  #
  polygonGeoJson: [latLong]

  #
  polygonGeoPosition: [centroidLatLong]

  #
  circleGeoJson: [circleGeoJson1]

  #
  assignedVin: [String]
}

#
type latLong {
  #
  lat: Float

  #
  long: Float
}

#
type centroidLatLong {
  #
  centroidLat: Float

  #
  centroidLong: Float
}

#
type circleGeoJson1 {
  #
  radius: Int

  #
  centerLat: Float

  #
  centerLong: Float
}

#
type getGeofenceListResponse {
  #
  geofences: [newGeofenceList]

  #
  status: Int!

  #
  statusMessage: String!
}

#
type newGeofenceList {
  #
  geofenceName: String

  #
  geofenceId: Int

  #
  geofenceType: String

  #
  address: String

  #
  circularGeofence: newCircularGeofence

  #
  polygonGeofence: newPolygonGeofence

  #
  createdUserDetails: createdUserDetailsNew

  #
  lastModifiedDetails: lastModifiedDetailsNew

  #
  recipients: [recepientsNew]

  #
  created_timestamp: String

  #
  alertStatus: String

  #
  is_deleted: Int
}

#
type newCircularGeofence {
  #
  circularPosition: lat_LongCircular

  #
  radius: Int
}

#
type lat_LongCircular {
  #
  lat: String

  #
  long: String
}

#
type newPolygonGeofence {
  #
  coordinates: [lat_LongPolygon]

  #
  polygonPosition: polygon_lat_long_New
}

#
type lat_LongPolygon {
  #
  lat: String

  #
  long: String
}

#
type polygon_lat_long_New {
  #
  lat: String

  #
  long: String
}

#
type createdUserDetailsNew {
  #
  userId: String

  #
  userName: String

  #
  userType: String
}

#
type lastModifiedDetailsNew {
  #
  userId: String

  #
  userName: String

  #
  userType: String

  #
  updated_timestamp: String
}

#
type recepientsNew {
  #
  userId: String

  #
  userName: String

  #
  userType: String
}

#
type vinDetailsResponse {
  #
  details: detailsObj

  #
  status: Int!

  #
  statusMessage: String!
}

#
type detailsObj {
  #
  vin_details: vinDetails

  #
  users: [vinUsersResponse]

  #
  homechargerData_details: homechargerData
}

#
type vinDetails {
  #
  vin: String!

  #
  initial_imei: String

  #
  serial_number: String

  #
  sale_date_timestamp: String

  #
  description: String

  #
  vehicle_colour: String

  #
  vehicle_type_id: Int

  #
  theme: Int

  #
  vehicle_registration_number: String

  #
  vehicle_nick_name: String

  #
  codp_model: String

  #
  variant_id: String

  #
  sim_provider: String

  #
  phone_number: String

  #
  sim_number: String

  #
  model_name: String
}

#
type vinUsersResponse {
  #
  app_user_id: String!

  #
  user_name: String!

  #
  email: String!

  #
  iso_code: String

  #
  mobile_number: String!

  #
  country_code: Int

  #
  user_type: String!

  #
  isFCM: Boolean!
}

#
type homechargerData {
  #
  hc_imei: String!

  #
  primary_bat_a_uid: String

  #
  primary_bat_b_uid: String

  #
  secondary_batteries_uid: [BatteryDetails]
}

#
type BatteryDetails {
  #
  bat_uids: String
}

#
type getUserDetailsResponse {
  #
  details: userDetailsObj

  #
  status: Int!

  #
  statusMessage: String!
}

#
type userDetailsObj {
  #
  user_details: detailsOfUser

  #
  associated_vins: [associatedVinsArray]
}

#
type detailsOfUser {
  #
  app_user_id: String

  #
  user_name: String

  #
  email: String

  #
  iso_code: String

  #
  country_code: Int

  #
  mobile_number: String!

  #
  associated_vins: [associatedVinsArray]

  #
  isFCM: Boolean
}

#
type associatedVinsArray {
  #
  vin: String

  #
  type: String
}

#
enum ISO_CODES {
  #
  AFG

  #
  ALB

  #
  DZA

  #
  ASM

  #
  AND

  #
  AGO

  #
  AIA

  #
  ATA

  #
  ATG

  #
  ARG

  #
  ARM

  #
  ABW

  #
  AUS

  #
  AUT

  #
  AZE

  #
  BHS

  #
  BHR

  #
  BGD

  #
  BRB

  #
  BLR

  #
  BEL

  #
  BLZ

  #
  BEN

  #
  BMU

  #
  BTN

  #
  BOL

  #
  BIH

  #
  BWA

  #
  BVT

  #
  BRA

  #
  IOT

  #
  BRN

  #
  BGR

  #
  BFA

  #
  BDI

  #
  KHM

  #
  CMR

  #
  CAN

  #
  CPV

  #
  CYM

  #
  CAF

  #
  TCD

  #
  CHL

  #
  CHN

  #
  CXR

  #
  CCK

  #
  COL

  #
  COM

  #
  COG

  #
  COK

  #
  CRI

  #
  CIV

  #
  HRV

  #
  CUB

  #
  CYP

  #
  CZE

  #
  DNK

  #
  DJI

  #
  DMA

  #
  DOM

  #
  TMP

  #
  ECU

  #
  EGY

  #
  SLV

  #
  GNQ

  #
  ERI

  #
  EST

  #
  ETH

  #
  FLK

  #
  FRO

  #
  FJI

  #
  FIN

  #
  FRA

  #
  FXX

  #
  GUF

  #
  PYF

  #
  ATF

  #
  GAB

  #
  GMB

  #
  GEO

  #
  DEU

  #
  GHA

  #
  GIB

  #
  GRC

  #
  GRL

  #
  GRD

  #
  GLP

  #
  GUM

  #
  GTM

  #
  GIN

  #
  GNB

  #
  GUY

  #
  HTI

  #
  HMD

  #
  HND

  #
  HKG

  #
  HUN

  #
  ISL

  #
  IND

  #
  IDN

  #
  IRN

  #
  IRQ

  #
  IRL

  #
  ISR

  #
  ITA

  #
  JAM

  #
  JPN

  #
  JOR

  #
  KAZ

  #
  KEN

  #
  KIR

  #
  PRK

  #
  KOR

  #
  KWT

  #
  KGZ

  #
  LAO

  #
  LVA

  #
  LBN

  #
  LSO

  #
  LBR

  #
  LBY

  #
  LIE

  #
  LTU

  #
  LUX

  #
  MAC

  #
  MKD

  #
  MDG

  #
  MWI

  #
  MYS

  #
  MDV

  #
  MLI

  #
  MLT

  #
  MHL

  #
  MTQ

  #
  MRT

  #
  MUS

  #
  MYT

  #
  MEX

  #
  FSM

  #
  MDA

  #
  MCO

  #
  MNG

  #
  MSR

  #
  MAR

  #
  MOZ

  #
  MMR

  #
  NAM

  #
  NRU

  #
  NPL

  #
  NLD

  #
  ANT

  #
  NCL

  #
  NZL

  #
  NIC

  #
  NER

  #
  NGA

  #
  NIU

  #
  NFK

  #
  MNP

  #
  NOR

  #
  OMN

  #
  PAK

  #
  PLW

  #
  PAN

  #
  PNG

  #
  PRY

  #
  PER

  #
  PHL

  #
  PCN

  #
  POL

  #
  PRT

  #
  PRI

  #
  QAT

  #
  REU

  #
  ROM

  #
  RUS

  #
  RWA

  #
  KNA

  #
  LCA

  #
  VCT

  #
  WSM

  #
  SMR

  #
  STP

  #
  SAU

  #
  SEN

  #
  SYC

  #
  SLE

  #
  SGP

  #
  SVK

  #
  SVN

  #
  SLB

  #
  SOM

  #
  ZAF

  #
  SGS

  #
  ESP

  #
  LKA

  #
  SHN

  #
  SPM

  #
  SDN

  #
  SUR

  #
  SJM

  #
  SWZ

  #
  SWE

  #
  CHE

  #
  SYR

  #
  TWN

  #
  TJK

  #
  TZA

  #
  THA

  #
  TGO

  #
  TKL

  #
  TON

  #
  TTO

  #
  TUN

  #
  TUR

  #
  TKM

  #
  TCA

  #
  TUV

  #
  UGA

  #
  UKR

  #
  ARE

  #
  GBR

  #
  USA

  #
  UMI

  #
  URY

  #
  UZB

  #
  VUT

  #
  VAT

  #
  VEN

  #
  VNM

  #
  VGB

  #
  VIR

  #
  WLF

  #
  ESH

  #
  YEM

  #
  YUG

  #
  COD

  #
  ZMB

  #
  ZWE
}

#
type getUserDetailsByMobileNumberResponse {
  #
  details: userDetailsObject

  #
  status: Int!

  #
  statusMessage: String!
}

#
type userDetailsObject {
  #
  user_details: [detailsOfUser]
}

#
type redisResponse {
  #
  status: Int

  #
  statusMessage: String
}

#
type Route {
  #
  id: Int!

  #
  areaId: Int!

  #
  areaName: String!

  #
  clientLoginId: Int!

  #
  routeDetail: String!

  #
  places: String!

  #
  placeCoordinates: String!

  #
  areaTypeBuffer: String!

  #
  aoiFenceBuffer: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type RouteVehicleAssociation {
  #
  uniqueId: String!

  #
  routes: [Route]!
}

#
type DeviceService {
  #
  id: Int!

  #
  uniqueDeviceId: String!

  #
  deactivatedAt: String!

  #
  activatedAt: String

  #
  status: Int!
}

# Trip type details
type Trip {
  # Trip unique id
  tripId: Int!

  # Trip's name
  tripName: String!

  # Logged in client's id
  clientLoginId: Int!

  # Details of sub trips
  scheduledSubTrip: ScheduledSubTrip

  # Trip notification details
  tripNotifications: TripNotifications

  # Trip's route details
  route: Route!

  # Trip's geo json
  geoJson: String!

  # Trip's from timestamp
  fromTimestamp: String!

  # Trip's scheduled from timestamp
  scheduleFromTimestamp: String

  # Trip's To timestamp
  toTimestamp: String!

  # Trip's scheduled To timestamp
  scheduleToTimestamp: String

  # Trip's tolerance in seconds
  tolerance: Int!

  # Trip's schedule value
  schedule: Int

  # Trip's vehicle details
  vehicle: vehicleData!

  # Created at time
  createdAt: String!

  # Updated at time
  updatedAt: String!

  # Trip's status
  status: Int

  # Check if trip is pickup
  isPickup: Boolean

  # Should alert flag to indicate wether first and last AOI are same or not
  shouldAlert: Int
}

# Scheduled sub trip's details
type ScheduledSubTrip {
  # Sub trip's From timestamp
  fromTimestamp: String

  # Sub trip's To timestamp
  toTimestamp: String
}

# Trip notification details
type TripNotifications {
  # List of emails to send notifications to
  email: [String]

  # List of phone numbers to send notifications to
  sms: [String]
}

# Paginated trip info
type TripConnection {
  # Total result count
  totalCount: Int!

  # Trip information
  edges: [TripEdge]

  # Page information
  pageInfo: PageInfo!
}

# Trip detail edge
type TripEdge {
  # Single trip cursor
  cursor: String!

  # Single trip details
  node: Trip!
}

# Pagination page information
type PageInfo {
  # Start cursor value
  startCursor: String!

  # End cursor value
  endCursor: String!

  # Check for next page in pagination
  hasNextPage: Boolean!
}

#
type TripStudentsDetail {
  #
  tripId: Int!

  #
  tripStartTime: String!

  #
  tripEndtime: String!

  #
  tripName: String!

  #
  VehicleNumber: String!

  #
  tripType: String

  #
  uniqueDeviceId: String!

  #
  students: [students]!
}

#
type students {
  #
  studentId: Int!

  #
  studentName: String!

  #
  primaryNumber: String

  #
  secondaryContactNumber: String

  #
  RFID: String
}

#
type SubTrip {
  #
  subTripId: Int!

  #
  tripId: Int!

  #
  tripName: String!

  #
  events: [TripAlert]!

  #
  aggregations: [TripAggregations]!

  #
  clientLoginId: Int!

  #
  route: Route!

  #
  geoJson: String!

  #
  fromTimestamp: String!

  #
  toTimestamp: String!

  #
  tolerance: Int!

  #
  schedule: Int

  #
  vehicle: vehicleData!

  #
  status: Int!
}

#
type TripAlert {
  #
  type: String

  #
  details: [BreachDetails]
}

#
type BreachDetails {
  #
  areaName: String

  #
  index: Int

  #
  startLocation: TripAlertLocation

  #
  startTimestamp: String

  #
  endLocation: TripAlertLocation

  #
  endTimestamp: String
}

#
type TripAlertLocation {
  #
  lat: Float

  #
  lng: Float

  #
  address: String
}

#
type TripAggregations {
  #
  totalDist: Float

  #
  totalRunningTime: Float

  #
  totalHaltTime: Float

  #
  totalHaCount: Int

  #
  totalHbCount: Int

  #
  avgSpeed: Float

  #
  totalIdlingTime: Float

  #
  totalOsDist: Float

  #
  maxSpeed: Float
}

# WSO Trip details
type WSOTrip {
  # WSO trip id
  id: Int

  # Trip id
  tripId: Int

  # Area id
  areaId: Int

  # Longitude
  longitude: Float

  # Latitude
  latitude: Float

  # Unique device id
  uniqueId: String

  # Trip's area type
  areaType: String

  # Trip's area name
  areaName: String

  # Trip's way point
  wayPoint: Int

  # Trip alert flag
  alertFlag: Int
}

# Trip's filters
input TripFilters {
  # Trip id array
  tripId: [Int]

  # Trip's status
  status: TripStatusType

  # Unique device id
  uniqueDeviceId: String

  # Name of the trip
  tripName: String

  # Type of trip
  tripType: TripType

  # Trips between two times
  timeRange: TripTimeRange

  # Id of the AOI
  AoiId: Int
}

# Trip's status type
enum TripStatusType {
  # Active trip
  ACTIVE

  # Completed trips
  COMPLETED

  # Trips which are in progress at current time
  PAUSED

  # Trips which are paused
  DELETED

  # Deleted trips
  IN_PROGRESS
}

#
enum TripType {
  #
  PICKUP

  #
  DROP
}

# Trip's time range
input TripTimeRange {
  # Trip's start time
  startTime: String

  # Trip's end time
  endTime: String
}

#
type wayPointTrips {
  #
  tripId: Int!

  #
  WayPoints: [WayPoints!]!

  #
  routeId: Int!

  #
  fromTimestamp: String!

  #
  toTimestamp: String!

  #
  tolerance: Int!

  #
  clientLoginId: Int!

  #
  status: Int!
}

#
type WayPoints {
  #
  tripId: Int!

  #
  uniqueDeviceId: String!

  #
  haltTime: Int!

  #
  areaId: Int!

  #
  areaName: String!
}

#
type TripDetails {
  # Trip unique id
  tripId: Int!

  # Trip's name
  tripName: String!

  # Logged in client's id
  clientLoginId: Int!

  # Trip's geo json
  geoJson: String!

  # Trip's from timestamp
  fromTimestamp: String!

  # Trip's scheduled from timestamp
  scheduleFromTimestamp: String

  # Trip's To timestamp
  toTimestamp: String!

  # Trip's scheduled To timestamp
  scheduleToTimestamp: String

  # Trip's tolerance in seconds
  tolerance: Int!

  # Trip's schedule value
  schedule: Int

  # Created at time
  createdAt: String!

  # Updated at time
  updatedAt: String!

  # Trip's status
  status: Int!

  # Check if trip is pickup
  isPickup: Boolean

  # Should alert flag to indicate wether first and last AOI are same or not
  shouldAlert: Int

  #
  startLocation: String

  #
  endLocation: String

  #
  vehicleNumber: String
}

#
type TripScheduleStatus {
  #
  pauseScheduled: Boolean!

  #
  editScheduled: Boolean!

  #
  deleteScheduled: Boolean!
}

#
type Edits {
  #
  fromTimestamp: String!

  #
  toTimestamp: String!

  #
  scheduleFromTimestamp: String!

  #
  scheduleToTimestamp: String!

  #
  schedule: Int!

  #
  email: [String]

  #
  sms: [String]

  #
  tolerance: Int!

  #
  tripName: String!
}

# Student details
type Student {
  # Unique student id
  studentId: Int!

  # Student's name
  studentName: String!

  # Student's gender
  gender: String!

  # Student's email
  email: String

  # Student's contact number
  contactNumber: String!

  # Student's secondary contact number
  secondaryContactNumber: String

  # Student's parent login id
  parentLoginId: Int!

  # Client's login id
  clientLoginId: Int!

  # Secondary login id
  secondaryLoginId: Int

  # Student's RFID
  rfid: String

  # Student's pickup location
  pickupLocation: PickupDropLocation

  # Student's pickup AOI
  aoiPickup: Int

  # Student's pickup vehicle id
  pickupVehicleId: String

  # Student's drop location
  dropLocation: PickupDropLocation

  # Student's drop AOI
  aoiDrop: Int

  # Student's drop vehicle id
  dropVehicleId: String

  # Student's address
  address: String

  # Created at
  createdAt: String!

  # Updated at
  updatedAt: String!

  # Student's status code
  status: Int!

  # Student's pickup trips information
  pickupTrips: [TripInformation]

  # Student's drop trips information
  dropTrips: [TripInformation]

  # Student's school id
  schoolId: Int

  # Student's school name
  schoolName: String

  # Boolean to check if pickup trip
  pickUpTrip: Boolean

  # Boolean to check if drop trip
  dropTrip: Boolean

  # Boolean to check if SMS enabled or not
  smsEnabled: Boolean

  # Student's drop vehicle
  dropVehicle: String

  # Student's pickup vehicle
  pickUpVehicle: String

  # Student's unique id from school
  schoolStudentId: String

  # Student's course name
  courseName: String

  # Student's pickup route information
  pickupRoute: RouteInformation

  # Student's drop route information
  dropRoute: RouteInformation

  # Student's active pickup trip information
  inProgressPickupTrip: TripInformation

  # Student's active pickup trip information
  inProgressDropTrip: TripInformation
}

# Pickup and rop location information
type PickupDropLocation {
  # Latitude
  lat: Float

  # Longitude
  lng: Float

  # Address of pickup or drop location
  address: String

  # Area id of pickup or drop location
  areaId: Int

  # Area name of pickup or drop location
  areaName: String
}

# Trip's information
type TripInformation {
  # Trip unique id
  tripId: Int

  # Trip name
  tripName: String

  # Trip's route information
  route: RouteInformation
}

# Route's details
type RouteInformation {
  # Route unique id
  routeId: Int

  # Route's area name
  areaName: String
}

#
type parentLoginDetails {
  #
  username: String!

  #
  lastLoginTime: String

  #
  student: Student
}

#
type SchoolRoute {
  #
  id: Int!

  #
  routeName: String!

  #
  clientLoginId: Int!

  #
  routeDetails: String!

  #
  routeType: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type SchoolArea {
  #
  id: Int!

  #
  areaName: String!

  #
  clientLoginId: Int!

  #
  areaShape: String!

  #
  areaDetails: String!

  #
  geoJson: String!

  #
  areaType: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type SchoolTrip {
  #
  id: Int!

  #
  tripName: String!

  #
  clientLoginId: Int!

  #
  tripType: String!

  #
  route: SchoolRoute!

  #
  schedulingFrequency: String!

  #
  scheduledDays: String!

  #
  tolerance: Int!

  #
  stoppageTime: Int!

  #
  schoolTime: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type LicenseTypeResellerAssign {
  #
  id: Int!

  #
  reseller: ResellerDetails!

  #
  licenseType: LicenseType!

  #
  licenseTypeId: Int!

  #
  resellerLoginId: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type DeviceModelResellerAssign {
  #
  id: Int!

  #
  reseller: ResellerDetails!

  #
  deviceModel: DeviceModel!

  #
  deviceModelId: Int!

  #
  resellerLoginId: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: String!
}

#
type PurchaseRequest {
  #
  id: Int!

  #
  reseller: ResellerDetails!

  #
  licenseTypeList: [LicenseTypeWithQuantity!]!

  #
  deviceModelList: [DeviceModelWithQuantity!]!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type LicenseTypeWithQuantity {
  #
  id: Int!

  #
  licenseType: String!

  #
  description: String!

  #
  maxPrice: Int!

  #
  requestedQuantity: Int!

  #
  assignedQuantity: Int!

  #
  finalPrice: Int

  #
  gst: Float

  #
  totalPrice: Int
}

#
type DeviceModelWithQuantity {
  #
  id: Int!

  #
  model_name: String!

  #
  version: Float!

  #
  devicetype: String!

  #
  description: String

  #
  maxPrice: Int

  #
  manufacturerId: Int!

  #
  manufacturerCode: String!

  #
  requestedQuantity: Int!

  #
  assignedQuantity: Int!

  #
  finalPrice: Int

  #
  gst: Float

  #
  totalPrice: Int
}

#
type DeviceResellerAssign {
  #
  id: Int!

  #
  purchaseRequestId: Int!

  #
  device: DeviceDetail!

  #
  reseller: ResellerDetails!

  #
  deviceModel: DeviceModel!

  #
  uniqueDeviceId: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type ResellerDeviceStockDetail {
  #
  deviceModelId: Int!

  #
  modelName: String!

  #
  totalAssignedDevice: Int!

  #
  totalAssignedDeviceToClient: Int!

  #
  totalRegisteredDevice: Int!

  #
  availableStock: Int!
}

#
type SimResellerAssign {
  #
  id: Int!

  #
  sim: SimDetail!

  #
  reseller: ResellerDetails!

  #
  serviceProvider: ServiceProvider!

  #
  simId: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type ResellerSimStockDetail {
  #
  serviceProviderId: Int!

  #
  serviceProviderName: String!

  #
  totalAssignedSim: Int!

  #
  totalAssignedSimToClient: Int!

  #
  totalRegisteredSim: Int!

  #
  availableStock: Int!
}

#
type ResellerSubscriptions {
  #
  id: Int!

  #
  client: ClientDetail!

  #
  reseller: ResellerDetails!

  #
  billingMode: BillingMode!

  #
  billingFrequency: BillingFrequency!

  #
  billingLogic: BillingLogic!

  #
  billingDay: Int!

  #
  gst: Float!

  #
  deviceModel: DeviceModel!

  #
  deviceQuantity: Int!

  #
  unAssignedDeviceQuantity: Int

  #
  licenseType: LicenseType

  #
  licenseQuantity: Int

  #
  unAssignedLicenseQuantity: Int

  #
  serviceProvider: ServiceProvider

  #
  simQuantity: Int

  #
  unAssignedSimQuantity: Int

  #
  licenseTypeId: Int

  #
  deviceModelId: Int

  #
  serviceProviderId: Int

  #
  amount: Int!

  #
  totalAmount: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!

  #
  resellerLicenseInventory: [ResellerLicenseInventory!]!
}

#
type ResellerLicenseInventory {
  #
  id: Int!

  #
  reseller: ResellerDetails!

  #
  licenseType: LicenseType!

  #
  purchaseRequestId: Int!

  #
  licenseTypeId: Int!

  #
  resellerLoginId: Int!

  #
  licenseExpiryTime: String!

  #
  approvedQuantity: Int!

  #
  assignedQuantityToClient: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: String!
}

#
type LicenseResellerAssign {
  #
  id: Int

  #
  resellerLoginId: Int

  #
  clientLoginId: Int

  #
  resellerLicenseInventoryId: Int

  #
  vehicleId: Int

  #
  actualExpiryTime: String

  #
  createdAt: String

  #
  updatedAt: String

  #
  status: Int
}

#
type ResellerSubscriptionInventoryAssign {
  #
  id: Int!

  #
  subscriptionId: Int!

  #
  assignedDeviceList: String!

  #
  assignedSimList: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type SMSPurchaseHistory {
  #
  id: Int!

  #
  fromLoginId: Int!

  #
  fromAccountType: String!

  #
  toLoginId: Int!

  #
  toAccountType: String!

  #
  transactionType: String!

  #
  smsCount: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type data {
  #
  id: Int
}

#
type smsBalance {
  #
  id: Int!

  #
  fromLoginId: Int!

  #
  fromAccountType: String!

  #
  toLoginId: Int!

  #
  resellerName: String

  #
  businessName: String

  #
  clientName: String

  #
  toAccountType: String!

  #
  smsBalance: Int!

  #
  totalSMS: Int!

  #
  key: String

  #
  clientId: String

  #
  sms_gateway: String!

  #
  username: String

  #
  password: String

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type obdDescription {
  #
  name: String

  #
  mode: String

  #
  pid: String

  #
  bytesReturned: Int

  #
  description: String

  #
  minValue: String

  #
  maxValue: String

  #
  unit: String

  #
  formula: String
}

#
type SMS111PurchaseHistory {
  #
  id: Int

  #
  fromLoginId: Int

  #
  fromAccountType: String

  #
  toLoginId: Int

  #
  toAccountType: String

  #
  transactionType: String

  #
  smsCount: Int

  #
  createdAt: String

  #
  updatedAt: String

  #
  status: Int
}

#
type deviceCount {
  #
  id: Int!

  #
  deviceUniqueId: String!

  #
  clientLoginId: Int!

  #
  noOfPackets: Int!

  #
  dateOfPackets: Int!

  #
  vehicleNumber: String!
}

#
type tableData {
  #
  deviceUniqueId: String!

  #
  clientLoginId: Int!

  #
  noOfDays: Int!

  #
  vehicleNumber: String!
}

#
type invoiceDetail {
  #
  paymentMasterDetails: paymentMasterDetails

  #
  clientDetails: ClientDetail

  #
  partnerDetails: PartnerDetail

  #
  paymentHitoryDetails: [paymentHitoryDetails]

  #
  billingDetails: paymentBillDetails!

  #
  subscriptionBillDetails: [subscriptionBillDetails]

  #
  noOfSubscriptions: Int
}

#
type paymentMasterDetails {
  #
  id: Int!

  #
  proFormaInvoiceId: String!

  #
  invoiceId: String!

  #
  clientLoginId: Int

  #
  partnerLoginId: Int

  #
  PIAmount: Int!

  #
  invoiceAmount: Int!

  #
  invoiceAmountWithGST: Int!

  #
  GST: Float!

  #
  accountRemarks: String

  #
  serviceRemarks: String

  #
  invoiceRaisedDate: String

  #
  billedDate: String

  #
  paidMoney: Int!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  bucketName: String

  #
  piFileName: String

  #
  invoiceFileName: String

  #
  paymentStatus: Int!
}

#
type paymentHitoryDetails {
  #
  id: Int!

  #
  paidMoney: Int

  #
  paymentMode: String!

  #
  softwareGSTAmountPaid: Int!

  #
  hardwareGSTAmountPaid: Int!

  #
  simGSTAmountPaid: Int!

  #
  accessoryGSTAmountPaid: Int!

  #
  bank: String

  #
  chequeNumber: String

  #
  chequeDate: String

  #
  referenceNumber: String

  #
  invoiceRaisedDate: String

  #
  accountRemarks: String

  #
  noOfSubscription: Int!

  #
  noOfDevices: Int!

  #
  billPaidDate: String

  #
  billGeneratedDate: String

  #
  invoiceAmount: Int

  #
  piAmount: Int

  #
  GST: Float!

  #
  createdAt: String

  #
  updatedAt: String
}

#
type paymentBillDetails {
  #
  totalAmount: Int!

  #
  totalAmountGST: Int!

  #
  totalAmountPaidGST: Int!

  #
  totalAmountToBePaidGST: Int!

  #
  simBillDetails: billData

  #
  softwareBillDetails: billData

  #
  accessoryBillDetails: billData

  #
  hardwareBillDetails: billData
}

#
type billData {
  #
  quantity: Int!

  #
  amount: Int!

  #
  amountGST: Int!

  #
  amountPaidGST: Int!

  #
  amountToBePaidGST: Int!

  #
  creditDate: String
}

#
type subscriptionBillDetails {
  #
  subscriptionId: Int

  #
  partnerSubscriptionId: Int

  #
  gst: Float!

  #
  PIAmount: Int!

  #
  invoiceAmount: Int!

  #
  simBill: billAmount

  #
  simPaidMoney: Int!

  #
  hardwareBill: billAmount

  #
  hardwarePaidMoney: Int!

  #
  softwareBill: billAmount

  #
  softwarePaidMoney: Int!

  #
  accessoryBill: billAmount

  #
  accessoryPaidMoney: Int!
}

#
type InvoiceDetails {
  #
  type: String!

  #
  invoiceId: String!

  #
  date: String!

  #
  customer: CustomerDetails

  #
  partnerDetails: PartnerDetail

  #
  subscriptions: [SubscriptionDetails]

  #
  totalBill: BillDetails

  #
  noOfSubscriptions: Int
}

#
type CustomerDetails {
  #
  id: Int!

  #
  name: String

  #
  address: String

  #
  gstNumber: String

  #
  email: String
}

#
type SubscriptionDetails {
  #
  id: Int

  #
  type: String

  #
  frequency: String

  #
  noOfDevices: Int

  #
  mmtc: Int

  #
  billingFrom: Int

  #
  billingTo: Int

  #
  piAmount: Float

  #
  invoiceAmount: Float
}

#
type BillDetails {
  #
  subTotal: Float

  #
  cgst: Float

  #
  sgst: Float

  #
  totalBill: Float

  #
  discount: Float

  #
  credits: Float

  #
  netPayable: Float
}

#
type InvoiceIds {
  #
  id: Int!

  #
  updatedAt: String!
}

#
type clientCredits {
  #
  client: ClientDetail!

  #
  credit: Float!

  #
  createdAt: String!

  #
  updatedAt: String!
}

#
type billingHistory {
  #
  id: Int!

  #
  invoiceId: String!

  #
  paymentId: String!

  #
  clientLoginId: Int!

  #
  clientName: String!

  #
  paymentMode: String!

  #
  referenceNumber: Int

  #
  chequeDate: String

  #
  remarks: String

  #
  bankName: String

  #
  discount: Int!

  #
  GST: Float!

  #
  creditAmount: Int!

  #
  invoiceAmount: Int!

  #
  piAmount: Int!

  #
  paidAmount: Int!

  #
  billGenerated: String!

  #
  billpaidDate: String!

  #
  paidDate: String!

  #
  noOfDevices: Int!

  #
  noOfsubscrription: Int!
}

#
type School {
  #
  address: String

  #
  schoolId: Int!

  #
  schoolName: String!

  #
  schoolArea: Area

  #
  createdAt: String

  #
  updatedAt: String

  #
  status: Int

  #
  userDetails: UserDetail
}

#
type PartnerSubscription {
  #
  id: Int!

  #
  partnerLoginId: Int!

  #
  partnerDetail: PartnerDetail

  #
  gst: Float

  #
  amount: Int

  #
  deviceModelId: Int

  #
  accessoryTypeId: Int

  #
  serviceProviderId: Int

  #
  deviceModel: DeviceModel

  #
  totalDeviceQty: Int

  #
  unbilledDeviceQty: Int

  #
  unassignedDeviceQuantity: Int

  #
  hardwareCharges: Int

  #
  totalSoftwareQty: Int

  #
  unbilledSoftware: Int

  #
  noOfDevices: Int

  #
  deviceTrackingCharges: Int

  #
  serviceProvider: ServiceProvider

  #
  simQty: Int

  #
  unbilledSims: Int

  #
  unassignedSimQty: Int

  #
  simCharges: Int

  #
  accessoryType: AccessoryType

  #
  accessoryQty: Int

  #
  unbilledAccessory: Int

  #
  unassignedAccessoryQty: Int

  #
  accessoryCharges: Int

  #
  nextPaymentDate: Int

  #
  billingFrequencyId: Int

  #
  billingFrequency: BillingFrequency

  #
  billingMode: BillingMode

  #
  createdAt: Int

  #
  updatedAt: Int

  #
  status: Int

  #
  billingDetails: billingDetails

  #
  salesRemarks: String

  #
  accountsRemarks: String
}

#
type schoolAlerts {
  #
  alertId: Int!

  #
  alertType: String!

  #
  status: Int!
}

#
type assignedSchoolAlerts {
  #
  alerts: schoolAlerts!

  #
  clientLoginId: Int!

  #
  sms_status: Boolean!

  #
  email_status: Boolean!

  #
  status: Boolean!
}

# Device tracking details
type DeviceTrackingDataNew {
  # Vehicle's number
  vehicleNumber: String!

  # Vehicle's type
  vehicleType: String!

  # Vehicle's model
  vehicleModel: String!

  # Vehicle's unique identifier
  uniqueId: String!

  # Vehicle's groups
  vehicleGroups: [String!]

  #
  timestamp: String

  #
  latitude: Float

  #
  longitude: Float

  # Vehicle's GPS status
  gpsStatus: String

  #
  satellites: Int

  # Vehicle's idling status
  idlingStatus: Boolean

  # Vehicle's halt status
  haltStatus: Boolean

  # Is vehicle in overspeed status
  isOverspeed: Boolean

  #
  isHA: Boolean

  #
  isHB: Boolean

  #
  isPrimaryBattery: Boolean

  #
  isNoGps: Boolean

  # Is vehicle offline
  isOffline: Boolean

  #
  isNoData: Boolean

  # Vehicle's speed
  speed: Float

  #
  extBatVol: Float

  #
  plusCode: String

  # Vehicle's address
  address: String
}

#
type ClientEmailDetail {
  #
  limit: Int!

  #
  count: Int!

  #
  login: Login!

  #
  date: String!

  #
  createdAt: String

  #
  updatedAt: String

  #
  status: Int
}

# Trip search field enums
enum TripSearchFields {
  # Trip's name
  TRIP_NAME

  # Vehicle number
  VEHICLE_NUMBER

  # Trip type
  TRIP_TYPE
}

#
type SearchTripsConnection {
  # Total result count
  totalCount: Int!

  # Trip information
  edges: [SearchTripsEdge]

  # Page information
  pageInfo: PageInfo!
}

#
type SearchTripsEdge {
  # Single trip cursor
  cursor: String!

  # Single trip details
  node: TripSearchResult!
}

# Trip search result
type TripSearchResult {
  # Trip id
  tripId: Int!

  # Trip name
  tripName: String!

  #
  uniqueDeviceId: String

  #
  schedule: Int

  #
  tolerance: Int

  #
  clientLoginId: Int

  #
  createdAt: String

  #
  updatedAt: String

  #
  status: Int

  #
  tripType: String
}

#
type deviceSimMapped {
  #
  id: Int!

  #
  deviceId: String

  #
  deviceSerialNo: String!

  #
  deviceImeiNo: String!

  #
  deviceModel: DeviceModel

  #
  phoneNumber: String

  #
  simNumber: String

  #
  serviceProvider: ServiceProvider

  #
  vehicleIdentificationNumber: String

  #
  clientLoginId: Int

  #
  createdAt: String

  #
  updatedAt: String

  #
  status: Int
}

# Vehicle maintenance details
type VehicleMaintDetail {
  # Unique vehicle maintenance id
  id: Int!

  # Unique vehicle ID
  vehicleId: Int!

  # Vehicle Number
  vehicleNumber: String!

  # Client's unique login ID
  clientLoginId: Int!

  # Unique device ID
  uniqueDeviceId: String!

  # Start reminder FROM timestamp (epoch)
  maintRemindFromTimestamp: Int!

  # Remind at distance (in km)
  maintAtDistance: Int

  # Remind at hour
  maintAtHour: Int

  # Remind at timestamp (epoch)
  maintRemindAtTimestamp: Int

  # Current distance the vehicle has run from reminder start timestamp
  maintCurrentDistance: Int

  # Current hour the vehicle has run from reminder start timestamp
  maintCurrentHour: Int

  # List of emails to send maintenance reminder
  emails: [String]

  # List of phone numbers to send maintenance remider
  sms: [String]

  # Flag for recurring reminders
  recurring: Boolean!
}

#
type Icon {
  # Unique identifier
  id: Int

  # Login Id
  loginId: Int

  # Icon category. Ex. Report or Analytics
  iconCategory: String!

  # Icon sub-category. Ex. idle-run-ratio or consolidated
  iconSubCategory: String!

  # Icon name, like cosolidated, idle-run-ratio
  iconName: String!

  # Icon URL
  url: String!

  # Icon svg content
  content: String!
}

#
type Pid {
  #
  id: Int!

  #
  clientLoginId: Int!

  #
  pid: String!

  #
  parameter: String!
}

#
type SparePartReplacements {
  #
  uniqueDeviceId: String!

  #
  sparePartNumber: String!

  #
  sparePartName: String!

  #
  description: String

  #
  replacedPartNumber: String!

  #
  replacedBy: String!

  #
  replacedDate: Int!

  #
  clientLoginId: Int!
}

#
type vehicleInfo {
  #
  vtsNo: String

  #
  clientLoginId: Int
}

#
type VehicleSpareParts {
  #
  invoice_number: String

  #
  equipmentName: String

  #
  equipment_serial_number: String

  #
  commissioning_date: String

  #
  deviceUniqueId_fk: String

  #
  department: String

  #
  idlingSpeed: Int

  #
  sparePartDetails: [SparePartReplacements]
}

#
type EmailTemplate {
  #
  clientLoginId: Int

  #
  template: String

  #
  emailSub: String

  #
  sms: String

  #
  alertName: String
}

#
type EmailConfigs {
  #
  user: String!

  #
  pass: String!

  #
  host: String!

  #
  clientLoginId: Int
}

#
type EmailidsForAlerts {
  #
  id: Int!

  #
  emailId: String!

  #
  type: String!

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int
}

#
type File {
  #
  filename: String!

  #
  mimetype: String!

  #
  encoding: String!
}

#
type SensorsConfig {
  #
  id: Int

  #
  clientLoginId: Int

  #
  pinId: String

  #
  sensorType: String
}

#
type CommonFields {
  #
  commonFieldId: String!

  #
  commonFieldDescription: String!

  #
  fieldName: String!

  #
  unit: String

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type GraphData {
  #
  id: Int!

  #
  graphName: String!

  #
  graphMinThreshold: Int

  #
  graphMaxThreshold: Int

  #
  graphAxisData: JSON

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!
}

#
type DistrictModel {
  #
  district_id: Int!

  #
  name: String!

  #
  status: Int!

  #
  type: String
}

#
type ClientVehicleData {
  #
  district_id: Int!

  #
  taluk_id: Int

  #
  panchayat_id: Int

  #
  village_id: Int

  #
  type: String

  #
  wppId: String

  #
  uniqueId: String
}

#
type DistrictDetails {
  #
  district_id: Int!

  #
  name: String

  #
  status: Int

  #
  taluk: [talukDetails]
}

#
type talukDetails {
  #
  taluk_id: Int

  #
  name: String
}

#
type TalukModel {
  #
  taluk_id: Int!

  #
  name: String!

  #
  district_id: Int!

  #
  status: Int!

  #
  type: String
}

#
type VillageModel {
  #
  village_id: Int!

  #
  name: String!

  #
  panchayat_id: Int!

  #
  taluk_id: Int!

  #
  district_id: Int!

  #
  status: Int!

  #
  type: String
}

#
type PanchayatModel {
  #
  panchayat_id: Int!

  #
  name: String!

  #
  taluk_id: Int!

  #
  district_id: Int!

  #
  status: Int!

  #
  type: String
}

#
type ClientReportAssign {
  #
  id: Int!

  #
  clientLoginId: Int!

  #
  category: Int!

  #
  reportName: String!

  #
  fields: [Fields!]

  #
  reportType: String
}

#
type AirtelPlans {
  #
  planCode: String!

  #
  planName: String!

  #
  planDescription: String!

  #
  billFrequency: String!

  #
  brandName: String!

  #
  price: String!

  #
  testPlan: String!
}

#
enum simFilterType {
  # Mobile number
  MSISDN

  # Sim number
  SIM_NO
}

#
type AirtelSimDetails {
  #
  mobileNo: String!

  #
  simNo: String!

  #
  imsi: String!

  #
  status: String!

  #
  circleName: String!

  #
  planCode: String!

  #
  planName: String!

  #
  description: String!

  #
  dataType: String!

  #
  onboardingDate: String!

  #
  activationDate: String!

  #
  operatorName: String!
}

#
type WppStaticData {
  #
  wppId: String

  #
  installationDate: String

  #
  latLong: String

  #
  district: String

  #
  taluk: String

  #
  panchayat: String

  #
  village: String

  #
  plantCapacity: Int

  #
  agency: String

  #
  rawTds: Int

  #
  pureTds: Int

  #
  operatorName: String

  #
  operatorContactNumber: String
}

#
type AreaInfo {
  #
  areaName: String!

  #
  areaType: String!

  #
  areaId: Int

  #
  clientLoginId: Int!
}

#
type getAllSharedLiveLocationResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  shared_live_locations: [shared_live_locations_details]
}

#
type shared_live_locations_details {
  #
  request_id: Int

  #
  vin: String

  #
  shared_by_app_user_id: String

  #
  map_provider: String

  #
  share_name: String

  #
  shared_to_emails: [String]

  #
  shared_to_sms: [country_code]

  #
  shared_to_app_users_ids: [String]

  #
  app_user_id_ended_by: String

  #
  time_to_share_till: String

  #
  destination: [lat_long]

  #
  created_at: String

  #
  updated_at: String

  #
  expired_time: String

  #
  token: String

  #
  shared_link: String

  #
  status: Int

  #
  is_sos_raised: Boolean

  #
  is_crash_raised: Boolean

  #
  is_theft_raised: Boolean
}

#
type country_code {
  #
  country_code: Int

  #
  iso_code: String

  #
  mobile_number: String
}

#
type lat_long {
  #
  lat: String!

  #
  long: String!
}

#
type sharedLiveShortLinkDetails {
  #
  id: Int

  #
  token: String!

  #
  expired_time: String

  #
  shared_link: String!

  #
  shorten_token: String!
}

#
type fetchEmergencyContactsResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  contacts_details: [fetchcontacts_detailsResponse]
}

#
type fetchcontacts_detailsResponse {
  #
  emergency_contact_id: Int!

  #
  app_user_id: String!

  #
  vin: String!

  #
  emergency_contact_name: String!

  #
  iso_code: String!

  #
  country_code: Int

  #
  emergency_mobile_number: String!

  #
  email_id: String

  #
  created_timestamp: String

  #
  updated_timestamp: String

  #
  status: Int
}

#
type offlineMapsResponse {
  #
  response: [responeData]

  #
  status: Int

  #
  statusMessage: String
}

#
type responeData {
  #
  id: Int

  #
  vin: String

  #
  map1: String

  #
  size1: Float

  #
  map2: String

  #
  size2: Float

  #
  created_at: String

  #
  update_at: String
}

#
type HomeChargerDetailsResponse {
  #
  details: HomeChargerDetails

  #
  status: Int!

  #
  statusMessage: String!
}

#
type HomeChargerDetails {
  #
  hc_imei: String!

  #
  associated_vin: String!

  #
  primary_bat_a_uid: String

  #
  primary_bat_b_uid: String

  #
  secondary_batteries_uid: [SecondaryBatteries]
}

#
type SecondaryBatteries {
  #
  bat_uids: String
}

#
type DomainConfiguration {
  #
  domain: String!

  #
  header: DomainConfigurationHeader!

  #
  page: DomainConfigurationPage

  #
  customPage: Boolean!

  #
  customPageId: String
}

#
type DomainConfigurationHeader {
  #
  title: String!

  #
  shortcutIcon: String

  #
  icon16: String

  #
  icon32: String

  #
  appleTouchIcon: String
}

#
type DomainConfigurationPage {
  #
  title: String

  #
  subtitle: String

  #
  background: String

  #
  logo: String

  #
  navbarConfig: NavbarConfig

  #
  splash1: String

  #
  splash2: String

  #
  splash3: String

  #
  tagline: String

  #
  footerLink: String

  #
  darkMode: Boolean

  #
  color: String
}

#
type NavbarConfig {
  #
  logo: String

  #
  title: String
}

#
type UserConfiguration {
  #
  config: UserConfigData!

  #
  plan: JSON!
}

#
type UserConfigData {
  #
  loginId: Int!

  #
  theme: JSON!

  #
  configuration: JSON!
}

#
type TravelHistory {
  #
  distanceTravelledKms: Float!

  #
  points: [TravelReplayPacket!]!
}

#
type TravelReplayPacket {
  #
  ts: String

  #
  lat: Float!

  #
  lng: Float!

  #
  speed: Float

  #
  isHA: Boolean

  #
  isHB: Boolean

  #
  satellites: Int

  # Key used to fetch a string address
  pluscode: String

  # reverse geo-coded address string from google
  address: String
}

#
type RawLocationData {
  #
  timestamp: String

  #
  latitude: Float

  #
  longitude: Float

  #
  gpsStatus: String

  #
  isHA: Boolean

  #
  isHB: Boolean

  #
  satellites: Int

  #
  isNoGps: Boolean

  #
  speed: Float

  #
  extBatVol: Float

  #
  direction: Int

  #
  address: String
}

#
input CoordinateInput {
  #
  lat: Float!

  #
  lng: Float!
}

#
type PlusCodeAddress {
  #
  plusCode: String!

  #
  address: String!

  #
  postal_code: String

  #
  city: String

  #
  country: String

  #
  state: String
}

# Has both latlng and label
type PlaceFeature {
  #
  geometry: CoordinateArray!

  #
  properties: FeatureProperty!
}

#
type CoordinateArray {
  # coordinates = [lng, lat]
  coordinates: [Float!]!
}

#
type FeatureProperty {
  #
  id: String!

  #
  gid: String!

  # Address of the place pointed by coordinate
  label: String!
}

#
input RouteCoordinateInput {
  #
  lat: Float!

  #
  lon: Float!

  #
  type: RouteCoordinateType
}

#
enum RouteCoordinateType {
  #
  break

  #
  through
}

#
type RouteDetails {
  #
  trip: RouteTrip
}

#
type RouteTrip {
  #
  legs: [Leg]

  #
  summary: Summary
}

#
type Leg {
  #
  shape: [RouteCoordinate!]!

  #
  summary: Summary!
}

#
type RouteCoordinate {
  #
  lat: Float!

  #
  lon: Float!
}

#
type Summary {
  #
  max_lon: Float!

  #
  max_lat: Float!

  #
  time: Float!

  #
  length: Float!

  #
  min_lat: Float!

  #
  min_lon: Float!
}

#
enum mapType {
  #
  GOOGLE

  #
  HEREMAP

  #
  OPENSTREETMAP
}

#
input FileInput {
  #
  bucketName: String!

  #
  filename: String!
}

#
type ParsedData {
  #
  stringifiedRowJSON: String!
}

#
input Data {
  #
  stringifiedRowJSON: String!
}

#
type DownloadFile {
  #
  bucketName: String!

  #
  filename: String!

  #
  filePublicDownloadURL: String!
}

#
type Alert {
  #
  clientid: Int!

  #
  uniqueid: String!

  #
  alerttype: String!

  #
  alertvalue: String

  #
  from_ts: String!

  #
  to_ts: String!

  #
  server_ts: String!

  #
  areaandroute: String

  #
  lat: Float

  #
  lng: Float

  #
  to_lat: Float

  #
  to_lng: Float

  #
  alert_completed: Boolean!

  #
  view_status: Boolean!

  #
  pluscode: String

  #
  address: String

  #
  vehicleNumber: String

  #
  type: String
}

#
enum alerttype {
  #
  aoi

  #
  overspeed

  #
  pullout

  #
  tow

  #
  sos

  #
  panic

  #
  noResponse

  #
  scheduleMaintenance

  #
  IntBatLow

  #
  halt

  #
  idle

  #
  ExtBatLow

  #
  route

  #
  conditionalMaintenance

  #
  crash

  #
  fall

  #
  theft

  #
  soc

  #
  vehicle_charging

  #
  vehicle_ignition

  #
  homecharger_charging

  #
  battery_fully_charged

  #
  battery_taken_out
}

#
type allAlertResponse {
  #
  status: Int!

  #
  statusMessage: String!

  #
  response: [alertResponse]
}

#
type alertResponse {
  #
  alerttype: String!

  #
  alertvalue: String!

  #
  from_ts: String!

  #
  to_ts: String

  #
  server_ts: String!

  #
  from_lat: Float!

  #
  from_lng: Float!

  #
  to_lat: Float!

  #
  to_lng: Float!

  #
  alert_completed: Boolean!

  #
  address: String!

  #
  to_address: String

  #
  vin: String

  #
  areaandroute: String!

  #
  alert_generated_by_app_userid: String

  #
  alert_ended_by_app_user_id: String

  #
  from_timestamp: String

  #
  to_timestamp: String

  #
  request_id: String

  #
  live_location_link: String

  #
  to_be_expired_at: String

  #
  event_id: String

  #
  threshold_type: String
}

#
type testTrackingHistory {
  #
  trackingHistory: [trackingHistoryData]

  #
  vin: String!

  #
  status: Int!

  #
  statusMessage: String!
}

#
type trackingHistoryData {
  #
  uniqueid: String

  #
  device_time: String

  #
  lat: Float

  #
  lng: Float

  #
  isha: Boolean

  #
  ishb: Boolean

  #
  distance: Float

  #
  event_flag: Int

  #
  fl_level: Int

  #
  gps_statu: String

  #
  gsm_signal: Int

  #
  direction: String

  #
  external_bat_voltage: String

  #
  internal_bat_voltage: String

  #
  satellites: Int

  #
  hdop: Float

  #
  temperature: Float

  #
  delta_distance: String

  #
  pluscode: String

  #
  packet_event_code: String

  #
  server_ts: String
}

#
type OverspeedInstance {
  #
  ts: String!

  #
  location: String!

  #
  speed: String!

  #
  speedLimit: String!
}

#
type trackVehiclesCount {
  #
  tracking: Int!

  #
  nonTracking: Int!
}

#
type DayWiseReportObject {
  #
  uniqueId: String!

  #
  date: String

  #
  startTime: String

  #
  endTime: String

  #
  startLocation: Location

  #
  endLocation: Location

  #
  totalDistance: Float

  #
  speedStatus: MinMaxSpeed

  #
  travelledAreas: [String]
}

#
type Location {
  #
  latitude: String

  #
  longitude: String

  #
  address: String
}

#
type MinMaxSpeed {
  #
  min: Float

  #
  max: Float
}

#
type ConsolidatedReportObject {
  #
  uniqueid: String!

  #
  start_time: String

  #
  start_loc: String

  #
  end_time: String

  #
  end_loc: String

  #
  totalHaltTime: String!

  #
  totalRunTime: String!

  #
  totalDistance: Float!

  #
  totalHb: Int!

  #
  totalHa: Int!

  #
  avg_speed: Float!
}

#
type CategoryOneObject {
  #
  uniqueid: String

  #
  dateTime: String

  #
  location: String

  #
  address: String

  #
  cumDist: Float

  #
  micellio_dist: Float

  #
  obddistance: Float

  #
  speed: Float

  #
  vehiclespeed: Float

  #
  micellio_speed: Float

  #
  coolant: Float

  #
  engine: String

  #
  milege: String

  #
  engine_load: Float

  #
  engine_rpm: Float

  #
  maf_air_flow: Float

  #
  vin: String

  #
  intake_pressure: Float

  #
  intakeAirTemp: Float

  #
  throttle_pos: Float

  #
  runtime_p: Float

  #
  engine_oil_temp: String

  #
  state_of_charge: Int

  #
  external_bat_voltage: Float

  #
  internal_bat_voltage: Float

  #
  tankLevel: Float

  #
  warmups: Int

  #
  fuelRail: Float

  #
  obdStandards: String

  #
  telltale: String

  #
  pto_drive_engagement: String

  #
  engine_torque_percent: String

  #
  service_distance: String

  #
  gross_combination_vehicle_weight: String

  #
  selected_gear: String

  #
  current_gear: String

  #
  fuel_consumption: Float

  #
  fuel_level: Float

  #
  fuel_rate: Float

  #
  fuel_economy: Float

  #
  accelerator_pedal_pos: Float

  #
  vehicle_weight: Float

  #
  air_suspension_pressure_front_axle_left: Float

  #
  air_suspension_pressure_front_axle_right: Float

  #
  air_suspension_pressure_rear_axle_left: Float

  #
  air_suspension_pressure_rear_axle_right: Float

  #
  battery_pack_current: Float

  #
  battery_pack_voltage: Float

  #
  power: Float

  #
  lamp_status: String

  #
  hydraulic_oil_filter: Int

  #
  air_filter: Int

  #
  no_charging: Int

  #
  low_fuel: Int

  #
  engine_temp_high: Int

  #
  hydraulic_oil_temp_high: Int

  #
  water_in_fuel: Int

  #
  low_oil_pressure: Int

  #
  roller_speed: Int

  #
  vibration_status: String

  #
  axle_position: Int

  #
  tire_position: Int

  #
  tire_pressure: String

  #
  tire_temperature: String

  #
  tire_air_leakage_rate: String

  #
  tire_sensor_enable_status: String

  #
  tire_status: String

  #
  tire_sensor_electric_fault: String

  #
  extended_tire_pressure_support: String

  #
  tire_pressure_threshold_detection: String

  #
  extended_tire_pressure: String

  #
  cpc_system_type: String

  #
  required_tire_pressure: Int

  #
  cpc_tire_id: Int

  #
  cpc_graphical_position: Int

  #
  cpc_tire_location: String

  #
  cpc_ttm_id: String

  #
  greaves_reference: Float

  #
  greaves_speed: Float

  #
  greaves_battery_voltage: Float

  #
  greaves_dischange_current: Float

  #
  greaves_temp_two: Float

  #
  greaves_temp_three: Float

  #
  greaves_temp_one: Float

  #
  greaves_charge_current: Float

  #
  micelio_battery_current: Float

  #
  micelio_battery_voltage: Float

  #
  micelio_max_discharge_current: Float

  #
  micelio_sop: Float

  #
  micelio_battery_soc: Float

  #
  micelio_full_cap: Float

  #
  micelio_max_charge_current: Float

  #
  micelio_max_charge_voltage: Float

  #
  micelio_soh: Float

  #
  micelio_lowest_cell_voltage: Float

  #
  micelio_highest_cell_voltage: Float

  #
  micelio_low_module_temp: Float

  #
  micelio_high_module_temp: Float

  #
  micelio_current_cycle_charge_capacity: Float

  #
  micelio_current_cycle_discharge_capacity: Float

  #
  micelio_lifetime_cycle_charge_capacity: Float

  #
  micelio_lifetime_cycle_discharge_capacity: Float

  #
  greaves_available_energy: Float

  #
  greaves_cycle_count: Float

  #
  greaves_motor_speed: Float

  #
  greaves_motor_temp: Float

  #
  greaves_controller_temp: Float

  #
  greaves_throttle_percentage: Float

  #
  greaves_fault_codes: String

  #
  greaves_battery_temp: Float

  #
  greaves_pdu_temp: Float

  #
  xval: String

  #
  yval: String

  #
  zval: String

  #
  micelio_bin: String

  #
  micelio_battery_status: String

  #
  batStatus: String

  #
  ignitionstatus: String

  #
  volR: String

  #
  volY: String

  #
  volB: String

  #
  frequency: String

  #
  ampR: String

  #
  ampY: String

  #
  ampB: String

  #
  KWCombined: String

  #
  KVACombined: String

  #
  PFCombined: String

  #
  KWHmain: String

  #
  rpm_genset: String

  #
  battery_voltage: String

  #
  alternator_voltage: String

  #
  llop: String

  #
  hwt: String

  #
  lfl: String

  #
  run_hour: String

  #
  run_min: String

  #
  ser_hour: String

  #
  ser_min: String

  #
  distance_since_mil: Float

  #
  commanded_egr: Float

  #
  egr_error: Float

  #
  drive_cycle_status: String

  #
  ambient_air_temperature: Float

  #
  fuel_system_status: String

  #
  short_term_fuel_trim_bank_1: Float

  #
  long_term_fuel_trim_bank_1: Float

  #
  timing_advance: Float

  #
  oxygen_sensors_present: Float

  #
  oxygen_sensor_1_voltage: Float

  #
  oxygen_sensor_2_voltage: Float

  #
  commanded_evaporative_purge: Float

  #
  control_module_voltage: Float

  #
  absolute_load_value: Float

  #
  relative_throttle_position: Float

  #
  oxygen_sensor_1_short_term_fuel_trim: Float

  #
  oxygen_sensor_2_short_term_fuel_trim: Float

  #
  secondary_air_status: String

  #
  catalyst_temperature_bank1_sensor1: String

  #
  catalyst_temperature_bank1_sensor2: String

  #
  barometric_pressure: String

  #
  virya_odomoter: Float

  #
  virya_soc: Float

  #
  virya_dte: Float

  #
  virya_time_to_charge: Float

  #
  virya_battery_temp: Float

  #
  virya_controller_temp: Float

  #
  virya_motor_temp: Float

  #
  virya_battery_voltage: Float

  #
  virya_key_switch_voltage: Float

  #
  virya_speed: Float

  #
  virya_battery_current: Float

  #
  virya_drive_current_limit: Float

  #
  virya_regen_current_limit: Float

  #
  virya_key_on_indicator: String

  #
  virya_battery_light: String

  #
  virya_battery_swap_status: String

  #
  virya_battery_state: String

  #
  virya_drive_mode: String

  #
  virya_regen_flag: String

  #
  virya_vehicle_mode_request: String

  #
  can_raw_data: String

  #
  virya_dtc: String

  #
  temperature: String

  #
  analog1: Int

  # Not Yet Implemented
  flLevel: Float

  # Not Yet Implemented
  acStatus: String

  #
  jascon_battery_current: Float

  #
  jascon_battery_temp: Float

  #
  jascon_battery_voltage: Float

  #
  jascon_charger_status: String

  #
  jascon_charging_volts: Float

  #
  jascon_soc: Float

  #
  jascon_charging_current: Float

  #
  alti_tq_demand: Float

  #
  alti_torque: Float

  #
  alti_battery_voltage: Float

  #
  alti_battery_current: Float

  #
  alti_throttle: Float

  #
  alti_brake: Float

  #
  alti_im_temp: Float

  #
  alti_inverter_temp: Float

  #
  alti_vehicle_speed: Float

  #
  alti_dte: Float

  #
  alti_bms_voltage: Float

  #
  alti_bms_current: Float

  #
  alti_bms_soc: Float

  #
  alti_ev_mileage: Float

  #
  alti_bv_12: Float

  #
  alti_wheel_power: Float

  #
  alti_trip_dist: Float

  #
  alti_ib_pc: Float

  #
  alti_ic_pc: Float

  #
  alti_ia_pc: Float

  #
  alti_motor_config: Int

  #
  alti_software_checksum: Int

  #
  alti_vehicle_config: Int

  #
  alti_io_status: Int

  #
  alti_odo_low: Int

  #
  alti_odo_hi: Int

  #
  alti_fault_code_2: Int

  #
  alti_fault_code: Float

  #
  alti_shaft_speed: Int

  #
  log9_voltage: Float

  #
  log9_current: Float

  #
  log9_soc: Float

  #
  log9_max_monomer_vol: Float

  #
  log9_min_monomer_vol: Float

  #
  log9_charging_tube_status: String

  #
  log9_discharging_tube_status: String

  #
  log9_residual_capacity: Float

  #
  log9_charge_discharge_cycles: Float

  #
  log9_bmslife: Float

  #
  log9_min_monomer_temp: Float

  #
  log9_max_monomer_temp: Float

  #
  log9_min_vol_cell_no: Float

  #
  log9_max_vol_cell_no: Float

  #
  log9_error: String

  #
  log9_unswitched_pack_voltage: Float

  #
  log9_pack_current: Float

  #
  log9_switched_pack_voltage: Float

  #
  log9_v_min: Float

  #
  log9_v_max: Float

  #
  log9_v_min_id: Float

  #
  log9_v_max_id: Float

  #
  log9_t_min: Float

  #
  log9_t_max: Float

  #
  log9_t_avg: Float

  #
  log9_t_min_id: Float

  #
  log9_t_max_id: Float

  #
  log9_charging_current_limit: Float

  #
  log9_discharging_current_limit: Float

  #
  pulse_data: String

  #
  tds_data: String

  #
  vaaku_data0: Float

  #
  vaaku_voltage: Float

  #
  vaaku_curr_calc_factor: Float

  #
  vaaku_current: Float

  #
  vaaku_soc: Float

  #
  vaaku_soh_1: Float

  #
  vaaku_alert_status_1: String

  #
  vaaku_alert_status_2: String

  #
  vaaku_temp_1: Float

  #
  vaaku_temp_2: Float

  #
  vaaku_temp_3: Float

  #
  vaaku_temp_4: Float

  #
  vaaku_temp_5: Float

  #
  vaaku_temp_6: Float

  #
  vaaku_soh_2: Float

  #
  vaaku_data7: Float

  #
  oye_battery_voltage: Float

  #
  oye_battery_current: Float

  #
  oye_remaining_capacity: Float

  #
  oye_full_capacity: Float

  #
  oye_no_discharge_cycles: Float

  #
  oye_rsoc: Float

  #
  mosfet_status: String

  #
  oye_ntc_temp: String

  #
  oye_error: String
}

#
type CategoryOBDObject {
  #
  uniqueid: String

  #
  dateTime: String

  #
  coolant: Float

  #
  engine: String

  #
  milege: String

  #
  engine_load: Float

  #
  engine_rpm: Float

  #
  vehicle_speed: Float

  #
  maf_air_flow: Float

  #
  distance_travelled: Float

  #
  vin: String

  #
  intake_pressure: Float

  #
  throttle_pos: Float

  #
  runtime_p: Float

  #
  engine_oil_temp: String

  #
  soc: Int
}

#
type CategoryTwoObject {
  #
  uniqueid: String

  #
  tripId: Int

  #
  startTime: String

  #
  endTime: String

  #
  alertDur: Float

  #
  alertLoc: String

  #
  alertAddress: String

  #
  startLoc: String

  #
  startAddress: String

  #
  endAddress: String

  #
  endLoc: String

  #
  totalDist: Float

  #
  totalRunningTime: Float

  #
  totalHaltTime: Float

  #
  totalHaCount: Int

  #
  totalHbCount: Int

  #
  avgSpeed: Float

  #
  totalIdlingTime: Float

  #
  totalOsDist: Float

  #
  dayStartTime: String

  #
  dayStartLoc: String

  #
  dayStartAddress: String

  #
  currLoc: String

  #
  currAddress: String

  #
  batStatus: String

  #
  currSpeed: Float

  #
  date: String

  #
  travelledAreas: String

  #
  speedMinMax: String

  #
  lastTrackTime: String

  #
  distCoverToday: Float

  #
  tripName: String

  #
  scheduledStartTimeAndLoc: String

  #
  scheduledEndTimeAndLoc: String

  #
  actualStartTimeAndLoc: String

  #
  actualEndTimeAndLoc: String

  #
  routeBreaches: String

  #
  wayPointInOuts: String

  #
  AoiName: String

  #
  AoiInTime: String

  #
  AoiOutTime: String

  #
  changeInsoc: String

  #
  socRange: String

  #
  socType: String

  #
  chargingLocation: String

  # Not Yet Implemented
  currVehicleStat: String

  # Not Yet Implemented
  minTemp: Float

  # Not Yet Implemented
  maxTemp: Float

  # Not Yet Implemented
  avgTemp: Float

  # Not Yet Implemented
  totAcOnDur: Float

  # Not Yet Implemented
  totAcOffDur: Float

  # Not Yet Implemented
  totalScore: Float

  # Not Yet Implemented
  groupName: String

  # Not Yet Implemented
  driverName: String

  #
  maxSpeed: Float

  # Not Yet Implemented
  flConsumed: Float

  # Not Yet Implemented
  mileage: Float

  # Not Yet Implemented
  totalTrips: Int

  # Not Yet Implemented
  startFlLevel: Float

  # Not Yet Implemented
  endFlLevel: Float

  # Not Yet Implemented
  flAdded: Float

  # Not Yet Implemented
  flAddTimeAndLoc: String

  # Not Yet Implemented
  flRmTimeAndLoc: String

  # Not Yet Implemented
  flRemoved: Float

  # Not Yet Implemented
  yardName: String

  # Not Yet Implemented
  poiName: String

  # Not Yet Implemented
  poiType: String

  #
  Di_1_ON: String

  #
  Di_1_OFF: String

  #
  Di_2_ON: String

  #
  Di_2_OFF: String

  #
  Di_3_ON: String

  #
  Di_3_OFF: String

  #
  Di_4_ON: String

  #
  Di_4_OFF: String

  #
  fuelStartTime: String

  #
  fuelEndTime: String

  #
  generatorId: String

  #
  generatorCapacity: Int

  #
  agenceVille: String

  #
  avgConsumption: Int

  #
  tankCapacity: Int

  #
  activityStatus: String

  #
  startIndex: Int

  #
  endIndex: Int

  #
  refuelCount: Int

  #
  refuelAmount: Float

  #
  pilferageCount: Int

  #
  pilferageAmount: Float

  #
  runtime_p: Float

  #
  totalFuelUsed: Float

  #
  actualConsumption: Float

  #
  variance: Float

  #
  totalEngineHours: Float

  #
  active: String

  #
  vehicleNumber: String

  #
  vehicleType: String

  #
  duration: Float

  #
  minSpeed: Float

  #
  suddenAccelrations: Int

  #
  suddenBreaks: Int

  #
  totalDistanceAtSpeed_0_8: Float

  #
  totalDistanceAtSpeed_8_12: Float

  #
  totalDistanceAtSpeed_12_20: Float

  #
  totalDistanceAtSpeed_20: Float

  #
  vehicleStartAddress: String

  #
  vehicleEndAddress: String

  #
  contractorName: String

  #
  totalRouteDeviatedTime: Float

  #
  aoiInDistance: Float

  #
  replayLink: String

  #
  totalDistOBD: Float

  #
  energyConsumption: Float

  #
  tripCount: Int

  #
  districtName: String

  #
  baseLocationName: String

  #
  baseLocationCods: String

  #
  baseStartTime: String

  #
  campEndTime: String

  #
  campLocationName: String

  #
  campLocationCods: String

  #
  baseToCampDistance: Float

  #
  campStartTime: String

  #
  baseLocationEndTime: String

  #
  campBaseDistance: Float

  #
  durationFromCampToBase: Float

  #
  totalDistance: Float

  #
  timeDeviation: String

  #
  campDeviation: String

  #
  baseLocationAOI: String

  #
  campLocationAOI: String

  #
  totalDistanceInKm: Float

  #
  socStartTime: String

  #
  socEndTime: String

  #
  speedLimit: Float

  #
  hc: Int

  #
  idlePercent: Float

  #
  totalOsCount: Int

  #
  chargeCurrent: Float

  #
  dischargeCurrent: Float

  #
  voltageRange: String

  #
  avgCc: Float

  #
  power: Float

  #
  eventType: String

  #
  location: String

  #
  socRangeTracking: String

  #
  range: Float
}

#
type CategoryThreeObject {
  #
  uniqueid: String

  #
  startTime: String

  #
  startLoc: String

  #
  endTime: String

  #
  endLoc: String

  #
  startAddress: String

  #
  endAddress: String

  #
  totalDist: Float

  #
  totalRunningTime: Float

  #
  totalHaltTime: Float

  #
  totalHaCount: Int

  #
  totalHbCount: Int

  #
  avgSpeed: Float

  #
  totalIdlingTime: Float

  #
  totalOsDist: Float

  #
  dayStartTime: String

  #
  dayStartLoc: String

  #
  dayStartAddress: String

  #
  currLoc: String

  #
  currAddress: String

  #
  batStatus: String

  #
  currSpeed: Float

  #
  lastTrackTime: String

  #
  distCoverToday: Float

  #
  vin: String

  #
  fuelType: String

  #
  totalNightDriveTime: Float

  #
  totalDayDriveTime: Float

  #
  totalMachineHours: Int

  #
  totalFuelConsumed: Float

  #
  totalScore: Float

  #
  totalOsCount: Int

  #
  totalOsTime: Float

  # Total distance covered while Ignition off
  totalDistanceIgOff: Float

  # Total distance covered while Ignition on
  totalDistanceIgOn: Float

  # Total halt time while Ignition off
  totalHaltTimeIgOff: Int

  # Total idling time while Ignition on
  totalIdlingTimeIgOn: Int

  # Total Ignition off time
  totalIgOffTime: Int

  # Total Ignition on time
  totalIgOnTime: Int

  # Total running time while Ignition off
  totalRunningTimeIgOff: Int

  # Total running time while Ignition on
  totalRunningTimeIgOn: Int

  #
  routeDeviationDistance: Float

  #
  onRouteDistance: Float

  #
  omniFlConsumed: Float

  #
  omniRefuel: Float

  #
  omniDraining: Float

  #
  totalDuration: String

  #
  fuelConsumedLitrePerHour: Float

  #
  idleHours: String

  #
  revenueHours: String

  #
  standAloneHours: String

  #
  totalEngineOnTime: String

  # Not Yet Implemented
  currVehicleStat: String

  # Not Yet Implemented
  minTemp: Float

  # Not Yet Implemented
  maxTemp: Float

  # Not Yet Implemented
  avgTemp: Float

  # Not Yet Implemented
  totAcOnDur: Float

  # Not Yet Implemented
  totAcOffDur: Float

  # Not Yet Implemented
  groupName: String

  # Not Yet Implemented
  driverName: String

  #
  maxSpeed: Float

  # Not Yet Implemented
  alertDur: Float

  # Not Yet Implemented
  flConsumed: Float

  # Not Yet Implemented
  mileage: Float

  # Not Yet Implemented
  totalTrips: Int

  # Not Yet Implemented
  startFlLevel: Float

  # Not Yet Implemented
  endFlLevel: Float

  # Not Yet Implemented
  flAdded: Float

  # Not Yet Implemented
  flAddTimeAndLoc: String

  # Not Yet Implemented
  flRmTimeAndLoc: String

  # Not Yet Implemented
  flRemoved: Float

  # Not Yet Implemented
  yardName: String

  # Not Yet Implemented
  poiName: String

  # Not Yet Implemented
  poiType: String

  #
  fuelStartTime: String

  #
  fuelEndTime: String

  #
  generatorId: String

  #
  generatorCapacity: Int

  #
  agenceVille: String

  #
  avgConsumption: Int

  #
  tankCapacity: Int

  #
  activityStatus: String

  #
  startIndex: Int

  #
  endIndex: Int

  #
  refuelCount: Int

  #
  refuelAmount: Float

  #
  pilferageCount: Int

  #
  pilferageAmount: Float

  #
  runtime_p: Float

  #
  totalFuelUsed: Float

  #
  actualConsumption: Float

  #
  variance: Float

  #
  totalEngineHours: Float

  #
  totalDistOBD: Float

  #
  totalRunningTimeOBD: Float

  #
  avgSpeedOBD: Float

  #
  maxSpeedOBD: Float

  #
  idlePercent: Float
}

#
type reportPagination {
  #
  categoryOneFields: [CategoryOneObject]

  #
  categoryTwoFields: [CategoryTwoObject]

  #
  categoryThreeFields: CategoryThreeObject

  #
  end_ts: String

  #
  continue_flag: Boolean

  #
  previousDist: Float

  #
  totalDIEvents: Int

  #
  total_DI_1_Events: Int

  #
  total_DI_2_Events: Int

  #
  total_DI_3_Events: Int

  #
  total_DI_4_Events: Int

  #
  status: Int

  #
  statusMessage: String
}

#
enum fileTypes {
  #
  PDF

  #
  EXCEL
}

#
type reportDownloadLink {
  #
  downloadLink: String
}

#
enum KMFREQUENCY {
  #
  MONTHLY

  #
  DAILY
}

#
type dailyDistance {
  #
  uniqueId: String

  #
  vehicleNumber: String

  #
  totaldist: Float

  #
  noOfPackets: Int

  #
  noOfDays: Int

  #
  date: String

  #
  month: String
}

#
enum TimeRange {
  #
  DAY

  #
  WEEK

  #
  MONTH

  #
  ALL_TIME
}

#
type DownloadLink {
  #
  downloadLink: String
}

#
type currentTrackinfoObj {
  #
  vehicleNumber: String

  #
  deviceSlNumber: String

  #
  phoneNumber: String

  #
  imeiNumber: String

  #
  simNumber: String

  #
  deviceVersion: String

  #
  vehicleModel: String

  #
  clientName: String

  #
  gpsSpeed: Float

  #
  coordinates: String

  #
  address: String

  #
  vehicleGroup: String

  #
  timestamp: String

  #
  trackingStatus: String

  #
  batteryStatus: String

  #
  Status: client_status

  #
  ignitionStatus: String

  #
  gprsSignalStrength: String

  #
  customerName: String

  #
  fuelRawValue: Int

  #
  fuelRawTimestamp: String
}

#
enum client_status {
  #
  ACTIVE

  #
  INACTIVE
}

#
type idleCurrentTrackinfoObj {
  #
  vehicleNumber: String

  #
  deviceSlNumber: String

  #
  phoneNumber: String

  #
  imeiNumber: String

  #
  simNumber: String

  #
  deviceVersion: String

  #
  vehicleModel: String

  #
  clientName: String

  #
  gpsSpeed: Float

  #
  coordinates: String

  #
  address: String

  #
  vehicleGroup: String

  #
  timestamp: String

  #
  trackingStatus: String

  #
  batteryStatus: String
}

#
type vehicleAnayticDataObj {
  #
  vehicleNo: String

  #
  timestamp: String

  #
  imeiNumber: String

  #
  mobileNumber: String

  #
  firmwareVersion: Float

  #
  vehicleStatus: String

  #
  totalTrackingpacketsReceived: Int

  #
  ignitionOnMinutes: String

  #
  ignitionOnTrackingPackets: Int

  #
  ignitionOffMinutes: String

  #
  ignitionOffTrackingPackets: Int

  #
  mainPowerConnectedPackets: Int

  #
  mainPowerDisconnectedPackets: Int

  #
  noDataInMinutes: Int

  #
  livePacketsCount: Int

  #
  historyPacketsCount: Int

  #
  livePacketPercentage: Float

  #
  gnssValidDataCount: Int

  #
  gnssInvalidDataCount: Int

  #
  validDataPercentage: Float

  #
  invalidWithIgnitionOn: Int

  #
  invalidWithIgnitionOff: Int
}

#
type NumberOfPackets {
  #
  uniqueId: String!

  #
  numOfPackets: String!
}

#
type fetchSmsDataReponse {
  #
  response: [SmsData]

  #
  status: Int!

  #
  statusMessage: String!
}

#
type SmsData {
  #
  vehicleNumber: String

  #
  message_sent: String

  #
  alert_type: String

  #
  alert_time: String

  #
  app_user_id: String

  #
  sent_to: String

  #
  category: String

  #
  type: String

  #
  notification_status: String

  #
  response_data: String

  #
  updatedAt: String

  #
  status: String
}

#
type fetchwhatsappDataReponse {
  #
  response: [WhatsappData]

  #
  status: Int!

  #
  statusMessage: String!
}

#
type WhatsappData {
  #
  vehicleNumber: String

  #
  mobileNumber: String

  #
  message: String

  #
  sender_id: String

  #
  sentAt: String

  #
  updatedAt: String

  #
  status: String

  #
  sent_to: String

  #
  category: String

  #
  type: String

  #
  response_data: String
}

#
type fetchEmailDataReponse {
  #
  response: [EmailData]

  #
  status: Int!

  #
  statusMessage: String!
}

#
type EmailData {
  #
  vin: String

  #
  user_id: String

  #
  clientLoginId: String

  #
  category: String

  #
  type: String

  #
  sent_to: String

  #
  subject: String

  #
  body: String

  #
  retry_count: String

  #
  response_data: String

  #
  createdAt: String

  #
  updatedAt: String

  #
  status: String
}

#
type LocationData {
  #
  timestamp: String

  #
  latitude: Float

  #
  longitude: Float

  #
  gpsStatus: String

  #
  isHA: Boolean

  #
  isHB: Boolean

  #
  isPrimaryBattery: Boolean

  #
  isNoGps: Boolean

  #
  speed: Float

  #
  extBatVol: Float

  #
  direction: Int

  #
  distance: String

  #
  location: String

  #
  eventFlag: String

  #
  plusCode: String
}

#
type LatestData {
  #
  vehicleData: staticVehicleData

  #
  trackingData: trackingData

  #
  ioStatus: ioStatus
}

#
type staticVehicleData {
  #
  vehicleNumber: String

  #
  vehicleType: String

  #
  vehicleModel: String

  #
  uniqueId: String

  #
  vehicleGroups: [String]
}

#
type trackingData {
  #
  timestamp: String

  #
  latitude: Float

  #
  longitude: Float

  #
  gpsStatus: String

  #
  isHA: Boolean

  #
  isHB: Boolean

  #
  isPrimaryBattery: Boolean

  #
  isNoGps: Boolean

  #
  speed: Float

  #
  extBatVol: Float

  #
  location: String

  #
  eventFlag: String

  #
  plusCode: String

  #
  satellites: Int

  #
  isOffline: Boolean

  #
  isNoData: Boolean

  #
  idlingStatus: Boolean

  #
  haltStatus: Boolean
}

#
type ioStatus {
  #
  digitalIn1: Boolean

  #
  digitalIn2: Boolean

  #
  digitalIn3: Boolean

  #
  digitalIn4: Boolean

  #
  digitalOut1: Boolean

  #
  digitalOut2: Boolean

  #
  analogIn1: Float

  #
  analogIn2: Float
}

#
type HealthDistribution {
  #
  moderate: Int

  #
  good: Int

  #
  critical: Int

  #
  healthDataObj: [HealthData]
}

#
type HealthData {
  #
  vehicleNumber: String

  #
  vehicleType: String

  #
  vehicleModel: String

  #
  vehicleScore: Float

  #
  vehicleHealth: String

  #
  uniqueid: String

  #
  totalDTCs: Int

  #
  latestOdometerKM: String
}

#
type getCurrentSummaryData {
  #
  uniqueid: String

  #
  startTime: String

  #
  startLoc: String

  #
  endTime: String

  #
  endLoc: String

  #
  distance: String

  #
  speed: String

  #
  maxSpeed: String

  #
  avgSpeed: String

  #
  startAddress: String

  #
  endAddress: String

  #
  clientName: String

  #
  driverName: String

  #
  vehicleNumber: String

  #
  vehicleGroupAssign: String

  #
  trackingStatus: String

  #
  batteryStatus: String
}

#
type getOverspeedData {
  #
  startTime: String

  #
  endTime: String

  #
  alertDur: Float

  #
  alertLoc: String

  #
  maxSpeed: Int

  #
  overspeedAddress: String

  #
  avgSpeed: Float

  #
  totalHaCount: Int

  #
  totalHbCount: Int

  #
  totalOsDist: Float

  #
  groupName: String

  #
  driverName: String

  #
  downloadLink: String
}

#
type getWeeklySummaryData {
  #
  distanceCovered: [distanceCovered]

  #
  driverScore: String

  #
  greenKm: String

  #
  speedAlertMap: [speedAlertMap]

  #
  fuelConsumend: String

  #
  idlingTime: String

  #
  totalDrivingMinutes: String

  #
  totalTrips: String

  #
  totalDistance: String
}

#
type distanceCovered {
  #
  date: String

  #
  distance: String
}

#
type speedAlertMap {
  #
  tripId: String

  #
  averageSpeed: String

  #
  numberOfAlarms: String
}

#
type RMSFleetAnalytics {
  #
  totalNumberOfCansDispensed: Int

  #
  cansDispensedHourWise: [CanData]

  #
  totalOperationalWPP: Int

  #
  totalNonOperationalWPP: Int

  #
  tdsOfWater: String

  #
  tdsData: Float

  #
  tdsCount: [TDSCount]
}

#
type CanData {
  #
  date: String

  #
  hour: String

  #
  totalCans: Int
}

#
type TDSCount {
  #
  status: String

  #
  count: Int
}

#
type WPPTrend {
  #
  wppSalesDate: [WPPSalesTrend]
}

#
type WPPSalesTrend {
  #
  date: String

  #
  hour: String

  #
  totalSales: Float

  #
  totalTds: Float
}

#
type DistrictData {
  #
  totalWPP: Int

  #
  wppData: [DistrictDataWpp]

  #
  totalRMS: Int

  #
  rmsData: [DistrictDataRms]
}

#
type DistrictDataWpp {
  #
  timeLineName: String

  #
  totalOperationalWPP: Int

  #
  totalNonOperationalWPP: Int
}

#
type DistrictDataRms {
  #
  timeLineName: String

  #
  totalOperationalRMS: Int

  #
  totalNonOperationalRMS: Int
}

#
type TalukData {
  #
  talukName: String

  #
  totalRMS: talukDataRms

  #
  totalWPP: talukDataWpp

  #
  data: [talukDataParam]
}

#
type talukDataRms {
  #
  totalOperationalRMS: Int

  #
  totalNonOperationalRMS: Int
}

#
type talukDataWpp {
  #
  totalOperationalWPP: Int

  #
  totalNonOperationalWPP: Int
}

#
type talukDataParam {
  #
  timeLineName: String

  #
  numberOfCansDispensed: Int

  #
  maximumTds: Float

  #
  minimumTds: Float

  #
  averageTds: Float
}

#
type TPMSaggregates {
  #
  date: String

  #
  no_warn: String

  #
  under_pressure: String

  #
  extreme_under_pressure: String
}

#
type TPMSalerts {
  #
  ts: String

  #
  vehicleNumber: String

  #
  temperature: String

  #
  pressure: String

  #
  alertName: String
}

#
enum AlertTypeMaster {
  #
  waypoint

  #
  aoi
}

#
type alertHistory {
  # Client Login Id
  clientid: Int

  # Device Unique Id
  uniqueid: String

  # Alert Type
  alerttype: String

  # Alert Value
  alertvalue: String

  # From TimeStamp
  from_ts: String

  # To TimeStamp
  to_ts: String

  # Latitude
  lat: String

  # Longitude
  lng: String

  # To Latitude
  to_lat: String

  # To Longitude
  to_lng: String

  # Trip Id
  tripid: Int

  # Alert Completed
  alert_completed: Boolean

  # Vehicle Number
  vehiclenumber: String

  # Area Id
  areaId: Int
}

#
type WPPSalesReport {
  #
  wppSales: [WPPSales]
}

#
type WPPSales {
  #
  uniqueid: String

  #
  wppId: String

  #
  date: String

  #
  ts: String

  #
  numberOfCansPerDay: Int

  #
  lat: Float

  #
  lng: Float

  #
  address: String

  #
  villageName: String

  #
  districtName: String

  #
  talukName: String

  #
  avgTdsData: Float
}

#
type DispenseSummary {
  #
  dispenseSummary: [DispensedData]
}

#
type DispensedData {
  #
  uniqueid: String

  #
  wppId: String

  #
  date: String

  #
  ts: String

  #
  lat: Float

  #
  lng: Float

  #
  numberOfCansPerDay: Int

  #
  address: String
}

#
type TdsReportData {
  #
  uniqueid: String

  #
  wppId: String

  #
  date: String

  #
  ts: String

  #
  lat: Float

  #
  lng: Float

  #
  quantityDispensed: Int

  #
  minimumTds: Float

  #
  averageTds: Float

  #
  maximumTds: Float

  #
  minimumCans: Float

  #
  averageCans: Float

  #
  maximumCans: Float

  #
  address: String

  #
  rmsInstallationDate: String

  #
  maximumCansDispensed: Int

  #
  minimumCansDispensed: Int

  #
  totalCans: Int

  #
  status: String

  #
  nonDispensingDays: Int

  #
  rmsFuntionalDates: String

  #
  rmsFunctionalCount: Int

  #
  rmsNonFunctionalDates: String

  #
  rmsNonFunctionalCount: Int
}

#
type TDSQualityReport {
  #
  uniqueid: String

  #
  wppId: String

  #
  date: String

  #
  ts: String

  #
  lat: Float

  #
  lng: Float

  #
  location: String

  #
  averageTds: Float
}

#
type DownTimeReport {
  #
  uniqueid: String

  #
  wppId: String

  #
  date: String

  #
  nonDispensingDays: Int

  #
  quantityDispensed: Int

  #
  location: String

  #
  operatorName: String

  #
  operatorContactNumber: String
}

#
type VillageData {
  #
  wppId: String

  #
  fromTime: String

  #
  toTime: String

  #
  date: String

  #
  averageTds: Float

  #
  totalCansDispensed: Int

  #
  villageName: String

  #
  totalWaterDispensed: Float

  #
  wppData: [VillageWppData]
}

#
type VillageWppData {
  #
  time: String

  #
  canCount: Int

  #
  quantity: Float

  #
  tdsValue: Float
}

#
type WppData {
  #
  wppStatistics: [talukDataParam]

  #
  dispensedSummary: WppDispenseZeroDispenseSummary

  #
  cansDispenseSummary: CansDispenseSummary

  #
  trendAndSales: TrendAndSales
}

#
type WppDispenseZeroDispenseSummary {
  #
  dispensingWPP: Int

  #
  nonDispensingWPP: Int

  #
  dispensedData: [DispenseData]
}

#
type DispenseData {
  #
  name: String

  #
  dispensingWPP: Int

  #
  nonDispensingWPP: Int

  #
  zeroDispensingWpps: [[String]]
}

#
type CansDispenseSummary {
  #
  totalCans: Int

  #
  maximumCansDispensed: Int

  #
  minimumCansDispensed: Int

  #
  averageTds: Float

  #
  canData: [CanCountData]
}

#
type CanCountData {
  #
  name: String

  #
  canCount: Int
}

#
type TrendAndSales {
  #
  totalCans: Int

  #
  maxTds: Float

  #
  minTds: Float

  #
  averageTds: Float

  #
  trendData: [TrendData]

  #
  minimumCansDispensed: Int

  #
  maximumCansDispensed: Int

  #
  avgCansDispensed: Float
}

#
type TrendData {
  #
  name: String

  #
  canCount: Int

  #
  tdsData: Float
}

#
type TripCount {
  #
  uniqueId: String

  #
  tripCount: Int

  #
  date: String
}

#
type wppPdfDownloadLink {
  #
  downloadLink: String
}

#
type ChargeHistoryResponseNew {
  #
  charge_history: [ChargeResponseNew]

  #
  vin: String!

  #
  status: Int!

  #
  statusMessage: String!
}

#
type ChargeResponseNew {
  #
  start_soc: Float!

  #
  end_soc: Float!

  #
  start_datetime: String!

  #
  end_datetime: String!

  #
  duration: Float!

  #
  energy_consumed: Float

  #
  vin: String!
}

#
type HCChargingHistoryResponse {
  #
  status: Int!

  #
  statusMessage: String!

  #
  charging_session_data: ChargingSessionData
}

#
type ChargingSessionData {
  #
  no_of_charge_sessions: Int!

  #
  total_charging_time: String!

  #
  charge_sessions: [ChargingSession]
}

#
type ChargingSession {
  # Date Format is DD/MM/YYYY hh:mm:ss In UTC
  start_date: String

  # Date Format is DD/MM/YYYY hh:mm:ss In UTC
  end_date: String

  #
  bat_a_uid: String

  #
  bat_b_uid: String

  #
  bat_a_start_soc: Float

  #
  bat_a_end_soc: Float

  #
  bat_b_start_soc: Float

  #
  bat_b_end_soc: Float

  #
  charging_time: String

  #
  total_energy_consumed: Float
}

#
type ChargeHistoryResponse {
  #
  charge_history: [ChargeResponse]

  #
  vin: String!

  #
  status: Int!

  #
  statusMessage: String!
}

#
type ChargeResponse {
  #
  start_soc: Float!

  #
  end_soc: Float!

  #
  start_datetime: String!

  #
  end_datetime: String!

  #
  energy_consumed: Float

  #
  vin: String!
}

#
type tripHistory {
  #
  trip: [historyResponse]

  #
  vin: String

  #
  status: Int

  #
  statusMessage: String
}

#
type historyResponse {
  #
  vIgnitionDisplay: [String!]

  #
  vCreatedDisplay: [String!]

  #
  vSpeed: [Float!]

  #
  vLatitude: [Float!]

  #
  vLongitude: [Float!]

  #
  vOdometer: [Float!]

  #
  vSoc: [Float!]

  #
  isNoGps: [Boolean!]

  #
  incognitoModes: [String!]
}

#
type chargeSummaryresponse {
  #
  start_soc: Float

  #
  end_soc: Float

  #
  start_datetime: String

  #
  end_datetime: String

  #
  energy_consumed: Float

  #
  vin: String

  #
  status: Int

  #
  statusMessage: String
}

#
type tripDataResponse {
  #
  tripHistory: [tripData]

  #
  vin: String!

  #
  status: Int!

  #
  statusMessage: String!
}

#
type tripData {
  #
  distance: Float

  #
  start_datetime: String!

  #
  end_datetime: String!

  #
  end_longitude: Float

  #
  start_soc: Float

  #
  end_soc: Float

  #
  end_latitude: Float

  #
  incognito_mode: String

  #
  start_pluscode: String

  #
  start_address: String

  #
  start_latitude: Float

  #
  end_pluscode: String

  #
  end_address: String

  #
  avg_speed: Float

  #
  end_odometer: Float

  #
  ev_range: Float

  #
  max_speed: Float

  #
  time_taken: Float

  #
  start_longitude: Float

  #
  energy_consumption: Float

  #
  start_odometer: Float

  #
  driving_mode: String
}

#
type tripDataResponseNew {
  #
  tripHistory: [tripDataNew]

  #
  vin: String!

  #
  status: Int!

  #
  statusMessage: String!
}

#
type tripDataNew {
  #
  start_datetime: String

  #
  end_datetime: String

  #
  start_latitude: Float

  #
  end_latitude: Float

  #
  start_longitude: Float

  #
  end_longitude: Float

  #
  start_soc: Float

  #
  end_soc: Float

  #
  incognito_mode: String

  #
  start_pluscode: String

  #
  start_address: String

  #
  end_pluscode: String

  #
  end_address: String

  #
  max_speed: Float

  #
  avg_speed: Float

  #
  start_odometer: Float

  #
  end_odometer: Float

  #
  distance: Float

  #
  ev_range: Float

  #
  co2_saved: Float

  #
  time_taken: Float

  #
  energy_consumption: Float

  #
  driving_mode_time: String

  #
  driving_mode_time_perc: String

  #
  driving_mode_distance: String

  #
  driving_mode_distance_perc: String

  #
  best_0_30_time: Float
}

#
type ChargingStationsResponse {
  #
  data: [ChargingStationsData]

  #
  status: Int!

  #
  statusMessage: String!
}

#
type ChargingStationsData {
  #
  actionId: Int

  #
  chargingStationId: Int

  #
  chargingStationName: String

  #
  stationTypeId: Int

  #
  stationType: String

  #
  chargingStationLatitude: Float

  #
  chargingStationLongitude: Float

  #
  chargingStationCountryId: Int

  #
  chargingStationStateId: Int

  #
  chargingStationCityId: Int

  #
  chargingStationAddress: String

  #
  chargingStationMobileNumber: String

  #
  chargingStationEmailId: String

  #
  chargingStationRegistrationNumber: String

  #
  chargingStationOrganizationId: Int

  #
  chargingStationCreatedBy: Int

  #
  chargingStationCreatedOn: String

  #
  chargingStationStatusID: Int

  #
  chargingStationStatusDisplayName: String

  #
  openAt: String

  #
  closeAt: String

  #
  comment: String

  #
  availableChargingPointCount: Int

  #
  distance: Float

  #
  priceId: Int

  #
  averagePrice: Float

  #
  statusName: String

  #
  reviewCount: Int

  #
  parkingStationCounts: Int

  #
  availabilityOrder: Int

  #
  CPOIId: Int

  #
  partyId: String

  #
  locationId: String

  #
  outputRating: String

  #
  chargingStationPhotoUrl: String

  #
  selected: Boolean

  #
  chargingStationProtocolType: Float

  #
  chargingStationDataCount: DataCountResponse

  #
  favouriteData: FavouriteDataResponse

  #
  connectorTypeData: [String]

  #
  connectorData: [String]
}

#
type DataCountResponse {
  #
  reviewsCount: Int

  #
  reviewPoint: Float

  #
  chargersCount: Int

  #
  chargingPriceCount: Int

  #
  usersCount: Int

  #
  supportedModelCount: Int

  #
  chargingStationId: Int

  #
  categoryId: Int

  #
  connectedToEVChargerCount: Int

  #
  connectedToEVAndChargingCount: Int

  #
  chargerPointAndPriceCount: Int

  #
  chargingPointsCount: Int

  #
  availableChargingPointCount: Int

  #
  bookedChargingPointCount: Int

  #
  liveChargingPointCount: Int

  #
  availableChargersCount: Int

  #
  unAvailableChargersCount: Int

  #
  emergencyPressChargingPointCount: Int

  #
  activeChargingPointCount: Int

  #
  notWorkingChargingPointCount: Int

  #
  inoperativeChargingPointCount: Int

  #
  notInOperationChargingPointCount: Int

  #
  notExistChargingPointCount: Int

  #
  pendingChargingPointCount: Int

  #
  totalChargingPointCount: Int

  #
  parkingPricePointCount: Int

  #
  chargerAvailableForBookingCount: Int

  #
  captiveChargerCount: Int

  #
  onlineChargerCount: Int

  #
  dtMeterCount: Int

  #
  stationCount: Int

  #
  chargerTriggerId: Int
}

#
type FavouriteDataResponse {
  #
  actionID: Int

  #
  favouriteID: Int

  #
  organizationID: Int

  #
  referenceID: Int

  #
  categoryID: Int

  #
  starCount: Float

  #
  nickName: String

  #
  statudID: Int

  #
  createdBy: Int

  #
  createdOn: String
}

#
type allGeofenceAlertsResponse {
  #
  GeofenceAlerts: [geofenceAlertsResp]

  #
  status: Int!

  #
  statusMessage: String!
}

#
type geofenceAlertsResp {
  #
  alerttype: String

  #
  from_ts: String

  #
  to_ts: String

  #
  from_lat: Float

  #
  from_lng: Float

  #
  to_lat: Float

  #
  to_lng: Float

  #
  breached_In_userId: String

  #
  breached_out_userId: String

  #
  alerted_to_in_userid: String

  #
  alerted_to_out_userid: String

  #
  vin: String

  #
  geofenceId: Int

  #
  from_address: String

  #
  to_address: String
}

#
type fetchDataReponse {
  #
  response: [fetchDataRespData]

  #
  status: Int!

  #
  statusMessage: String!
}

#
type fetchDataRespData {
  #
  vin: String

  #
  user_id: String

  #
  imei: String

  #
  event_flag: Int

  #
  seq_num: Int

  #
  device_time: String

  #
  kafka_enqueued_time: String

  #
  local_device_time: String

  #
  db_insert_time: String

  #
  original_event_flag: Int

  #
  packet_type: Int

  #
  packet_event_code: String

  #
  gps_fix: Int

  #
  gps_validity: String

  #
  latitude: Float

  #
  longitude: Float

  #
  altitude: Float

  #
  direction: Float

  #
  satellite_in_view: Int

  #
  satellite_in_use: Int

  #
  rssi: Int

  #
  network_operator_name: String

  #
  iccid: String

  #
  area_zip_code: String

  #
  tcu_bat_volt: Float

  #
  timezone_name: String

  #
  timezone_offset: String

  #
  ignition_status: Int

  #
  pluscode: String

  #
  odometer: Float

  #
  incognito_mode: String

  #
  charging_status: String

  #
  vehicle_mode: String

  #
  vehicle_state: String

  #
  speed: Float

  #
  soc: Int

  #
  regen_status: String

  #
  dte_eco: Int

  #
  dte_ride: Int

  #
  dte_power: Int

  #
  time_to_charge: Int

  #
  co2_saved: Float

  #
  sel_regen_selection: String

  #
  sw_package_version: String

  #
  bat_a_voltage: Float

  #
  bat_a_soc: Float

  #
  bat_a_warning_code: Int

  #
  bat_a_current: Float

  #
  bat_a_mode: Int

  #
  bat_a_max_discharge_current: Float

  #
  bat_a_i2t_limit: Float

  #
  bat_a_soh: Int

  #
  bat_a_soe: Float

  #
  bat_a_max_temp: Float

  #
  bat_a_min_temp: Float

  #
  bat_a_max_charge_current: Float

  #
  bat_a_cell1_volt: Float

  #
  bat_a_cell2_volt: Float

  #
  bat_a_cell3_volt: Float

  #
  bat_a_cell4_volt: Float

  #
  bat_a_cell5_volt: Float

  #
  bat_a_cell6_volt: Float

  #
  bat_a_cell7_volt: Float

  #
  bat_a_cell8_volt: Float

  #
  bat_a_cell9_volt: Float

  #
  bat_a_cell10_volt: Float

  #
  bat_a_cell11_volt: Float

  #
  bat_a_cell12_volt: Float

  #
  bat_a_cell13_volt: Float

  #
  bat_a_cell14_volt: Float

  #
  bat_a_fc_detect: Float

  #
  bat_a_max_cell_voltage: Float

  #
  bat_a_mosfet_temperature: Int

  #
  bat_a_pcb_temperature: Int

  #
  bat_a_pack_positive_term_temp: Int

  #
  bat_a_pack_negative_term_temp: Int

  #
  bat_a_load_positive_term_temp: Int

  #
  bat_a_error_byte_num_in_rest: Int

  #
  bat_a_corresponding_error_byte: Int

  #
  bat_a_error_byte_0: Int

  #
  bat_a_error_byte_1: Int

  #
  bat_a_error_byte_2: Int

  #
  bat_a_error_byte_3: Int

  #
  bat_a_error_byte_4: Int

  #
  bat_a_error_byte_5: Int

  #
  bat_a_error_byte_6: Int

  #
  bat_a_error_byte_7: Int

  #
  bat_a_full_charge_flag: Int

  #
  bat_b_voltage: Float

  #
  bat_b_soc: Float

  #
  bat_b_warning_code: Int

  #
  bat_b_current: Float

  #
  bat_b_mode: Int

  #
  bat_b_max_discharge_current: Float

  #
  bat_b_i2t_limit: Float

  #
  bat_b_soh: Int

  #
  bat_b_soe: Float

  #
  bat_b_max_temp: Float

  #
  bat_b_min_temp: Float

  #
  bat_b_max_charge_current: Float

  #
  bat_b_cell1_volt: Float

  #
  bat_b_cell2_volt: Float

  #
  bat_b_cell3_volt: Float

  #
  bat_b_cell4_volt: Float

  #
  bat_b_cell5_volt: Float

  #
  bat_b_cell6_volt: Float

  #
  bat_b_cell7_volt: Float

  #
  bat_b_cell8_volt: Float

  #
  bat_b_cell9_volt: Float

  #
  bat_b_cell10_volt: Float

  #
  bat_b_cell11_volt: Float

  #
  bat_b_cell12_volt: Float

  #
  bat_b_cell13_volt: Float

  #
  bat_b_cell14_volt: Float

  #
  bat_b_fc_detect: Float

  #
  bat_b_max_cell_voltage: Float

  #
  bat_b_mosfet_temperature: Int

  #
  bat_b_pcb_temperature: Int

  #
  bat_b_pack_positive_term_temp: Int

  #
  bat_b_pack_negative_term_temp: Int

  #
  bat_b_load_positive_term_temp: Int

  #
  bat_b_error_byte_num_in_rest: Int

  #
  bat_b_corresponding_error_byte: Int

  #
  bat_b_error_byte_0: Int

  #
  bat_b_error_byte_1: Int

  #
  bat_b_error_byte_2: Int

  #
  bat_b_error_byte_3: Int

  #
  bat_b_error_byte_4: Int

  #
  bat_b_error_byte_5: Int

  #
  bat_b_error_byte_6: Int

  #
  bat_b_error_byte_7: Int

  #
  bat_b_full_charge_flag: Int

  #
  payload_type: String

  #
  can_modified: String

  #
  change_version: Float

  #
  acc_x: Int

  #
  acc_y: Int

  #
  acc_z: Int

  #
  bms_maxchargecurrent: Float

  #
  bms_maxchargevoltage: Float

  #
  bms_cutoffchargecurrent: Float

  #
  bms_prechargecurrent: Float

  #
  bms_current: Int

  #
  bms_voltage: Int

  #
  bms_counter: Int

  #
  bms_soc: Int

  #
  bms_a_sw_version: String

  #
  main_voltage: Float

  #
  variant: String

  #
  tps: Int

  #
  accn_detect: Int

  #
  actively_charging_batteries: Int

  #
  actively_discharging_batteries: Int

  #
  bms_b_sw_version: String

  #
  bms_error_state: Int

  #
  bms_temperature: Int

  #
  can_distance: Float

  #
  cep_value: Float

  #
  charger_current: Float

  #
  charger_error_status: Int

  #
  charger_fan_status: Int

  #
  charger_input_voltage: Int

  #
  charger_output_status: Int

  #
  charger_temperature: Int

  #
  charger_terminal_voltage: Float

  #
  charger_type: Int

  #
  charging_mode: Int

  #
  distance_eco_mode: Int

  #
  distance_power_mode: Int

  #
  dtc_cluster_not_responding: Int

  #
  dtc_tcu_not_responding: Int

  #
  dtc_vehicle_on_charge: Int

  #
  ecu_temp: Int

  #
  energy_consumed_by_powertrain: Float

  #
  energy_consumption_eco_mode: Float

  #
  energy_consumption_pow_mode: Float

  #
  fix_type: String

  #
  gprs_connection_status: Int

  #
  gps_distance: Float

  #
  gradient_detect: Int

  #
  indicated_dte: Int

  #
  input_dc_current: Float

  #
  limphome_actively_discharging_batteries: Int

  #
  low_tyre_pressure_status: Int

  #
  mcu_dc_bus_discharge_maxlimit: Int

  #
  mcu_dc_bus_regen_maxlimit: Int

  #
  mcu_enable_t15_voltage: Float

  #
  mcu_irms_maxlimit: Int

  #
  mcudc_battery_voltage: Float

  #
  mil: Int

  #
  motor_temperature: Int

  #
  motor_torque_output: Int

  #
  network_band: String

  #
  no_of_communicating_batteries: Int

  #
  odometer_gps: Float

  #
  output_phase_current: Float

  #
  pitch_angle: Int

  #
  precharge_fault: Int

  #
  precharge_status_ack_fault: Int

  #
  regeneration_status: Int

  #
  roll_angle: Int

  #
  service_reset: Int

  #
  side_stand_status: Int

  #
  speed_data: Float

  #
  speed_gps: Float

  #
  speed_mode_status: Int

  #
  speed_rpm_data: Float

  #
  subsystem_fault_bits: Int

  #
  subsystem_protect_derating: Int

  #
  subsystem_sensor_tps_bits: Int

  #
  subsystem_status_bits: Int

  #
  subsystem_switchstatus_bits: Int

  #
  subsystem_protect_status_bits: Int

  #
  supply_fault_5v: Int

  #
  supply_voltage_5v: Int

  #
  tcp_connection_status: Int

  #
  tcu_avg_rssi: Int

  #
  tcu_batt_per: Int

  #
  tcu_fw_ver: String

  #
  tcu_inst_rssi: Int

  #
  tcu_no_of_can_packets_in_buffer: Int

  #
  tcu_no_of_can_packets_lost: Int

  #
  tcu_no_of_change_in_cell_id: Int

  #
  tcu_no_of_loc_packets_in_buffer: Int

  #
  tcu_no_of_loc_packets_lost: Int

  #
  tcu_no_of_unsucess_attempts_gprs: Int

  #
  tcu_no_of_unsucess_attempts_tcp: Int

  #
  tcu_packet_buffer_fill_level: Int

  #
  tft_cluster_sw_version: String

  #
  throttle_percentage: Int

  #
  torque_ref_from_throttledemand: Int

  #
  total_remaining_charging_time_min: Int

  #
  tps_voltage: Float

  #
  vcu_sw_version: String

  #
  bat_a_uid: String

  #
  bat_b_uid: String

  #
  charger_mode: Int

  #
  slot1_charging_status: Int

  #
  slot2_charging_status: Int

  #
  home_charger_state: Int

  #
  home_charger_dock_id: String

  #
  charger_firmware_version: String
}

#
type getCommandListResponse {
  #
  commandDetails: [commandresponse]

  #
  status: Int

  #
  statusMessage: String
}

#
type commandresponse {
  #
  id: Int

  #
  vin: String

  #
  command_display: String

  #
  status: String

  #
  create_at: String

  #
  modified_at: String

  #
  response: String
}

#
type commandStatus {
  #
  id: Int

  #
  uniqueid: String

  #
  command_display: String

  #
  status: String

  #
  create_ts: String

  #
  modified_ts: String

  #
  response: String
}

#
type getHomeChargerSettingsResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  settings: [SettingsResponse]
}

#
type SettingsResponse {
  #
  APN: apnResponce

  #
  HBFREQ: hbfResponce

  #
  ACAL: acalResponce

  #
  HOMEDOCKID: homeDockResponse

  #
  STOPCH: stopChResponse

  #
  SPEEDCH: speedChResponse

  #
  BATUID: batUidResponse

  #
  STOPCHLIMIT: stopChLimitResponse
}

#
type apnResponce {
  #
  apn: String
}

#
type hbfResponce {
  #
  duration: Int
}

#
type acalResponce {
  #
  accX: Int

  #
  accY: Int

  #
  accZ: Int

  #
  tiltAngle: Int
}

#
type homeDockResponse {
  #
  id: String
}

#
type stopChResponse {
  #
  on: stopChEnum
}

#
enum stopChEnum {
  #
  ON
}

#
type speedChResponse {
  #
  limit: speedChEnum
}

#
enum speedChEnum {
  #
  HIGH

  #
  NORMAL
}

#
type batUidResponse {
  #
  id: String
}

#
type stopChLimitResponse {
  #
  alertsEnabled: Boolean

  #
  socLimit: Int

  #
  whatsAppNotificationEnabled: Boolean

  #
  emailNotificationEnabled: Boolean

  #
  smsNotificationEnabled: Boolean
}

#
enum hcCommandsEnum {
  #
  STOPCH

  #
  STOPCHLIMIT

  #
  SPEEDCH

  #
  APN

  #
  HBFREQ

  #
  ACAL

  #
  HOMEDOCKID

  #
  BATUID
}

#
type getHomeChargerCommandStatusResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  command: [commandResponse]
}

#
type commandResponse {
  #
  cmdValue: String

  #
  cmdName: String

  #
  updateTimestamp: String

  #
  createTimestamp: String

  #
  cmdStatus: String!
}

#
type getVehicleCommandResponse {
  #
  status: Int!

  #
  statusMessage: String

  #
  settings: [settingsRes]
}

#
type settingsRes {
  #
  OVERST: overspeedRes

  #
  APN: apnRes

  #
  HBFREQ: hbfRes

  #
  ACAL: acalRes

  #
  RASHT: accRes

  #
  HBT: accRes

  #
  HAT: accRes

  #
  TRIPOFD: trpofdRes

  #
  TLBATT: tlbattRes

  #
  IMMOB: immobRes

  #
  CRASH: crashRes

  #
  FALL: fallRes

  #
  THEFT: theftRes
}

#
type overspeedRes {
  #
  alertsEnabled: Boolean

  #
  speedLimit: Int

  #
  duration: Int

  #
  overstWhatsAppNotificationEnabled: Boolean

  #
  overstEmailNotificationEnabled: Boolean

  #
  overstSmsNotificationEnabled: Boolean
}

#
type apnRes {
  #
  apn: String
}

#
type hbfRes {
  #
  duration: Int
}

#
type acalRes {
  #
  accX: Int

  #
  accY: Int

  #
  accZ: Int

  #
  tiltAngle: Int
}

#
type accRes {
  #
  accX: Int

  #
  accY: Int

  #
  accZ: Int
}

#
type trpofdRes {
  #
  duration: Int
}

#
type tlbattRes {
  #
  percentage: Int
}

#
type immobRes {
  #
  immob: Int
}

#
type crashRes {
  #
  speed: Int

  #
  tiltAngle: Int

  #
  crashWhatsAppNotificationEnabled: Boolean

  #
  crashEmailNotificationEnabled: Boolean

  #
  crashSmsNotificationEnabled: Boolean
}

#
type fallRes {
  #
  tiltAngle: Int

  #
  fallWhatsAppNotificationEnabled: Boolean

  #
  fallEmailNotificationEnabled: Boolean

  #
  fallSmsNotificationEnabled: Boolean
}

#
type theftRes {
  #
  thresholdDistance: Int

  #
  pdop: Int

  #
  satelliteNo: Int

  #
  theftWhatsAppNotificationEnabled: Boolean

  #
  theftEmailNotificationEnabled: Boolean

  #
  theftSmsNotificationEnabled: Boolean
}

#
enum vehicleCommandsEnum {
  #
  OVERST

  #
  CRASH

  #
  FALL

  #
  THEFT
}

#
type getVehicleCommandStatusResponse {
  #
  status: Int!

  #
  statusMessage: String!

  #
  command: [commandRes]
}

#
type commandRes {
  #
  cmdName: String!

  #
  cmdValue: String!

  #
  createTimestamp: String!

  #
  updateTimestamp: String!

  #
  cmdStatus: String!
}

#
type Activity {
  #
  clientLoginId: Int!

  #
  uniqueId: String!

  #
  vehicleNumber: String!

  #
  fromTs: String!

  #
  toTs: String!

  #
  activity_completed: Boolean!

  #
  startLoc: String

  #
  endLoc: String

  #
  startAddress: String

  #
  endAddress: String

  #
  totalDist: Float

  #
  totalRunningTime: Float

  #
  totalHaltTime: Float

  #
  totalHaCount: Int

  #
  totalHbCount: Int

  #
  totalIdlingTime: Float

  #
  totalScore: Float
}

#
type CustomActivityObject {
  # Vehicle number added in the client login
  vehicleNumber: String!

  # Unix Start timestamp in GMT (+0) of the activity
  fromTs: String!

  # Unix End timestamp in GMT (+0) of the activity
  toTs: String!

  # Start Location in <Lat,Long> format
  startLoc: String

  # End Location in <Lat,Long> format
  endLoc: String

  # Start Location in readable format
  startAddress: String

  # End Location in readable format
  endAddress: String

  # Total Distance travelled by the vehicle during the activity
  totalDist: Float

  # Total Running time in seconds of the vehicle during the activity
  totalRunningTime: Float

  # Total Halt time in seconds of the vehicle during the activity
  totalHaltTime: Float

  # Total Harsh Accelerations done by the vehicle during the activity
  totalHaCount: Int

  # Total Harsh Brakings done by the vehicle during the activity
  totalHbCount: Int

  # Total Idling time in seconds of the vehicle during the activity
  totalIdlingTime: Float

  # Total Score in % of the activity
  totalScore: Float

  # Total Green Miles travelled by the driver in KM
  totalGreenMiles: Float

  #
  averageSpeed: Float

  #
  topSpeed: Float

  #
  overspeedCount: Int
}

#
enum period {
  #
  DAY

  #
  WEEK

  #
  MONTH
}

#
type Score {
  #
  totalScore: Float
}

#
type Details_Score {
  #
  vehicleNumber: String

  #
  Score: Float

  #
  UniqueId: String
}

#
type Log9Data {
  #
  totalDistance: Float
}

#
type TotalWeeklyActivity {
  #
  from: String

  #
  to: String

  #
  totalActivity: [WeeklyActivity]
}

#
type WeeklyActivity {
  #
  dayOfWeek: String

  #
  noOfTrips: Int
}

#
type VehicleDriven {
  #
  vehicleNumber: String

  #
  trips: Int

  #
  score: Float
}

#
type allData {
  #
  status: String

  #
  pids: [String]

  #
  description: [String]
}

#
type allData2 {
  #
  status: String
}

#
type tripScoreResponse {
  #
  scoreData: tripDataScore

  #
  vin: String!

  #
  status: Int!

  #
  statusMessage: String!
}

#
type tripDataScore {
  #
  tripScore: Float

  #
  haScore: Float

  #
  haWeight: Float

  #
  hbScore: Float

  #
  hbWeight: Float

  #
  overspeedScore: Float

  #
  overspeedWeight: Float

  #
  brakeOnDrivingScore: Float

  #
  brakeOnDrivingWeight: Float

  #
  timeDurationEcoPower: Float

  #
  timeDurationEcoPowerWeight: Float

  #
  tripEndSoc: Float

  #
  tripEndSocWeight: Float
}

#
type driverScoreResponse {
  #
  scoreData: driverDataScore

  #
  vin: String!

  #
  status: Int!

  #
  statusMessage: String!
}

#
type driverDataScore {
  #
  driverScore: Float

  #
  tripScore: Float

  #
  dayScore: Float

  #
  chargeScore: Float
}

#
type chargeScoreResponse {
  #
  scoreData: chargeDataScore

  #
  vin: String!

  #
  status: Int!

  #
  statusMessage: String!
}

#
type chargeDataScore {
  #
  chargeScore: Float

  #
  chargeWeight: Float
}

#
type dayScoreResponse {
  #
  scoreData: dayDataScore

  #
  vin: String!

  #
  status: Int!

  #
  statusMessage: String!
}

#
type dayDataScore {
  #
  dayScore: Float

  #
  dayWeight: Float
}

#
input route_Array {
  #
  route_id: Int!

  #
  route: String!

  #
  distance: Float!
}

#
type ChargingStationsAlongRouteResponse {
  #
  status: Int!

  #
  statusMessage: String!

  #
  cs_along_route_details: [cs_detailsInput]!
}

#
type cs_detailsInput {
  #
  route_id: Int!

  #
  cs_details: [ChargingStation!]!
}

#
type ChargingStation {
  #
  charging_station_latitude_longitude: [Float!]!

  #
  charging_station_name: String!

  #
  deviation_from_route: Float!

  #
  within_dte_range_flag: [Boolean!]!
}

#
type getChargeStationsResponse {
  #
  response: [responeDataChargeStation]

  #
  status: Int

  #
  statusMessage: String
}

#
type responeDataChargeStation {
  #
  device_id: String

  #
  model: String

  #
  name: String

  #
  rate: Float

  #
  timings: String

  #
  sockets: [String]

  #
  host_details: hostDetailsObj

  #
  private: Boolean

  #
  isTwentyFourSeven: Boolean

  #
  superHostUID: String

  #
  vehicleNo: String

  #
  segment: String

  #
  subsegment: String

  #
  installation_date: String

  #
  image: [String]

  #
  output_type: String

  #
  total_capacity: Float

  #
  coordinates: [Float]

  #
  distance: Float

  #
  address: [addressListObj]

  #
  location: [Float]

  #
  vehicle_types: [String]

  #
  parking: [String]

  #
  geo_state: String
}

#
type hostDetailsObj {
  #
  host_id: String

  #
  name: String

  #
  phone: String
}

#
type addressListObj {
  #
  long_name: String

  #
  short_name: String

  #
  types: [String]
}

#
type getTransactionsResponse {
  #
  response: [responeDataLatestTransactions]

  #
  status: Int

  #
  statusMessage: String
}

#
type responeDataLatestTransactions {
  #
  txn_id: String

  #
  connector_id: Int

  #
  duration: Int

  #
  device_id: String

  #
  device_org: String

  #
  initiated_from: String

  #
  segment: String

  #
  set_duration: Int

  #
  subsegment: String

  #
  user_id: String

  #
  device_network_type: String

  #
  end_time: Int

  #
  power: Float

  #
  start_time: Int

  #
  total_usage: Float

  #
  tx_status: Int

  #
  txn_type: String

  #
  usage_limit: Float

  #
  vehicle_no: String

  #
  voltage: Float

  #
  payment_id: String

  #
  payment_status: Int

  #
  end_reason: String

  #
  payment_initialised: Boolean
}

#
type getLatestTransactionsResponse {
  #
  response: responeDataLatestTransactions

  #
  status: Int

  #
  statusMessage: String
}

#
type getTransactionDetailsResponse {
  #
  response: responeDataLatestTransactions

  #
  status: Int

  #
  statusMessage: String
}

#
type getDeviceStateResponse {
  #
  response: [responeDataDeviceState]

  #
  status: Int

  #
  statusMessage: String
}

#
type responeDataDeviceState {
  #
  device_id: String

  #
  org: String

  #
  geo_state: String

  #
  network: Boolean

  #
  vendor: String

  #
  protocol: String

  #
  device_group: String

  #
  host_id: String

  #
  timestamp: Int

  #
  boot: String

  #
  firmware_version: String

  #
  imsi: String

  #
  model: String

  #
  cp_error: String

  #
  cp_state: Int

  #
  num_connectors: Int

  #
  tariff: String

  #
  zone: String

  #
  charge_state: [Int]

  #
  config: config

  #
  location: [Float]

  #
  imei: String

  #
  network_info: network_info

  #
  network_type: Int

  #
  rssi: Int

  #
  voltage: Float

  #
  error_code: [String]

  #
  rate: Int

  #
  theft_state: Int
}

#
type config {
  #
  p_thresh: Int

  #
  v_thresh: Int

  #
  em_stat: Int

  #
  plugd_set: Int

  #
  plugd_t: Int

  #
  tamp_set: Boolean

  #
  resume_set: Boolean

  #
  contact: String

  #
  e_r: Int
}

#
type network_info {
  #
  op: String

  #
  imsi: String
}

#
type enableDeviceResponse {
  #
  response: String

  #
  status: Int

  #
  statusMessage: String
}

#
type disableDeviceResponse {
  #
  response: String

  #
  status: Int

  #
  statusMessage: String
}

#
type getTariffDetailsResponse {
  #
  response: responeDataTariffDetails

  #
  status: Int

  #
  statusMessage: String
}

#
type responeDataTariffDetails {
  #
  _id: String

  #
  name: String

  #
  org: String

  #
  tariff_id: String

  #
  rate: [rate]
}

#
type rate {
  #
  type: String

  #
  charge: Int

  #
  unit: String
}

#
enum unitsEnum {
  #
  imperial

  #
  metric

  #
  standard
}

#
enum enumLang {
  #
  af

  #
  al

  #
  ar

  #
  az

  #
  bg

  #
  ca

  #
  cz

  #
  da

  #
  de

  #
  el

  #
  en

  #
  eu

  #
  fa

  #
  fi

  #
  fr

  #
  gl

  #
  he

  #
  hi

  #
  hr

  #
  hu

  #
  id

  #
  it

  #
  ja

  #
  kr

  #
  la

  #
  lt

  #
  mk

  #
  no

  #
  nl

  #
  pl

  #
  pt

  #
  pt_br

  #
  ro

  #
  ru

  #
  sv

  #
  se

  #
  sk

  #
  sl

  #
  sp

  #
  es

  #
  sr

  #
  th

  #
  tr

  #
  ua

  #
  vi

  #
  zh_cn

  #
  zh_tw

  #
  zu
}

#
type currentWeatherDataResponse {
  #
  response: responseObj

  #
  status: String

  #
  statusMessage: String
}

#
type responseObj {
  #
  coord: latlon

  #
  weather: [weatherArr]

  #
  base: String

  #
  main: mainResponse

  #
  visibility: Int

  #
  wind: speedDegresponse

  #
  rain: rainObj

  #
  snow: snowObj

  #
  clouds: allClouds

  #
  dt: Int

  #
  sys: sycObj

  #
  timezone: Int

  #
  id: Int

  #
  name: String
}

#
type latlon {
  #
  lon: Float

  #
  lat: Float
}

#
type weatherArr {
  #
  id: Int

  #
  main: String

  #
  description: String

  #
  icon: String

  #
  iconPath: String
}

#
type mainResponse {
  #
  temp: Float

  #
  feels_like: Float

  #
  temp_min: Float

  #
  temp_max: Float

  #
  pressure: Float

  #
  humidity: Float

  #
  sea_level: Float

  #
  grnd_level: Float
}

#
type speedDegresponse {
  #
  speed: Float

  #
  deg: Int

  #
  gust: Float
}

#
type rainObj {
  #
  rain_1h: Float

  #
  rain_3h: Float
}

#
type snowObj {
  #
  snow_1h: Float

  #
  snow_3h: Float
}

#
type allClouds {
  #
  all: Int
}

#
type sycObj {
  #
  type: Int

  #
  id: Int

  #
  message: String

  #
  country: String

  #
  sunrise: Int

  #
  sunset: Int
}

#
type HourlyForecastDataResponse {
  #
  response: hourlyresponse

  #
  status: String

  #
  statusMessage: String
}

#
type hourlyresponse {
  #
  cnt: Int

  #
  list: [listArr]

  #
  city: cityObj

  #
  location: locationObj

  #
  credit: String

  #
  meta: metaObj

  #
  sun: sunObj
}

#
type listArr {
  #
  dt: Int

  #
  main: mainObj

  #
  weather: [weatherArr]

  #
  clouds: allClouds

  #
  wind: windResponse

  #
  visibility: Int

  #
  pop: Float

  #
  rain: rainObjHourly

  #
  snow: snowObjHour

  #
  sys: sysResponse

  #
  dt_txt: String
}

#
type mainObj {
  #
  temp: Float

  #
  feels_like: Float

  #
  temp_min: Float

  #
  temp_max: Float

  #
  pressure: Float

  #
  sea_level: Int

  #
  grnd_level: Int

  #
  humidity: Float

  #
  temp_kf: Float
}

#
type windResponse {
  #
  speed: Float

  #
  deg: Int

  #
  gust: Float
}

#
type rainObjHourly {
  #
  rain_1h: Float
}

#
type snowObjHour {
  #
  snow_1h: Float
}

#
type sysResponse {
  #
  pod: String
}

#
type cityObj {
  #
  id: String

  #
  name: String

  #
  coord: citycoord

  #
  country: String

  #
  timezone: String

  #
  sunrise: String

  #
  sunset: String

  #
  population: Float
}

#
type citycoord {
  #
  lat: Float

  #
  lon: Float
}

#
type locationObj {
  #
  name: String

  #
  type: String

  #
  country: String

  #
  timezone: String

  #
  location: locationObjj
}

#
type locationObjj {
  #
  altitude: Float

  #
  latitude: Float

  #
  longitude: Float

  #
  geobase: Float

  #
  geobaseid: String
}

#
type metaObj {
  #
  lastupdate: String

  #
  calctime: String

  #
  nextupdate: String
}

#
type sunObj {
  #
  rise: String

  #
  set: String
}

#
enum statusEnum {
  #
  completed

  #
  upcoming

  #
  live
}

#
type getCrricketMatchResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  response: responseRes

  #
  etag: String

  #
  modified: String

  #
  datetime: String

  #
  api_version: Float
}

#
type responseRes {
  #
  items: [responseDetails]

  #
  total_items: Int

  #
  total_pages: Int
}

#
type responseDetails {
  #
  match_id: Int

  #
  title: String

  #
  short_title: String

  #
  subtitle: String

  #
  match_number: String

  #
  format: Int

  #
  format_str: String

  #
  status: String

  #
  status_str: String

  #
  status_note: String

  #
  verified: String

  #
  pre_squad: String

  #
  odds_available: String

  #
  game_state: Int

  #
  game_state_str: String

  #
  domestic: String

  #
  competition: competitionResponse

  #
  teama: teamaResponse

  #
  teamb: teambResponse

  #
  date_start: String

  #
  date_end: String

  #
  timestamp_start: Int

  #
  timestamp_end: Int

  #
  date_start_ist: String

  #
  date_end_ist: String

  #
  venue: venueResponse

  #
  umpires: String

  #
  referee: String

  #
  equation: String

  #
  live: String

  #
  result: String

  #
  result_type: Int

  #
  win_margin: String

  #
  winning_team_id: Int

  #
  commentary: Int

  #
  wagon: Int

  #
  latest_inning_number: Int

  #
  presquad_time: String

  #
  verify_time: String

  #
  match_dls_affected: String

  #
  toss: tossResponse
}

#
type competitionResponse {
  #
  cid: Int

  #
  title: String

  #
  abbr: String

  #
  type: String

  #
  category: String

  #
  match_format: String

  #
  season: String

  #
  status: String

  #
  datestart: String

  #
  dateend: String

  #
  country: String

  #
  total_matches: Int

  #
  total_rounds: Int

  #
  total_teams: Int
}

#
type teamaResponse {
  #
  team_id: Int

  #
  name: String

  #
  short_name: String

  #
  logo_url: String

  #
  scores_full: String

  #
  scores: String

  #
  overs: String
}

#
type teambResponse {
  #
  team_id: Int

  #
  name: String

  #
  short_name: String

  #
  logo_url: String

  #
  scores_full: String

  #
  scores: String

  #
  overs: String
}

#
type venueResponse {
  #
  venue_id: Int

  #
  name: String

  #
  location: String

  #
  country: String

  #
  timezone: String
}

#
type tossResponse {
  #
  text: String

  #
  winner: Int

  #
  decision: Int
}

#
enum footballStatusEnum {
  #
  result

  #
  upcoming

  #
  live
}

#
type getFootballMatchListResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  response: footballRes

  #
  etag: String

  #
  modified: String

  #
  datetime: String

  #
  api_version: Float
}

#
type footballRes {
  #
  items: [footballResponseDetails]

  #
  total_items: Int

  #
  total_pages: Int
}

#
type footballResponseDetails {
  #
  mid: String

  #
  round: String

  #
  match_number: String

  #
  result: Result

  #
  teams: Team

  #
  periods: periodResponse

  #
  datestart: String

  #
  dateend: String

  #
  timestampstart: String

  #
  timestampend: String

  #
  injurytime: String

  #
  time: String

  #
  status_str: String

  #
  status: String

  #
  gamestate_str: String

  #
  gamestate: String

  #
  pre_squad: String

  #
  verified: String

  #
  periodlength: String

  #
  numberofperiods: String

  #
  attendance: String

  #
  overtimelength: String

  #
  competition: competitionRes

  #
  venue: venueRes

  #
  lineupavailable: String

  #
  projectionavailable: String

  #
  eventavailable: String

  #
  commentaryavailable: String
}

#
type Result {
  #
  home: String

  #
  away: String

  #
  winner: String
}

#
type Team {
  #
  home: TeamResponse

  #
  away: TeamResponse
}

#
type TeamResponse {
  #
  tid: String

  #
  tname: String

  #
  logo: String

  #
  fullname: String

  #
  abbr: String
}

#
type periodResponse {
  #
  p1: periodInfo

  #
  p2: periodInfo

  #
  ft: periodInfo
}

#
type periodInfo {
  #
  home: Int

  #
  away: Int
}

#
type competitionRes {
  #
  cid: String

  #
  cname: String

  #
  startdate: String

  #
  enddate: String

  #
  startdatetimestamp: String

  #
  endtdatetimestamp: String

  #
  year: String

  #
  category: String

  #
  tournament_id: String

  #
  category_id: String

  #
  ioc: String

  #
  status: String

  #
  status_str: String

  #
  logo: String
}

#
type venueRes {
  #
  venueid: String

  #
  name: String

  #
  location: String

  #
  founded: String

  #
  capacity: String

  #
  googlecoords: String
}

#
type startTransactionResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  response: String
}

#
type stopTransactionResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  response: String
}

#
type configDeviceResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  response: String
}

#
type configDeviceThresoldResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  response: String
}

#
type CurrentAirPollutionDataResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  response: airPollutionData
}

#
type airPollutionData {
  #
  coord: Coord

  #
  list: [ListItem]
}

#
type Coord {
  #
  lat: Float

  #
  lon: Float
}

#
type ListItem {
  #
  dt: Int

  #
  airQuality: String

  #
  main: Main

  #
  components: Components
}

#
type Main {
  #
  aqi: Int
}

#
type Components {
  #
  co: Float

  #
  no: Float

  #
  no2: Float

  #
  o3: Float

  #
  so2: Float

  #
  pm2_5: Float

  #
  pm10: Float

  #
  nh3: Float
}

#
type getDailyWeatherForecastDataResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  response: dailyForecastData
}

#
type dailyForecastData {
  #
  city: cityObjDaily

  #
  cod: String

  #
  cnt: Int

  #
  list: [listArryDaily]
}

#
type cityObjDaily {
  #
  id: String

  #
  name: String

  #
  coord: citycoord

  #
  country: String

  #
  timezone: String

  #
  population: Float
}

#
type listArryDaily {
  #
  dt: Int

  #
  sunrise: Int

  #
  sunset: Int

  #
  temp: dailyTempObj

  #
  feels_like: dailyfeels_like

  #
  pressure: Float

  #
  humidity: Float

  #
  weather: [weatherArrDaily]

  #
  speed: Float

  #
  deg: Int

  #
  gust: Float

  #
  clouds: Int

  #
  pop: Float

  #
  rain: Float
}

#
type dailyTempObj {
  #
  day: Float

  #
  min: Float

  #
  max: Float

  #
  night: Float

  #
  eve: Float

  #
  morn: Float
}

#
type dailyfeels_like {
  #
  day: Float

  #
  night: Float

  #
  eve: Float

  #
  morn: Float
}

#
type weatherArrDaily {
  #
  id: Int

  #
  main: String

  #
  description: String

  #
  icon: String

  #
  iconPath: String
}

#
type AllSharedLocationsResponse {
  #
  destinationDetails: [destinationDetails]

  #
  status: Int

  #
  statusMessage: String
}

#
type destinationDetails {
  #
  location_name: String

  #
  location_id: Int!

  #
  fromUserId: String!

  #
  toUserId: String

  #
  user_generated_name: String

  #
  vin: String!

  #
  lat_long: lat_longResponse!

  #
  placeId: String

  #
  is_shared: Boolean

  #
  is_recent: Boolean

  #
  is_favorite: Boolean

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  address: String!

  #
  shared_time: String

  #
  shared_timestamp: String

  #
  created_timestamp: String

  #
  updated_timestamp: String

  #
  is_shared_today: Boolean

  #
  sequence_number: String
}

#
type lat_longResponse {
  #
  lat: Float

  #
  long: Float
}

#
type allLocationResponse {
  #
  response: [allResponseOfLocation]

  #
  status: Int

  #
  statusMessage: String
}

#
type allResponseOfLocation {
  #
  location_id: Int!

  #
  location_name: String

  #
  user_generated_name: String

  #
  fromUserId: String!

  #
  vin: String!

  #
  lat_long: latLongResponse!

  #
  placeId: String!

  #
  is_shared: Boolean

  #
  is_recent: Boolean

  #
  is_favorite: Boolean

  #
  createdAt: String!

  #
  updatedAt: String!

  #
  status: Int!

  #
  address: String!

  #
  created_timestamp: String

  #
  updated_timestamp: String

  #
  location_type: String
}

#
type latLongResponse {
  #
  lat: Float

  #
  long: Float
}

#
type TravelHistoryNew {
  #
  distanceTravelledKms: Float

  #
  points: [TravelReplayPacketNew!]
}

#
type TravelReplayPacketNew {
  #
  ts: String

  #
  lat: Float!

  #
  lng: Float!

  #
  speed: Float

  #
  isHA: Boolean

  #
  isHB: Boolean

  #
  satellites: Int

  # Key used to fetch a string address
  pluscode: String

  # reverse geo-coded address string from google
  address: String
}

#
type RawLocationDataNew {
  #
  timestamp: String

  #
  latitude: Float

  #
  longitude: Float

  #
  gpsStatus: String

  #
  isHA: Boolean

  #
  isHB: Boolean

  #
  satellites: Int

  #
  isNoGps: Boolean

  #
  speed: Float

  #
  extBatVol: Float

  #
  direction: Int

  #
  address: String
}

#
type getApiStatResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  api_details: [api_detailsResponse]
}

#
type api_detailsResponse {
  #
  vin: String

  #
  app_userid: String

  #
  api_name: String

  #
  query: String

  #
  api_variables: String

  #
  response_data: String

  #
  status: Int

  #
  response_time: Int

  #
  timestamp: String
}

#
type fetchClusterChargeSessionSummaryResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  summary_details: [chargeSummaryDetailsResponse]
}

#
type chargeSummaryDetailsResponse {
  #
  session_id: String

  #
  app_user_id: String!

  #
  vin: String!

  #
  start_soc: Int

  #
  end_soc: Int

  #
  start_timestamp: String!

  #
  end_timestamp: String!

  #
  mqtt_server_time: String

  #
  kafka_enquequed_time: String

  #
  server_time: String

  #
  local_time: String

  #
  start_latitude: Float

  #
  start_longitude: Float

  #
  end_latitude: Float

  #
  end_longitude: Float

  #
  pluscode: String

  #
  total_energy_consumed: Float

  #
  method_of_charging: String

  #
  duration: Int
}

#
type CumulativeChargeSessionSummaryResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  summary_details: [cumulativeSummaryDetailsResponse]
}

#
type cumulativeSummaryDetailsResponse {
  #
  id: String

  #
  app_user_id: String!

  #
  vin: String!

  #
  total_charging_time: Int

  #
  total_charging_sessions: Int

  #
  total_energy_consumed: Int
}

#
type rideDetailsResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  data: rideData
}

#
type rideData {
  #
  totalRecords: Int

  #
  totalRideRecords: Int

  #
  totalTourRecords: Int

  #
  totalFavoriteRecords: Int

  #
  results: [resultData]
}

#
type resultData {
  #
  travelId: Int

  #
  vehicleTypeId: Int

  #
  vin: String

  #
  app_user_id: String

  #
  travelFileName: String

  #
  vehicleModelName: String

  #
  rideTime: Int

  #
  travelStartDateTime: String

  #
  travelEndDateTime: String

  #
  totalTravelledDistance: Float

  #
  topSpeed: Float

  #
  averageSpeed: Float

  #
  travelStatsDownloadLink: String

  #
  createdAt: String

  #
  travelName: String

  #
  type: Int

  #
  isFavourite: Boolean

  #
  day: String

  #
  totalTime: Int

  #
  isDeleted: Boolean

  #
  travelMMIDownloadLink: String

  #
  startLocation: String

  #
  endLocation: String

  #
  currentRideBestLapTime: Int

  #
  currentRideBestLapNumber: Int

  #
  currentRideTotalLapTime: Int

  #
  currentRideTotalLaps: Int

  #
  literPer100KM: Float

  #
  highestAltitude: Float

  #
  lastFuelStatus: Int

  #
  lowestAltitude: Float

  #
  vehicleAvgSpeed: Float

  #
  distanceToEmpty: Float

  #
  mileage: Float

  #
  odometerReading: Float

  #
  batteryVoltage: Float

  #
  cruisingRange: Int

  #
  vehicleBest0to60: Float

  #
  best0To100: Float

  #
  vehicleTopSpeed: Float

  #
  idleTime: Int

  #
  averageRPM: Float

  #
  topSpeedOverAll: Float

  #
  bestShortestTimeSportMode: Float

  #
  totalDistanceOverAll: Float

  #
  totalDuration: Int

  #
  maxAcceleration: Float

  #
  altitude: Float

  #
  maxDeceleration: Float

  #
  temperature: Float

  #
  isCompleted: Boolean

  #
  bestDeceleration: String

  #
  bestAcceleration: String

  #
  rearTyreMacId: String

  #
  frontTyreBattery: Float

  #
  speedoSWVersion: String

  #
  frontTyrePressure: Float

  #
  frontTyreMacId: String

  #
  rearTyrePressure: Float

  #
  rearTyreBattery: Float

  #
  best0To60: Float

  #
  frontTyreTemperature: Float

  #
  rearTyreTemperature: Float

  #
  totalDistanceStreetMode: Float

  #
  weatherShortDescription: String

  #
  isSportMode: Boolean

  #
  weatherIcon: String

  #
  rideTimeRaceMode: Int

  #
  averageSpeedSportMode: Float

  #
  averageSpeedStreetMode: Float

  #
  totalDistanceRaceMode: Float

  #
  lapDistanceSportMode: Float

  #
  averageSpeedRaceMode: Float

  #
  rideTimeStreetMode: Float

  #
  rideTag: Int

  #
  topSpeedRaceMode: Int

  #
  topSpeedSportMode: Float

  #
  isStreetMode: Boolean

  #
  topRPMRaceMode: Float

  #
  isRaceMode: Boolean

  #
  best0to60RaceMode: Float

  #
  userId274140: String

  #
  topSpeedStreetMode: Float

  #
  weatherTemp: Float

  #
  topRPM: Int

  #
  topRPMStreetMode: Float

  #
  best0to60StreetMode: Float

  #
  averageSpeedOverAll: Float

  #
  insertDate: String

  #
  modes: [ModesResponseData]

  #
  gears: [GearsResponseData]

  #
  laps: [LapsResponseData]

  #
  tour: TourResponseData
}

#
type ModesResponseData {
  #
  modeTypeId: Int

  #
  modeStartDateTime: Int

  #
  modeEndDateTime: Int

  #
  totalDistanceCovered: Float

  #
  totalDuration: Int
}

#
type GearsResponseData {
  #
  gearNumber: Int

  #
  gearStartDateTime: Int

  #
  gearEndDateTime: Int

  #
  totalDuration: Int

  #
  totalDistanceCovered: Float

  #
  averageSpeed: Float

  #
  averageUpshiftSpeed: Float

  #
  averageDownshiftSpeed: Float

  #
  averageRPM: Float

  #
  averageUpshiftRPM: Float

  #
  averageDownshiftRPM: Float
}

#
type LapsResponseData {
  #
  lapNumber: Int

  #
  lapTime: Int

  #
  lapDistance: Float
}

#
type TourResponseData {
  #
  tourId: Int

  #
  vin: String

  #
  app_user_id: String

  #
  type: Int

  #
  tourName: String

  #
  tourStartLocation: String

  #
  tourEndLocation: String

  #
  totalDuration: Int

  #
  totalDistance: Float

  #
  isDeleted: Boolean

  #
  isTourEnded: Boolean

  #
  tourStartDateTime: String

  #
  tourEndDateTime: String

  #
  mileage: Float

  #
  literPer100KM: Float

  #
  highestAltitude: Float

  #
  lowestAltitude: Float

  #
  topSpeed: Float

  #
  averageSpeed: Float

  #
  isFavourite: Boolean

  #
  tourMMIDownloadLink: String

  #
  createdAt: String

  #
  insertDate: String
}

#
type getVehicleOverViewResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  data: [VehicleOverViewResponse]
}

#
type VehicleOverViewResponse {
  #
  rideCumulativeId: String

  #
  vehicleTypeId: Int

  #
  vin: String

  #
  appUserId: String

  #
  totalRides: Float

  #
  totalTime: Float

  #
  rideTime: Float

  #
  totalTravelledDistance: Float

  #
  topSpeed: Float

  #
  averageSpeed: Float

  #
  isDeleted: Float

  #
  literPer100KM: Float

  #
  highestAltitude: Float

  #
  lastFuelStatus: Int

  #
  lowestAltitude: Float

  #
  vehicleAvgSpeed: Float

  #
  distanceToEmpty: Float

  #
  mileage: Float

  #
  odometerReading: Float

  #
  batteryVoltage: Float

  #
  cruisingRange: Int

  #
  vehicleBest0to60: Float

  #
  best0To100: Float

  #
  vehicleTopSpeed: Float

  #
  idleTime: Int

  #
  averageRPM: Float

  #
  topSpeedOverAll: Float

  #
  bestShortestTimeSportMode: Float

  #
  totalDistanceOverAll: Float

  #
  totalDuration: Int

  #
  maxAcceleration: Float

  #
  altitude: Float

  #
  tourId: Int

  #
  maxDeceleration: Float

  #
  temperature: Float

  #
  bestDeceleration: String

  #
  bestAcceleration: String

  #
  rearTyreMacId: String

  #
  frontTyreBattery: Float

  #
  speedoSwVersion: String

  #
  frontTyrePressure: Float

  #
  FrontTyreMacId: String

  #
  rearTyrePressure: Float

  #
  rearTyreBattery: Float

  #
  best0To60: Float

  #
  frontTyreTemperature: Float

  #
  rearTyreTemperature: Float

  #
  totalDistanceStreetMode: Float

  #
  weatherShortDescription: String

  #
  isSportMode: Boolean

  #
  weatherIcon: String

  #
  rideTimeRaceMode: Int

  #
  averageSpeedSportMode: Float

  #
  averageSpeedStreetMode: Float

  #
  totalDistanceRaceMode: Float

  #
  lapDistanceSportMode: Float

  #
  averageSpeedRaceMode: Float

  #
  rideTimeStreetMode: Float

  #
  rideTag: Int

  #
  topSpeedRaceMode: Int

  #
  topSpeedSportMode: Float

  #
  isStreetMode: Boolean

  #
  topRpmRaceMode: Float

  #
  isRaceMode: Boolean

  #
  best0To60RaceMode: Float

  #
  userId274140: String

  #
  topSpeedStreetMode: Float

  #
  weatherTemp: Float

  #
  topRpm: Int

  #
  topRpmStreetMode: Float

  #
  best0To60StreetMode: Float

  #
  averageSpeedOverall: Float

  #
  status: Int

  #
  modes: [ModesResponseData]

  #
  gears: [GearsResponseData]

  #
  laps: [LapsResponseData]

  #
  createdAt: String

  #
  updatedAt: String
}

#
type getRidingPatternResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  data: RidingPatternData
}

#
type RidingPatternData {
  #
  Modes: [ModesResponseData]

  #
  Gears: [GearsResponseData]
}

#
input Filters {
  #
  isPrimaryBattery: Boolean

  #
  isNoGps: Boolean

  #
  isNoData: Boolean

  #
  haltStatus: Boolean

  #
  idlingStatus: Boolean

  # Will be true if isOfflineSinceSeconds have passed since the last packet time
  isOffline: Boolean
}

#
input Configs {
  # Value in seconds, should be greater than 0. Defaults to 1800 seconds
  isOfflineSinceSeconds: Int
}

#
type DeviceTrackingData {
  #
  vehicleNumber: String!

  #
  vehicleType: String!

  #
  vehicleModel: String!

  #
  uniqueId: String!

  #
  vehicleGroups: [String!]

  #
  timestamp: String

  #
  latitude: Float

  #
  longitude: Float

  #
  gpsStatus: String

  #
  satellites: Int

  #
  idlingStatus: Boolean

  #
  haltStatus: Boolean

  #
  isOverspeed: Boolean

  #
  isHA: Boolean

  #
  isHB: Boolean

  #
  isNoGps: Boolean

  #
  isOffline: Boolean

  #
  isNoData: Boolean

  #
  speed: Float

  #
  extBatVol: Float

  #
  plusCode: String

  #
  address: String

  #
  event_flag: String

  #
  gpsSignal: Int

  #
  isPrimaryBattery: Boolean

  #
  standAlone: Boolean

  #
  revenue: Boolean
}

#
type LiveDataTrackingResponse {
  #
  response: DataLive

  #
  status: Int

  #
  statusMessage: String
}

#
type DataLive {
  #
  userId: String

  #
  timestamp: String

  #
  unitid: String

  #
  odometer: Float

  #
  vin: String

  #
  latitude: Float

  #
  longitude: Float

  #
  isLiveLocation: Boolean

  #
  lastValidTimestamp: String

  #
  last_incognito_off_latitude: Float

  #
  last_incognito_off_longitude: Float

  #
  last_incognito_off_address: String

  #
  last_incognito_off_timestamp: String

  #
  idlingStatus: Boolean

  #
  haltStatus: Boolean

  #
  isOverspeed: Boolean

  #
  speed: Float

  #
  extBatVol: Float

  #
  heading: Float

  #
  main_voltage: Float

  #
  ignition: Float

  #
  panic_button: Float

  #
  immobilizer: Float

  #
  datetime_pkt: String

  #
  soc: Int

  #
  odometer_can: Float

  #
  speed_can: Float

  #
  isPrimaryBattery: Boolean

  #
  charging_status: Int

  #
  isNoGps: Boolean

  #
  address: String

  #
  ignition_status: Int

  #
  driving_mode: Float

  #
  can_modified: String

  #
  time_to_charge_completion: Int

  #
  incognito_mode: String

  #
  co2Saved: Float

  #
  regen_status: Float

  #
  regen_energy: Float

  #
  ev_range: ev_range_detail

  #
  tyre_pressure: tyre_pressure_detail

  #
  package_version: String

  #
  totalTripsToday: Int

  #
  avgSpeedToday: Float

  #
  totalDistanceToday: Float

  #
  totalTimeTakenToday: Float

  #
  trees_offset: Float

  #
  is_sos: Boolean

  #
  is_tow: Boolean

  #
  is_crash: Boolean

  #
  is_fall: Boolean

  #
  regen_level: Float

  #
  imeiNo: String

  #
  serviceProvider: String

  #
  bat_a_uid: String

  #
  bat_b_uid: String

  #
  bat_a_soc: String

  #
  bat_b_soc: String

  #
  handleBar_status: String

  #
  timeToCharge: Float
}

#
type ev_range_detail {
  #
  dte_eco: Float

  #
  dte_power: Float

  #
  dte_street: Float

  #
  Xtl: Float

  #
  Xtr: Float

  #
  Xnc: Float
}

#
type tyre_pressure_detail {
  #
  front: String

  #
  rear: String
}

#
type HomechargerDataResponse {
  #
  status: Int!

  #
  statusMessage: String!

  #
  hc_data: HomechargerData
}

#
type HomechargerData {
  #
  hc_imei: String

  #
  bat_a_uid: String

  #
  bat_b_uid: String

  #
  bat_a_soc: Int

  #
  bat_b_soc: Int

  #
  hc_charging_status: Boolean

  #
  charging_dock_states_batA: String

  #
  charging_dock_states_batB: String

  #
  left_slot_bat_uid: String

  #
  right_slot_bat_uid: String

  #
  bat_a_timestamp: String

  #
  bat_b_timestamp: String

  #
  bat_a_eco_range: Float

  #
  bat_b_eco_range: Float

  #
  timeToCharge: Float
}

#
type BatteriesLatestDataResponse {
  #
  response: batteriesData

  #
  status: Int

  #
  statusMessage: String
}

#
type batteriesData {
  #
  bat_a_uid: String

  #
  bat_b_uid: String

  #
  bat_a_state: String

  #
  bat_b_state: String

  #
  bat_a_soc: Float

  #
  bat_b_soc: Float

  #
  bat_a_charging_status: String

  #
  bat_b_charging_status: String

  #
  soc: Float

  #
  eco_range: Float

  #
  pow_range: Float

  #
  bat_a_timestamp: String

  #
  bat_b_timestamp: String

  #
  time_to_charge_on_vehicle: Int
}

#
type fetchClusterRideSessionSummaryResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  summary_details: [summaryDetailsResponse]
}

#
type summaryDetailsResponse {
  #
  session_id: String

  #
  app_user_id: String!

  #
  vin: String!

  #
  start_timestamp: String!

  #
  end_timestamp: String!

  #
  mqtt_server_time: String

  #
  kafka_enquequed_time: String

  #
  server_time: String

  #
  local_time: String

  #
  start_location: location_lat_long

  #
  end_location: location_lat_long

  #
  start_address: String

  #
  end_address: String

  #
  type: String

  #
  start_odo: Float

  #
  end_odo: Float

  #
  distance_covered_mode_wise: String

  #
  total_distance: Float

  #
  avg_speed_mode_wise: String

  #
  total_avg_speed: Float

  #
  top_speed: Float

  #
  energy_consumed_mode_wise: String

  #
  energy_consumed_overall: Float

  #
  energy_recovered_mode_wise: String

  #
  energy_recovered_overall: Float

  #
  duration: Int

  #
  co2_saved: Float

  #
  driving_score: Int

  #
  cornering_score: Int

  #
  braking_score: Int

  #
  acceleration_screen: Int

  #
  speeding_score: Int

  #
  start_soc: Int

  #
  end_soc: Int

  #
  battery_used: Int
}

#
type location_lat_long {
  #
  lat: Float

  #
  long: Float
}

#
type fetchClusterCumulativeRideSessionSummaryResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  summary_details: [CumulativesummaryDetailsResponse]
}

#
type CumulativesummaryDetailsResponse {
  #
  id: String

  #
  app_user_id: String!

  #
  vin: String!

  #
  total_duration: Int

  #
  total_trips: Int

  #
  distance_covered_mode_wise: String

  #
  total_distance: Float

  #
  avg_speed_mode_wise: String

  #
  avg_speed: Float

  #
  top_speed: Float

  #
  energy_consumed_mode_wise: String

  #
  energy_consumed_overall: Float

  #
  energy_recovered_mode_wise: String

  #
  energy_recovered_overall: Float

  #
  co2_saved: Float

  #
  driving_score: Int

  #
  cornering_score: Int

  #
  braking_score: Int

  #
  speeding_score: Int

  #
  acceleration_screen: Int

  #
  battery_used: Int
}

type Mutation {
  #
  _emptyMutation: String

  #
  addServiceProvider(name: String!): Boolean!

  #
  addDeviceModel(
    model_name: String!
    version: Float!
    devicetype: String!
    description: String
    maxPrice: Int
    manufacturerId: Int!
  ): Boolean!

  #
  updateDeviceModel(
    id: Int!
    model_name: String!
    version: Float!
    devicetype: String!
    description: String
    maxPrice: Int
    status: Int!
  ): Boolean!

  #
  addDeviceDetail(
    serial_num: String!
    imei_num: String!
    uniqueDeviceId: String!
    deviceModelId: Int!
    manufacturerId: Int!
    ownerLoginId: Int!
  ): Boolean!

  #
  updateDeviceDetail(
    serial_num: String!
    imei_num: String!
    uniqueDeviceId: String!
    status: Int!
    deviceModelId: Int!
    manufacturerId: Int!
    ownerLoginId: Int!
    oldUniqueDeviceId: String!
  ): Boolean!

  #
  updateDevicePartner(
    serial_num: String!
    imei_num: String!
    uniqueDeviceId: String!
    status: Int!
    deviceModelId: Int!
    manufacturerId: Int!
    ownerLoginId: Int!
    oldUniqueDeviceId: String!
  ): Boolean!

  #
  deassignDeviceFromSubscription(
    serial_num: String!
    imei_num: String!
    subscriptionId: Int!
  ): Boolean!

  #
  addDeviceDetailsFromPartnerAdmin(
    serial_num: String!
    imei_num: String!
    uniqueDeviceId: String!
    deviceModelId: Int!
    manufacturerId: Int!
    ownerLoginId: Int!
  ): Boolean!

  #
  addDeviceToInventoryAndSubscriptionAPI(
    deviceNumbers: [inputDevices!]!
    simProvider: SIMPROVIDER!
    deviceModel: DEVICEMODEL!
    deviceManufacturer: DEVICEMANUFACTURER!
  ): deviceResponse!

  #
  deleteDeviceFromInventoryAndSubscription(
    deviceNumbers: [inputDevices!]!
    clientLoginId: Int!
  ): [deletedDevice!]!

  #
  deleteDeviceFromInventoryAndSubscriptionAPI(
    deviceNumbers: inputDevices!
  ): deletedDevice!

  #
  addDeviceSequece(uniqueDeviceId: String!): Boolean!

  #
  testAPI(clientLoginId: Int): String!

  #
  onBoardVehicle(
    deviceManufacturer: DEVICEMANUFACTURER!
    deviceModel: DEVICEMODEL!
    deviceSerialNo: String!
    deviceImeiNo: String!
    simProvider: SIMPROVIDER!
    simPhoneNumber: String!
    vehicleNumber: String!
    vehicleMake: String!
    averageMileage: Int!
    vehicleModel: String!
    vehicleType: VEHICLETYPES!
    overSpeedLimit: Int!
  ): vehicleDetails!

  #
  updateOnBoardedVehicle(
    deviceSerialNo: String!
    deviceImeiNo: String!
    simPhoneNumber: String!
    vehicleNumber: String!
    vehicleMake: String!
    vehicleModel: String!
    averageMileage: Int!
    vehicleType: VEHICLETYPES!
  ): updatedOnBoardedVehicleDetails!

  #
  decoupleDeviceSim(
    newDeviceUniqueId: String
    existingDeviceUniqueId: String
    newSimId: Int
    existingSimId: Int
    decoupleType: String!
    loginType: String!
  ): String!

  #
  testDecouple(
    newDeviceUniqueId: String
    existingDeviceUniqueId: String
    newSimNumber: Int
    existingSimNumber: Int
    newPhoneNumber: Int
    exixtingPhoneNumber: Int
    decoupleType: String!
    loginType: String!
  ): String!

  #
  deleteDeviceInStock(deviceUniqueId: String!): Boolean!

  #
  addSimDetail(
    phoneNumber: String!
    simNumber: String!
    service_provider_id: Int!
    monthlyCharges: Int!
    ownerLoginId: Int!
    status: Int
  ): Boolean!

  #
  updateSimDetail(
    id: Int!
    phoneNumber: String!
    simNumber: String!
    ownerLoginId: Int!
    monthlyCharges: Int!
    status: Int!
    service_provider_id: Int
  ): Boolean!

  #
  addSimToInventoryAndSubscriptionAPI(
    simPhoneNumber: [inputSims!]!
    simProvider: SIMPROVIDER!
    deviceModel: DEVICEMODEL!
    deviceManufacturer: DEVICEMANUFACTURER!
  ): simResponse!

  #
  addSimDetailsFromPartnerAdmin(
    phoneNumber: String!
    simNumber: String!
    service_provider_id: Int!
    ownerLoginId: Int!
    monthlyCharges: Int!
  ): Boolean!

  #
  addSimDetailsFromResellerAdmin(
    phoneNumber: String!
    simNumber: String!
    service_provider_id: Int!
    ownerLoginId: Int!
    monthlyCharges: Int!
  ): Boolean!

  # Delete a SIM
  deleteSim(
    # Phone number
    phoneNumber: String!

    # SIM number
    simNumber: String!

    # Owner's login id
    ownerLoginId: Int!
  ): Boolean!

  # Delete a Single SIM
  deleteSingleSim(
    # Phone number
    phoneNumber: String!

    # SIM number
    simNumber: String!

    # Owner's login id
    ownerLoginId: Int!
  ): Boolean!

  # Deassign Sim
  deassignSimFromSubscription(
    phoneNumber: String!
    simNumber: String!
    subscriptionId: Int!
  ): Boolean!

  #
  partnerSignup(
    username: String!
    password: String!
    accountType: String!
    businessName: String!
    email: String!
    contactPerson: String!
    contactNumber: String!
    billingMode: Int!
    salesPersonId: Int!
    address: String!
    city: String!
    state: Int!
    country: Int!
    pincode: Int!
    panNumber: String!
    partnerType: String!
    solution: Solution!
    typeOfPartner: ClientPartnerType
  ): Boolean!

  #
  superAdminSignup(
    username: String!
    password: String!
    accountType: String!
  ): Login!

  #
  clientSignup(
    username: String!
    password: String!
    accountType: String!
    clientName: String!
    email: String!
    contactPerson: String!
    contactNumber: String!
    address: String!
    city: String!
    state: Int!
    country: Int!
    pincode: Int
    panNumber: String
    gst: String
    planId: Int
    solution: String!
    billingMode: Int!
    salesPersonId: Int
    clientType: String!
    timezone: String!
    lat: Float
    long: Float
    partnerLoginId: Int
    resellerLoginId: Int
    licenseTypeId: Int
    typeOfClient: ClientPartnerType
    expiryDate: String
    registrationType: String
    secondaryContactName: String
    secondaryContactNumber: String
    secondaryEmail: String
    shippingAddress: String
    shippingCountry: Int
    shippingState: Int
    shippingCity: String
    shippingPincode: Int
    minimumTrackedDays: Int!
    packetThreshold: Int
    prorata: Int!
    addressEffectiveDate: String
  ): String!

  #
  decryptPass(pass: String): String

  #
  createClientAPI(
    username: String!
    password: String!
    clientName: String!
    email: String!
    contactPerson: String!
    contactNumber: String!
    address: String!
    city: String!
    state: STATE!
    country: COUNTRY!
    pincode: Int
    panNumber: String
    timezone: TIMEZONE!
    aadharNumber: String
    gst: String
  ): ClientDetailsResponse!

  #
  userSignup(
    username: String!
    password: String!
    accountType: String!
    userName: String!
    email: String
    contactNumber: String!
    clientLoginId: Int!
    roleId: Int!
    groupId: Int!
    address: String
  ): Boolean!

  #
  createUser(
    username: String!
    password: String!
    accountType: String
    email: String
    contactNumber: String!
    userName: String!
    roleId: Int!
    groupId: Int!
  ): Boolean!

  #
  createSublogin(
    username: String!
    password: String!
    subLoginName: String!
    email: String
    contactNumber: String!
    roleId: Int!
    groupId: Int!
  ): SubLoginDetails!

  #
  updateSublogin(
    subLoginId: Int!
    username: String
    password: String
    subLoginName: String
    email: String
    contactNumber: String
    roleId: Int
    groupId: Int
  ): SubLoginDetails!

  #
  changeUsernamePassword(
    newUsername: String
    newPassword: String!
    confirmNewPassword: String
    oldPassword: String
    loginId: Int
  ): Boolean!

  #
  validateToken(token: String!): validateTokenResponse!

  #
  updatePartnerDomainConfig(loginId: Int!, domain: String!): Boolean!

  #
  updatePartnerDetail(
    id: Int!
    businessName: String!
    email: String!
    contactPerson: String!
    contactNumber: String!
    billingMode: Int!
    salesPersonId: Int!
    login_id: Int!
    address: String!
    city: String!
    state_id: Int!
    country_id: Int!
    pincode: Int!
    panNumber: String!
    partnerType: String!
    status: Int!
    solution: String!
    typeOfPartner: ClientPartnerType
  ): Boolean!

  #
  deactivatePartnerAndClients(partnerLoginId: Int!, action: action!): Boolean!

  #
  addManufacturerDetail(
    manufacturerName: String!
    manufacturerCode: String!
    email: String!
    contactPerson: String!
    contactNumber: String!
    address: String!
    city: String!
    state_id: Int!
    country_id: Int!
    pincode: Int!
  ): Boolean!

  #
  updateManufacturerDetail(
    id: Int!
    manufacturerName: String!
    manufacturerCode: String!
    email: String!
    contactPerson: String!
    contactNumber: String!
    address: String!
    city: String!
    state_id: Int!
    country_id: Int!
    pincode: Int!
    Status: Int!
  ): Boolean!

  #
  addManufacturerPartnerAssignDetail(
    manufacturerId: Int!
    partnerLoginId: Int!
  ): Boolean!

  #
  addDeviceModelPartnerAssignDetail(
    manufacturerId: Int!
    partnerLoginId: Int!
    deviceModelId: Int!
  ): Boolean!

  #
  addDevicePartnerAssignDetail(
    uniqueDeviceId: String!
    partnerLoginId: Int!
    deviceModelId: Int!
  ): Boolean!

  #
  assignDevicesToClient(
    clientLoginId: Int!
    partnerLoginId: Int!
    uniqueDeviceId: String!
  ): Boolean!

  #
  addSimPartnerAssignDetail(
    simId: Int!
    partnerLoginId: Int!
    serviceProviderId: Int!
  ): Boolean!

  #
  assignSimToClient(
    clientLoginId: Int!
    partnerLoginId: Int!
    simId: Int!
  ): Boolean!

  #
  updateClientDetail(
    id: Int!
    clientName: String!
    email: String!
    contactPerson: String!
    contactNumber: String!
    loginUsername: String!
    login_id: Int!
    address: String!
    city: String!
    state_id: Int!
    country_id: Int!
    plan_id: Int
    solution: String!
    billingMode: Int!
    salesPersonId: Int
    pincode: Int
    panNumber: String
    gst: String
    clientType: String!
    timezone: String!
    lat: Float
    long: Float
    status: Int!
    partnerLoginId: Int
    resellLoginId: Int
    licenseTypeId: Int
    typeOfClient: ClientPartnerType
    expiryDate: String
    registrationType: String
    secondaryContactName: String
    secondaryContactNumber: String
    secondaryEmail: String
    shippingAddress: String
    shippingCountry: Int
    shippingState: Int
    shippingCity: String
    shippingPincode: Int
    packetThreshold: Int
    minimumTrackedDays: Int!
    prorata: Int!
    addressEffectiveDate: String
  ): String!

  #
  updateDriverWeightsForClient(clientLoginId: Int!, weights: JSON!): Boolean!

  #
  clientDeactivationAndActivation(
    clientLoginId: Int!
    activate: Boolean!
    accountType: String!
  ): String!

  #
  clientOfflineCondition(clientLoginId: Int!, offlineSeconds: Int): String!

  # Register a vehicle.
  addVehicleDetail(
    # Vehicle number to be registered.
    vehicleNumber: String!

    # Engine number of the vehicle.(optional)
    engineNumber: String

    # Chassis number of the vehicle.(optional)
    chassisNumber: String

    # Login id of the client to which vehicle need to be registered.
    clientLoginId: Int!

    # Unique device id of the device to be registered to the vehicle.
    uniqueDeviceId: String!

    #
    simId: Int!

    #
    speedSensorType: String!

    #
    speedLimit: Int!

    #
    uniqueAccessoryId: String

    #
    vehicleType: String!

    # Vehicle make of the vehicle.(optional)
    vehicleMake: String

    # Average mileage of the vehicle.(optional)
    averageMileage: Int

    #
    vehicleModel: String!

    # Vehicle capacity of the vehicle.(optional)
    vehicleCapacity: Int

    # Is vehicle activated. (Optional)
    isActivated: Boolean

    #
    partnerSubscriptionId: Int!

    # Type of the account. Possible types are INV,SAL,SER,ACC and PA
    accountType: String

    # Used for skoda
    vehicleIdentificationNumber: String

    # Vehicle colour
    vehicleColour: String

    # Invoice number (optional)
    invoiceNumber: String

    # Equipment serial number (optional)
    idlingSpeed: Int

    # Equipment serial number (optional)
    equipmentSerialNumber: String

    # Equipment serial number (optional)
    equipmentName: String

    # Commissioning date
    commissioningDate: Int

    #
    department: String

    #
    contractorName: String

    #
    operatorName: String

    #
    operatorContactNumber: String
  ): Boolean!

  #
  updateApproveStatus(
    deviceUniqueId_fk: String!
    vehicleStatus: vehicleStatus
  ): Boolean!

  #
  registerVehicle(
    serialNumber: String!
    vehicleNumber: String!
    clientLoginId: Int!
    vehicleType: SupportedVehicleTypes!
    vehicleModel: String!
    vehicleCapacity: Int
  ): Boolean!

  # save the client LoginId.
  saveclientLoginId(clientName: String): Boolean!

  # Update the vehicle details
  updateVehicleDetail(
    # Id of the vehicle to be updated.
    entityId: Int!

    # Vehicle plate number
    vehicleNumber: String!

    # Enginenumber of the vehicle.(optional)
    engineNumber: String

    # Chassis number of the vehicle.(optional)
    chassisNumber: String

    # Login Id of client.
    clientLoginId: Int!

    # Type of speed sensor. Possible values are GPS SPEED SENSOR and ODOMETRIC
    speedSensorType: String!

    # Speed limit of the vehicle
    speedLimit: Int!

    # Type of vehicle. Possible values are Bike,Car,,Bus,school bus,Ambulance,Truck,Roller
    vehicleType: String!

    # Model of the vehicle.
    vehicleModel: String!

    # Capacity of the vehicle.(optional)
    vehicleCapacity: Int

    # Equipment serial number (optional)
    equipmentSerialNumber: String

    # Equipment serial number (optional)
    idlingSpeed: Int

    # Equipment serial number (optional)
    invoiceNumber: String

    # Equipment serial number (optional)
    equipmentName: String

    # Commissioning date
    commissioningDate: Int

    #
    department: String

    # Is vehicle activated.(optional)
    isActivated: Boolean

    # Status of the vehicle. Possible values are 1,2,3
    status: Int!

    #
    contractorName: String

    #
    operatorName: String

    #
    operatorContactNumber: String
  ): Boolean!

  #
  editVehicle(
    deviceUniqueId: String!
    vehicleNumber: String
    chassisNumber: String
    engineNumber: String
  ): Boolean!

  # Device and associated sim registered to vehicle will be deassigned and will be
  # returned to stock. Vehicle associated to device is deleted.
  deAssignVehicleAndSImFromCLient(
    # Unique id of the device.
    deviceUniqueId: String!
  ): String

  # Delete a vehicle and associated device and sim will be returned back to assigned to client status
  deleteOnBoardedVehicle(
    # Vehicle number to be deleted.
    vehicleNumber: String!
  ): deletedVehicleDetails!

  #
  updateOnBoardedVehiceNumber(
    oldVehicleNumber: String!
    newVehicleNumber: String!
  ): updatedVehicleDetails!

  #
  onBoardNewVehicle(
    deviceManufacturer: DeviceManufacturer!
    deviceModel: DeviceModels!
    deviceSerialNo: String!
    deviceImeiNo: String!
    phoneNumber: String!
    simNumber: String!
    serviceProvider: ServiceProviders!
    vehicleNumber: String!
    vehicleType: VEHICLE!
    vehicleModel: String!
  ): VehicleDetails

  #
  onBoardTheVehicle(
    deviceManufacturer: DeviceManufacturer!
    deviceModel: DeviceModels!
    deviceSerialNo: String!
    deviceImeiNo: String!
    phoneNumber: String!
    simNumber: String!
    serviceProvider: ServiceProviders!
    vehicleNumber: String!
    vehicleType: VEHICLE!
    vehicleModel: String!
    vehicleIdentificationNumber: String
    vehicleColour: String
  ): VehicleDetails

  #
  onBoardUserAndVehicle(
    vin: String!
    vehicle_registration_number: String
    vehicle_nick_name: String
    description: String
    vehicle_colour: String
    vehicle_type_id: Int
    theme: Int
    imei_number: String!
    codp_model: String
    variant_id: String!
    sim_number: String
    phone_number: String
    sim_provider: String
    sale_date: String
    primary_user_details: PrimaryUserDetailsInput
  ): vehicleDetailsReponse

  #
  onBoardVehicleIntoClient(
    deviceManufacturer: DeviceManufacturer!
    deviceModel: DeviceModels!
    deviceSerialNo: String!
    deviceImeiNo: String!
    phoneNumber: String!
    simNumber: String!
    serviceProvider: ServiceProviders!
    vehicleNumber: String!
    vehicleType: VEHICLE!
    vehicleModel: String!
    subscriptionId: Int!
    vehicleIdentificationNumber: String
    vehicleColour: String
  ): VehicleDetails

  #
  onBoardDeviceAndVehicle(
    clientLoginId: Int!
    deviceManufacturer: DeviceManufacturer!
    deviceModel: DeviceModels!
    deviceSerialNo: String!
    deviceImeiNo: String!
    phoneNumber: String!
    simNumber: String!
    serviceProvider: ServiceProviders!
    vehicleNumber: String!
    vehicleType: VEHICLE!
    vehicleModel: String!
    engineNumber: String
    chassisNumber: String
  ): VehicleDetails

  #
  updateTheOnBoardedVehicle(
    deviceSerialNo: String!
    vehicleNumber: String!
    vehicleType: VEHICLETYPES!
    vehicleModel: String!
    engineNumber: String
    chassisNumber: String
  ): UpdateOnBoardedVehicleResponse!

  #
  addAlert(
    alertName: String!
    alertType: String!
    alertDescription: String!
    valueType: String
    valueStatus: Int!
  ): Boolean!

  #
  updateAlert(
    id: Int!
    alertName: String!
    alertType: String!
    alertDescription: String!
    valueType: String
    valueStatus: Int!
    status: Int!
  ): Boolean!

  #
  assignAlertsToClient(clientLoginId: Int!, alertId: Int!): Boolean!

  #
  deAssignAlertsToClient(clientLoginId: Int!, alertId: Int!): Boolean!

  #
  addPanicAlertConfig(
    panicType: Int!
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
  ): Boolean!

  #
  addMultiplePanicAlertConfig(
    panicType: Int!
    clientLoginId: Int!
    uniqueDeviceId: [String!]!
  ): Boolean!

  #
  updatePanicAlertConfig(
    id: Int!
    panicType: Int!
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
    status: Int!
  ): Boolean!

  #
  setMultiDeviceAlertConfigs(
    alertConfigs: [AlertConfigInput!]
    clientLoginId: Int
    alertType: String!
  ): Boolean!

  #
  updateAlertsToGroupVehicles(
    alertType: ALERT!
    alertValue: String
    groupId: Int!
    enabled: Boolean!
  ): GROUPALERTS!

  #
  updateAllAlertsToGroupVehicles(
    groupId: Int!
    alertInput: [ALERTINPUT!]!
  ): [GROUPALERTS!]!

  #
  updateAlertConfig(
    alertType: ALERT!
    alertValue: String
    vehicleNumber: String!
    enabled: Boolean!
  ): ALERTCONFIGS!

  #
  updateAllAlertsConfig(
    vehicleNumber: String!
    alertInput: [ALERTINPUT!]!
  ): ALERTCONFIG!

  #
  scheduleMaintReminderCron(run: Boolean!): Boolean

  #
  transferAlertsConfigToRedis(run: Boolean!): Boolean

  #
  createGeoFenceKeys(run: Boolean!): Boolean

  #
  setConditionalAlertConfig(
    vin: String!
    app_user_id: String!
    alert_parameter: String!
    alert_threshold_critical_high: Float
    alert_threshold_high: Float
    alert_threshold_low: Float
    alert_threshold_critical_low: Float
    is_enabled: Boolean!
  ): setConditionalAlertConfigResponse

  #
  addOverSpeedAlertConfig(
    osLimit: Int!
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
  ): Boolean!

  #
  updateOverSpeedAlertConfig(
    id: Int!
    osLimit: Int!
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
    status: Int!
  ): Boolean!

  #
  setOverspeedThreshold(
    osLimit: Int!
    vin: String!
    app_user_id: String!
  ): overSpeedResponse

  #
  addExtBatteryAlertConfig(
    voltage: Float!
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
  ): Boolean!

  #
  updateExtBatteryAlertConfig(
    id: Int!
    voltage: Float!
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
    status: Int!
  ): Boolean!

  #
  addTowAlertConfig(
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
  ): Boolean!

  #
  updateTowAlertConfig(
    id: Int!
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
    status: Int!
  ): Boolean!

  #
  addFallAlertConfig(
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
  ): Boolean!

  #
  updateFallAlertConfig(
    id: Int!
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
    status: Int!
  ): Boolean!

  #
  addNoResponseAlertConfig(
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
  ): Boolean!

  #
  updateNoResponseAlertConfig(
    id: Int!
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
    status: Int!
  ): Boolean!

  #
  addNoDispenseAlertConfig(
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
  ): Boolean!

  #
  updateNoDispenseAlertConfig(
    id: Int!
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
    status: Int!
  ): Boolean!

  #
  addIntBatteryVoltageAlertConfig(
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
  ): Boolean!

  #
  updateIntBatteryVoltageAlertConfig(
    id: Int!
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
    status: Int!
  ): Boolean!

  #
  addPulloutAlertConfig(
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
  ): Boolean!

  #
  updatePulloutAlertConfig(
    id: Int!
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
    status: Int!
  ): Boolean!

  #
  addGeofenceAlertConfig(
    areaId: Int!
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
  ): Boolean!

  #
  updateGeofenceAlertConfig(
    id: Int!
    areaId: Int!
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
    status: Int!
  ): Boolean!

  #
  addRoutefenceAlertConfig(
    clientLoginId: Int!
    uniqueDeviceId: String!
    routeId: Int!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
  ): Boolean!

  #
  updateRoutefenceAlertConfig(
    id: Int!
    clientLoginId: Int!
    uniqueDeviceId: String!
    routeId: Int!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
    status: Int!
  ): Boolean!

  #
  addRoles(clientLoginId: Int!, roleName: String!): Boolean!

  #
  addRoleAndFeatures(
    clientLoginId: Int!
    roleName: String!
    featureRoleAssignLists: [FeatureRoleAssigns!]
  ): Boolean!

  #
  updateRoleDetail(
    id: Int!
    clientLoginId: Int!
    roleName: String!
    status: Int!
  ): Boolean!

  #
  updateRoleFeatures(
    roleId: Int!
    featureRoleAssignLists: [FeatureRoleAssigns!]
  ): Boolean!

  #
  deleteRoleFeatures(roleId: Int!): Response!

  #
  addGroups(clientLoginId: Int!, groupName: String!): Boolean!

  #
  updateGroupDetail(
    id: Int!
    clientLoginId: Int!
    groupName: String!
    status: Int!
  ): Boolean!

  #
  addGroup(groupName: String!): groupDetails!

  #
  updateGroupName(groupId: Int!, newGroupName: String!): updatedGroupDet!

  #
  deleteGroupAPI(groupId: Int!): deletedGroup!

  #
  assignVehiclesToGroupAPI(
    groupId: Int!
    vehicleList: [VehicleNumList!]!
  ): assignDetails!

  #
  deAssignVehiclesFromGroupAPI(
    groupId: Int!
    vehicleList: [VehicleNumList!]!
  ): assignDetails!

  #
  updateUserDetail(
    id: Int!
    userName: String!
    email: String
    contactNumber: String!
    clientLoginId: Int
    roleId: Int!
    groupId: Int!
    status: Int!
    loginId: Int!
    loginUsername: String!
    address: String
  ): String!

  #
  deleteGroup(groupId: Int!): String!

  #
  deleteUser(userId: Int!): String!

  #
  addDriver(
    driverName: String!
    firstName: String!
    lastName: String!
    email: String
    license: String!
    countryCode: String!
    contactNumber: String!
    userLoginId: Int
    clientLoginId: Int
    vehicleId: Int
    rfid: String!
    vehicleType: String!
    driverType: String!
    licenseExpiry: String!
    driverImage: String
    otherDocument: String
  ): Boolean!

  #
  updateDriverDetail(
    id: Int!
    driverName: String!
    firstName: String!
    lastName: String!
    email: String
    license: String!
    countryCode: String!
    contactNumber: String!
    clientLoginId: Int
    userLoginId: Int
    vehicleId: Int
    rfid: String!
    vehicleType: String!
    driverType: String!
    licenseExpiry: String!
    driverImage: String
    otherDocument: String
    status: Int!
  ): Boolean!

  #
  deleteDriver(id: Int!): Boolean!

  #
  updateDriverLoginAndLogOutTime(
    driverId: Int!
    name: String
    date: String
    loginTime: String
    logOutTime: String
  ): Boolean

  #
  assignVehiclesToGroup(
    groupId: Int!
    vehicleList: [VehicleListInput!]!
  ): Boolean!

  #
  assignVehicleToGroup(
    groupId: Int!
    vehicleList: [VehicleListInput!]!
  ): Boolean!

  #
  deAssignVehicleFromGroup(
    groupId: Int!
    vehicleList: [VehicleListInput!]!
  ): Boolean!

  #
  addFeatures(
    featureName: String!
    featureKey: String!
    costPerAssetPerMonth: Int!
    featureDescription: String!
  ): Boolean!

  #
  updateFeature(
    id: Int!
    featureName: String!
    featureKey: String!
    costPerAssetPerMonth: Int!
    featureDescription: String!
    status: Int!
  ): Boolean!

  #
  addFeatureRoleAssignDetail(
    roleId: Int!
    featureRoleAssignList: [FeatureRoleAssignInput!]
  ): Boolean!

  #
  updateFeatureRoleAssignDetail(
    roleId: Int!
    featureRoleAssignList: [FeatureRoleAssignInput!]
  ): Boolean!

  #
  addReportField(
    fieldId: String!
    fieldName: String!
    fieldType: String!
  ): Boolean!

  #
  updateReportField(
    fieldId: String!
    fieldName: String!
    fieldType: String!
    status: Int!
  ): Boolean!

  #
  addReportType(reportTypeId: String!, reportType: String!): Boolean!

  #
  updateReportType(
    reportTypeId: String!
    reportType: String!
    status: Int!
  ): Boolean!

  #
  addCategory(
    availFields: String!
    categorizedAvailFields: String
    reportType: String
  ): Boolean!

  #
  updateCategory(
    category: Int!
    availFields: String!
    categorizedAvailFields: String
    reportType: String
    status: Int!
  ): Boolean!

  #
  addReportBuilder(
    clientLoginId: Int!
    category: Int!
    reportName: String!
    fields: String!
    reportType: String
  ): Boolean!

  #
  updateReportBuilder(
    clientLoginId: Int!
    category: Int!
    reportName: String!
    fields: String!
    reportType: String
    oldReportName: String!
    status: Int!
  ): Boolean!

  #
  deleteReportBuilder(clientLoginId: Int!, reportName: String!): Boolean!

  #
  addUpdateOrDeleteReportAutomation(
    operationType: String!
    reportName: String!
    loginId: Int!
    frequency: String
    vehicleList: String
    emails: String
    status: Int!
  ): Boolean!

  #
  addDefaultReportBuilder(
    category: Int!
    reportName: String!
    fields: String!
    reportType: String
  ): Boolean!

  #
  updateDefaultReportBuilder(
    category: Int!
    reportName: String!
    fields: String!
    reportType: String
    status: Int!
  ): Boolean!

  #
  addPlans(
    planName: String!
    description: String!
    featureList: String!
    costPerAsset: Int!
    partnerLoginId: Int
  ): Boolean!

  #
  updatePlans(
    id: Int!
    planName: String!
    description: String!
    featureList: String!
    costPerAsset: Int!
    partnerLoginId: Int
    status: Int!
  ): Boolean!

  #
  deletePlan(id: Int!, partnerLoginId: Int): Boolean!

  #
  addBillingMode(billingMode: String!): Boolean!

  #
  updateBillingMode(id: Int!, billingMode: String!, status: Int!): Boolean!

  #
  addBillingFrequency(
    frequency: String!
    billingModeId: Int!
    numberOfMonths: Int!
  ): Boolean!

  #
  updateBillingFrequency(
    id: Int!
    frequency: String!
    billingModeId: Int!
    numberOfMonths: Int!
    status: Int!
  ): Boolean!

  #
  addBillingLogic(billingLogic: String!, billingModeId: Int!): Boolean!

  #
  updateBillingLogic(id: Int!, billingModeId: Int!, status: Int!): Boolean!

  #
  addAccessoryType(
    accessoryName: String!
    version: Float!
    description: String
    manufacturerId: Int!
  ): Boolean!

  #
  updateAccessoryType(
    id: Int!
    accessoryName: String!
    version: Float!
    description: String
    manufacturerId: Int!
    status: Int!
  ): Boolean!

  #
  addAccessoryTypePartnerAssignDetail(
    manufacturerId: Int!
    partnerLoginId: Int!
    accessoryTypeId: Int!
  ): Boolean!

  #
  addAccessoryDetail(
    serialNumber: Int!
    uniqueAccessoryId: String!
    accessoryTypeId: Int!
    manufacturerId: Int!
    ownerLoginId: Int!
  ): Boolean!

  #
  updateAccessoryDetail(
    serialNumber: Int!
    uniqueAccessoryId: String!
    status: Int!
    accessoryTypeId: Int!
    manufacturerId: Int!
    ownerLoginId: Int!
    oldUniqueAccessoryId: String!
  ): Boolean!

  #
  addAccessoryDetailsFromPartnerAdmin(
    serialNumber: Int!
    uniqueAccessoryId: String!
    accessoryTypeId: Int!
    manufacturerId: Int!
    ownerLoginId: Int!
  ): Boolean!

  #
  addAccessoryPartnerAssignDetail(
    uniqueAccessoryId: String!
    partnerLoginId: Int!
    accessoryTypeId: Int!
  ): Boolean!

  #
  assignAccessoryToClient(
    clientLoginId: Int!
    partnerLoginId: Int!
    uniqueAccessoryId: String!
  ): Boolean!

  #
  addSubscriptions(
    clientLoginId: Int!
    partnerLoginId: Int!
    billingFrequencyId: Int!
    GST: Float!
    softwareQuantity: Int!
    deviceTrackingCharges: Int!
    deviceModelId: Int!
    deviceQuantity: Int!
    hardwareCharges: Int!
    serviceProviderId: Int
    simQuantity: Int
    simCharges: Int
    accessoryTypeId: Int
    accessoryQuantity: Int
    accessoryCharges: Int
    billingStartedFrom: String
    billingPayTill: String
    salesRemarks: String
    accountsRemarks: String
    invoiceLink: String
    bucketName: String
    fileName: String
  ): Boolean!

  #
  updateSubscriptions(
    id: Int!
    clientLoginId: Int!
    billingFrequencyId: Int!
    partnerLoginId: Int!
    softwareQuantity: Int!
    deviceQuantity: Int!
    accessoryQuantity: Int
    simQuantity: Int
    salesRemarks: String
    accountsRemarks: String
    invoiceLink: String
    bucketName: String
    fileName: String
  ): Boolean!

  # Delete a subscription
  deleteSubscription(
    # Subscription id
    id: Int!

    # Client's login id
    clientLoginId: Int!

    # Partner's login id
    partnerLoginId: Int!
  ): Boolean!

  #
  approveOrRejectSubscription(
    clientLoginId: Int!
    paymentId: Int!
    subscriptionId: Int!
    approveOrReject: approveOrReject!
    paidDetails: inputBillingDetails
    paymentMode: paymentMode
    bankName: String
    referenceNumber: String
    paymentRemarks: String
  ): Boolean!

  #
  addAreaType(areaTypeName: String!): Boolean!

  #
  updateAreaType(id: Int!, areaTypeName: String!, status: Int!): Boolean!

  #
  addArea(
    areaName: String!
    areaTypeId: Int!
    clientLoginId: Int!
    geoJson: String!
    geoPosition: String
  ): areaResult!

  # Add the new AOI. ClientloginId is fetched from token.Exposed to client.
  addAreaAPI(
    # Name of the AOI to be added
    areaName: String!

    # geoJson of type String.Format of the geoJson is -- {"type":"Circle","radius":radiusAbove25mtrs,"coordinates":[lat,long]}
    geoJson: String!
  ): addAreaResponse!

  # Add the new AOI. ClientloginId is fetched from token.Exposed to client.
  addAreaGeoFenceAPI(
    # Name of the AOI to be added
    areaName: String!

    # Type of area. Possible values are Circle and Poygon
    areaType: areaType!

    # Radius is compulsary if area type is Circle. Radius sholud be above 25 mtrs
    radius: Int

    # Single lat long for Circle and more than 3 lat long for Polygon. First lat
    # long and last lat long should be same for Polygon.
    coordinates: [lat_Long!]!
  ): AreaGeoFenceResponse!

  #
  editAreaGeoFenceAPI(
    # Id of the area.
    areaId: Int!

    # Name of the AOI to be replaced.
    areaName: String!

    # Type of area. Possible values are Circle and Poygon
    areaType: areaType!

    # Radius is compulsary if area type is Circle. Radius sholud be above 25 mtrs
    radius: Int

    # Single lat long for Circle and more than 3 lat long for Polygon. First lat
    # long and last lat long should be same for Polygon.
    coordinates: [lat_Long!]!
  ): AreaGeoFenceResponse!

  # Edit the existing area. ClientloginId is fetched from token. Exposed to client.
  editAreaAPI(
    # Id of the area to be edited.
    areaId: Int!

    # Name of the AOI to be edited.If pass old areaname if dont want to edit.
    areaName: String!

    # geoJson of type String.Format of the geoJson is -- {"type":"Circle","radius":radiusAbove25mtrs,"coordinates":[lat,long]}
    geoJson: String!
  ): editedAreaResponse!

  # Delete the existing area of the client. ClientLoginId is fetched from token. Exposed to client.
  deleteAreaGeofenceAPI(
    # Id of the area to be deleted.
    areaId: Int!
  ): DeletedAreaGeoFence!

  #
  deleteGeofence(
    vin: String!
    app_user_id: String!
    geofence_id: [Int!]!
  ): DetetedGeoFenceResponse

  #
  updateArea(
    id: Int!
    areaName: String!
    areaTypeId: Int!
    clientLoginId: Int!
    geoJson: String!
    geoPosition: String
    status: Int!
  ): Boolean!

  # Delete AOI which is not used anywhere
  deleteUnusedAOI(
    # AOI's unique id
    id: Int!
  ): Boolean!

  #
  editArea(areaId: Int!, edits: AreaEdit!): AreaUpdationStatus!

  #
  assingVehiclesToAOI(
    areaId: Int!
    vehicleList: [vehicleNum!]
    email: String
    sms: String
  ): AOI_Status

  #
  deAssignVehiclesFromAOI(
    areaId: Int!
    vehicleList: [vehicleNum!]
  ): deAssign_STATUS

  #
  setGeofenceOld(
    userId: String!
    centerLat: Float
    centerLng: Float
    radius: Int
    type: geofenceType!
    polygonCoordinates: [lat_Long]
    geofenceName: String!
  ): geofenceResponse!

  #
  setGeofence(
    # Userid must be app_user_id
    userId: String!

    # Vehicle identification number associated with the userId
    vin: String!

    # Particular name must be give to set geofence
    geofenceName: String!

    # circularPosition and radius must be provided
    circularGeofence: CircularGeofences

    # required geofenceType circle or polygon
    geofenceType: geofenceType!

    # coordinate and polygonposition must be provided
    polygonGeofence: PolygonGeofences

    # recipient id  must be phonenumber
    recipients: [String]!
  ): geofenceResponses!

  #
  editGeofenceOld(
    geofenceId: Int!
    userId: String!
    geofenceType: editType!
    centerLat: Float
    centerLng: Float
    radius: Int
    polygonCoordinates: [lat_Long]
    geofenceName: String
    recipients: [String]!
    alertStatus: Int!
  ): editGeofenceOldResponse!

  #
  editGeofence(
    geofenceId: Int!
    userId: String!
    vin: String!
    geofenceName: String!
    circularGeofence: CircularGeofences
    geofenceType: geofenceType!
    polygonGeofence: PolygonGeofences
    recipients: [String]!
    alertStatus: Boolean!
  ): editGeofenceResponse!

  #
  removeGeofence(geofenceid: Int!): RemoveGeofenceResponse!

  #
  addVehicleToGeofence(
    geofenceId: Int!
    vin: [String!]
  ): AddVehicleToGeofenceResponse!

  #
  removeVehicleFromGeofence(
    geofenceId: Int!
    vin: [String!]
  ): RemoveVehicleFromGeofenceResponse!

  #
  addSecondaryUser(
    vin: String!
    secondary_app_user_id: String!
    user_name: String!
    email: String!
    iso_code: ISO_CODES!
    mobile_number: String!
  ): secondaryUserResponse

  #
  removeUserVehicleAssociation(
    vin: String!
    primary_app_user_id: String!
    app_user_ids: [String!]!
  ): removeSecondaryUsersResponse!

  #
  updateUserDetails(
    app_user_id: String!
    user_name: String!
    email: String!
    mobile_number: String!
    iso_code: ISO_CODES!
  ): updateUserDetailsResponse!

  #
  updatePrimaryUser(
    vin: String!
    old_primary_app_user_id: String!
    new_primary_app_user_id: String!
    user_name: String!
    mobile_number: String!
    iso_code: ISO_CODES!
    email: String!
  ): updatePrimaryUserResponse!

  #
  updateVinDetails(
    vin: String!
    vehicle_nick_name: String
    sale_date: String
    vehicle_registration_number: String
    description: String
    vehicle_colour: String
    imei_number: String
    phone_number: String
    sim_number: String
    variant_id: String
  ): updateVinDetailsResponce

  #
  updateNonOwnerStatus(
    vin: String!
    app_user_id: String!
    status: String!
    command: String!
  ): CommandStatusResponse

  #
  addRoute(
    areaTypeId: Int!
    areaName: String!
    clientLoginId: Int!
    routeDetail: String!
    places: String!
    placeCoordinates: String!
    areaTypeBuffer: String!
    aoiFenceBuffer: String!
    geoJson: String!
    areaIds: [Int]!
  ): Boolean!

  #
  deleteUnusedRoute(routeId: Int!): Boolean!

  #
  editRoute(routeId: Int!, edits: RouteEdit!): RouteUpdationStatus!

  #
  setSubscriptionInventoryAssignment(
    uniqueDeviceIdList: [uniqueDeviceIdListInput!]
    uniqueAccessoryIdList: [uniqueAccessoryIdListInput!]
    simList: [simListInput!]
    deviceModelId: Int!
    accessoryTypeId: Int
    serviceProviderId: Int
    unAssignedDeviceQuantity: Int!
    unAssignedAccessoryQuantity: Int!
    unAssignedSimQuantity: Int!
    partnerLoginId: Int!
    clientLoginId: Int!
    subscriptionId: Int!
  ): Boolean!

  #
  addDeviceService(uniqueDeviceId: String!, isActivated: Boolean!): Boolean!

  #
  deviceActivateDeactivateService(
    uniqueDeviceId: String!
    type: String!
    reason: String!
  ): String!

  # Add new trip
  addTrip(
    # Trip's Geo Json
    geoJson: [GeoJsonInput!]

    # Name of the trip
    tripName: String!

    # Logged in client's id
    clientLoginId: Int!

    # Trip's route id
    routeId: Int!

    # Trip's starting time in epoch
    fromTimestamp: String!

    # Trip's scheduled from time in epoch
    scheduleFromTimestamp: String!

    # Trip's ending time in epoch
    toTimestamp: String!

    # Trip's scheduled To time in epoch
    scheduleToTimestamp: String!

    # Trip's tolerance in seconds
    tolerance: Int!

    # List of mobile numbers to send trip creation sms
    sms: [String]

    # List of email addresses to send trip creation emails
    email: [String]

    # Unique vehicle id
    uniqueDeviceId: String!

    # Schedule value of trip. A decimal notation of binary representation of week days
    schedule: Int!

    # Type of trip, such as PICKUP or DROP
    tripType: TripType
  ): Boolean!

  #
  addTripWithRoute(
    # Logged in client's id
    clientLoginId: Int

    # Trip's starting time in epoch
    fromTimestamp: String!

    # Trip's ending time in epoch
    toTimestamp: String!

    # Trip's tolerance in seconds
    tolerance: Int!

    # List of mobile numbers to send trip creation sms
    sms: [String]

    # List of email addresses to send trip creation emails
    email: [String]

    # Unique vehicle id
    uniqueDeviceId: String!

    # Schedule value of trip. A decimal notation of binary representation of week days
    schedule: Int!

    # Trip's geo fence details
    geoFenceDetails: [areaIds!]!
  ): Boolean!

  #
  updateSubTripStatus(tripId: Int!, alertType: String!): Int

  #
  updateTripStatusByTripId(id: Int!, status: Int!): Boolean!

  #
  deleteScheduledTrips(clientLoginId: Int!, id: Int): Boolean!

  #
  updateWSOTrip(areaId: Int!, tripId: Int!, alertFlag: Int!): Boolean!

  # Add trip with halt time for AOIs
  addTripWithHaltTime(
    # Trip start time in epoch
    fromTimestamp: String!

    # Trip end time in epoch
    toTimestamp: String!

    # Trip tolerance in seconds
    tolerance: Int

    # List of numbers to send notifications to
    sms: [String]

    # List of emails to send notifications to
    email: [String]

    # Unique device id
    uniqueDeviceId: String!

    # Trip's geo fence details
    geoFenceDetails: [geoFenceWithHalt!]!
  ): Trip!

  #
  completeTrip(tripId: Int!): TripUpdationStatus!

  #
  pauseTrip(tripId: Int!): TripUpdationStatus!

  #
  resumeTrip(tripId: Int!): TripUpdationStatus!

  #
  deleteTrip(tripId: Int!): TripUpdationStatus!

  #
  editTrip(tripId: Int!, edits: TripEdit!): TripUpdationStatus!

  # Add new student or update existing student's details
  addOrUpdateStudent(
    # Student's name
    studentName: String!

    # Student's gender
    gender: String!

    # Student's email address
    email: String

    # Student's contact name
    contactNumber: String!

    # Student's secondary contact
    secondaryContactNumber: String

    # Student's pickup trip id
    pickupTripId: [Int]

    # Student's drop trip id
    dropTripId: [Int]

    # Client's login id
    clientLoginId: Int!

    # Student's RFID
    rfid: String

    # Student's address
    address: String

    # Student's status
    status: Int

    # Student's unique id
    studentId: Int

    # Student's AOI pickup id
    aoiPickup: Int

    # Student's AOI drop id
    aoiDrop: Int

    # Student's school id
    schoolId: Int

    # Check if sms is enabled
    smsEnabled: Boolean

    # School's student unique id
    schoolStudentId: String

    # Student's course name
    courseName: String
  ): Boolean!

  # Update student's address details
  updateStudentAddress(
    studentId: Int!
    pickUpLocation: InputLocation
    dropLocation: InputLocation
  ): Boolean!

  # Assign stops to students
  assignStopsToStudents(
    # List of student stops
    studentStops: [StudentStops!]!

    # Client's login id
    clientLoginId: Int!
  ): Boolean!

  # Delete a studen
  deleteStudent(
    # Student's unique id
    studentId: [Int!]
  ): Boolean!

  # Deassign a stop from the student
  deassignStopToStudent(
    # Client's login id
    clientLoginId: Int!

    # Student's unique id
    studentId: Int!
  ): Boolean!

  # Update student details
  updateStudent(
    # Student's number (i.e. school's student unique id)
    studentNumber: String!

    # Student's branch code (i.e. school name)
    branchCode: String

    # Student's name
    studentName: String

    # Student's course name
    courseName: String

    # Student's pickup route name
    pickupRoute: String

    # Student's drop route name
    dropRoute: String

    # Student's pickup stop name
    pickupStop: String

    # Student's drop stop name
    dropStop: String

    # Student's primary contact number
    primaryContactNumber: String

    # Student's secondary contact number
    secondaryContactNumber: String

    # Student's address
    address: String
  ): Boolean!

  #
  addSchoolRouteAndAreas(
    routeName: String!
    clientLoginId: Int!
    routeDetails: [RouteDetailInput!]!
    routeType: String!
  ): Boolean!

  #
  addSchoolTrip(
    tripName: String!
    clientLoginId: Int!
    routeId: Int!
    tripType: String!
    schedulingFrequency: String!
    scheduledDays: ScheduledDaysList!
    tolerance: Int!
    stoppageTime: Int!
    schoolTime: String!
  ): Boolean!

  #
  updateSchoolTrip(
    id: Int!
    tripName: String!
    clientLoginId: Int!
    routeId: Int!
    tripType: String!
    schedulingFrequency: String!
    scheduledDays: ScheduledDaysList!
    tolerance: Int!
    stoppageTime: Int!
    schoolTime: String!
    status: Int!
  ): Boolean!

  #
  excelFileUpload(
    fileInfo: FileUploadInput!
    commonInput: CommonInput!
  ): FileUploadResponse!

  #
  addLicenseType(
    licenseType: String!
    description: String!
    featureList: String!
    maxPrice: Int!
  ): Boolean!

  #
  updateLicenseType(
    id: Int!
    licenseType: String!
    description: String!
    featureList: String!
    maxPrice: Int!
    status: Int!
  ): Boolean!

  #
  updateResellerDomainConfig(loginId: Int!, domain: String!): Boolean!

  #
  setResellerDetails(
    id: Int
    username: String
    password: String
    accountType: String
    resellerName: String!
    email: String!
    contactPerson: String!
    contactNumber: String!
    loginId: Int
    address: String!
    city: String!
    stateId: Int!
    countryId: Int!
    pincode: Int!
    panNumber: String!
    gst: String!
    freePeriod: Int!
    bufferPeriod: Int!
    discountPercentage: Int!
    defaultBillingFrequency: Int!
    licenseExpiryPeriod: Int!
    assignedDeviceModel: [AssignDeviceModelToReseller!]!
    assignedLicenseType: [AssignLicenseTypeToReseller!]!
    status: Int!
  ): Boolean!

  #
  raisePurchaseRequest(
    licenseTypeList: [LicenseTypeRequest!]!
    deviceModelList: [DeviceModelRequest!]!
    resellerLoginId: Int!
  ): Boolean!

  #
  revertPurchaseRequestWithFinalPrice(
    purchaseRequestId: Int!
    licenseTypeList: [LicenseTypeRequest!]!
    deviceModelList: [DeviceModelRequest!]!
    isPreApproved: Boolean!
  ): Boolean!

  #
  resellerApprovalForFinalPrice(
    purchaseRequestId: Int!
    isApproved: Boolean!
  ): Boolean!

  #
  processPurchaseRequest(
    resellerLoginId: Int!
    licenseExpiryPeriod: Int!
    purchaseRequestId: Int!
    processedDeviceList: [processedDeviceList!]!
    processedLicenseTypeList: [processedLicenseTypeList!]!
    licenseTypeList: [LicenseTypeRequest!]!
    deviceModelList: [DeviceModelRequest!]!
    isPartialProcessed: Boolean!
  ): Boolean!

  #
  addDeviceResellerAssignDetail(
    purchaseRequestId: Int!
    deviceList: [DeviceListInput!]!
    resellerLoginId: Int!
    deviceModelId: Int!
  ): Boolean!

  #
  assignDevicesToResellerClient(
    clientLoginId: Int!
    resellerLoginId: Int!
    uniqueDeviceId: String!
  ): Boolean!

  #
  addSimResellerAssignDetail(
    simId: Int!
    resellerLoginId: Int!
    serviceProviderId: Int!
  ): Boolean!

  #
  assignSimToResellerClient(
    clientLoginId: Int!
    resellerLoginId: Int!
    simId: Int!
  ): Boolean!

  #
  addResellerSubscriptions(
    clientLoginId: Int!
    resellerLoginId: Int!
    billingModeId: Int!
    billingFrequencyId: Int!
    billingLogicId: Int
    billingDay: Int!
    gst: Float!
    deviceModelId: Int!
    deviceQuantity: Int!
    unAssignedDeviceQuantity: Int!
    licenseTypeId: Int
    licenseQuantity: Int
    unAssignedLicenseQuantity: Int
    serviceProviderId: Int
    simQuantity: Int
    unAssignedSimQuantity: Int
    amount: Int!
    totalAmount: Int!
  ): Boolean!

  #
  updateResellerSubscriptions(
    id: Int!
    clientLoginId: Int!
    resellerLoginId: Int!
    billingModeId: Int!
    billingFrequencyId: Int!
    billingLogicId: Int
    billingDay: Int!
    gst: Float!
    deviceModelId: Int!
    deviceQuantity: Int!
    unAssignedDeviceQuantity: Int!
    licenseTypeId: Int
    licenseQuantity: Int
    unAssignedLicenseQuantity: Int
    serviceProviderId: Int
    simQuantity: Int
    unAssignedSimQuantity: Int
    amount: Int!
    totalAmount: Int!
    status: Int!
  ): Boolean!

  #
  setResellerSubscriptionInventoryAssignment(
    uniqueDeviceIdList: [uniqueDeviceIdListInput!]
    simList: [simListInput!]
    licenseList: [licenseListInput!]
    deviceModelId: Int!
    serviceProviderId: Int
    licenseTypeId: Int
    unAssignedDeviceQuantity: Int!
    unAssignedSimQuantity: Int!
    unAssignedLicenseQuantity: Int
    resellerLoginId: Int!
    clientLoginId: Int!
    subscriptionId: Int!
  ): Boolean!

  # This API is used to configure sms balance to partner login,later can assign sms to its clients.
  addsmsPurchaseHistorySuperAdmin(
    # From login id will be superadmin login id.
    fromLoginId: Int!

    # From account type is super admin account type.
    fromAccountType: String!

    # Partner or reseller login id
    toLoginId: Int!

    # Partner or reseller account type.
    toAccountType: String!

    # Key is used by sms infiny(sms gateway)
    key: String

    # Cliend id is same as sender id. Used in sms infiny and etech-keys sms gateways
    clientId: String

    # Types of sms gateways. Possible gateways are GUPSHUP,SMSINFINY,ETECH_KEYS
    sms_gateway: smsGateways!

    # Username used in sms infiny and etech-keys sms gateways
    username: String

    # Password used in sms infiny and etech-keys sms gateways
    password: String

    # Possible values are Credit and Debit
    transactionType: String!

    # It is optional.For the future use.
    status: Int

    # Sms balance to be added or removed.
    smsCount: Int!
  ): Boolean!

  # This API is used to configure sms balance to its clients from partner.
  addsmsPurchaseHistoryRESAndPRT(
    # From login id will be partner login id.
    fromLoginId: Int!

    # From account type is partner account type.
    fromAccountType: String!

    # Clientlogin id
    toLoginId: Int!

    # Client account type
    toAccountType: String!

    # Key is used by sms infiny(sms gateway)
    key: String

    # Cliend id is same as sender id. Used in sms infiny and etech-keys sms gateways
    clientId: String

    # Types of sms gateways. Possible gateways are GUPSHUP,SMSINFINY,ETECH_KEYS
    sms_gateway: smsGateways!

    # Username used in sms infiny and etech-keys sms gateways
    username: String

    # Password used in sms infiny and etech-keys sms gateways
    password: String

    # Possible values are Credit and Debit
    transactionType: String!

    # It is optional.For the future use.
    status: Int

    # Sms balance to be added or removed.
    smsCount: Int!
  ): Boolean!

  #
  updatesmsPurchaseHistory(
    id: Int!
    fromLoginId: Int!
    fromAccountType: String!
    toLoginId: Int!
    toAccountType: String!
    transactionType: String!
    status: Int
    smsCount: Int!
  ): Boolean!

  #
  decrementSMSBalance(loginId: Int!): Boolean!

  #
  addPacketsCount(
    deviceUniqueId: String!
    clientLoginId: Int!
    noOfPackets: Int!
  ): Boolean!

  #
  monthlyBillGenerator(
    fromTimestamp: Int!
    raiseBills: Boolean
    updateSubscriptions: Boolean
  ): Boolean

  #
  raiseInvoices(ids: [Int!]!, isInvoice: Boolean!): Boolean!

  #
  updateAndRaiseInvoice(
    id: Int!
    paymentStatus: Int!
    invoiceAmount: Int
    discount: Int
    serviceRemarks: String
    accountRemarks: String
  ): Boolean!

  #
  makePayment(
    paymentId: Int!
    totalAmountPaid: Int!
    simAmountPaid: Int!
    softwareAmountPaid: Int!
    accessoryAmountPaid: Int!
    hardwareAmountPaid: Int!
    accountRemarks: String
    paymentMode: paymentMode!
    paymentStatus: Int!
    bankName: String
    referenceNumber: String
    chequeDate: String
    simExpectedDate: String
    softwareExpectedDate: String
    hardwareExpectedDate: String
    accessoryExpectedDate: String
  ): Boolean

  #
  makePartnerPayment(
    paymentId: Int!
    totalAmountPaid: Int!
    simAmountPaid: Int!
    softwareAmountPaid: Int!
    accessoryAmountPaid: Int!
    hardwareAmountPaid: Int!
    accountRemarks: String
    paymentMode: paymentMode!
    paymentStatus: Int!
    bankName: String
    referenceNumber: String
    chequeDate: String
    simExpectedDate: String
    softwareExpectedDate: String
    hardwareExpectedDate: String
    accessoryExpectedDate: String
  ): Boolean

  #
  saveInvoiceDetails(
    id: Int!
    bucketName: String!
    fileName: String!
    isInvoice: Boolean!
  ): Boolean!

  #
  addUpdateClientCredits(
    clientLoginId: Int!
    subscriptionId: Int!
    minimumAmountDue: Float!
    partnerLoginId: Int
    paidMoney: Float!
    paymentMode: String!
    bankName: String
    referenceNumber: Int
    accountRemarks: String
    noOfDevices: Int
    status: Int!
  ): String!

  #
  updatePaymentDetails(
    id: Int!
    clientLoginId: Int!
    paidMoney: Int!
    paymentMode: String!
    bankName: String
    chequeDate: String
    referenceNumber: Int
    remarks: String
    billPaidDate: String!
    discount: Int
    paymentType: PaymentType!
  ): String!

  #
  addHaltAlertConfig(
    panicType: Int!
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
  ): Boolean!

  #
  addMultipleHaltAlertConfig(
    clientLoginId: Int!
    uniqueDeviceId: [String!]!
    fromTimestamp: String!
    toTimestamp: String!
    haltTime: Int!
    email: String!
    sms: String!
  ): String!

  #
  updateHaltAlertConfig(
    id: Int!
    panicType: Int!
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
    status: Int!
  ): Boolean!

  #
  createEditSchool(
    clientLoginId: Int!
    schoolId: Int
    schoolName: String!
    areaTypeId: Int
    geoJson: String
    geoPosition: String
    userLoginId: Int
    address: String
  ): Boolean!

  #
  deleteSchool(schoolId: Int!): Boolean!

  #
  addIdleAlertConfig(
    panicType: Int!
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
  ): Boolean!

  #
  addMultipleIdleAlertConfig(
    clientLoginId: Int!
    uniqueDeviceId: [String!]!
    fromTimestamp: String!
    toTimestamp: String!
    idleTime: Int!
    email: String!
    sms: String!
  ): String!

  #
  updateIdleAlertConfig(
    id: Int!
    panicType: Int!
    clientLoginId: Int!
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
    status: Int!
  ): Boolean!

  #
  createPartnerSubscription(
    partnerLoginId: Int!
    billingFrequencyId: Int!
    GST: Float!
    deviceModelId: Int!
    hardwareQty: Int!
    hardwareCharges: Int!
    softwareQty: Int!
    softwareTrackingCharges: Int!
    serviceProviderId: Int
    simQty: Int!
    simCharges: Int!
    accessoryTypeId: Int
    accessoryQty: Int!
    accessoryCharges: Int!
    salesRemarks: String
    accountsRemarks: String
  ): Boolean

  # Update the existing partner subscription. Only quantity of hardware
  updatePartnerSubscriptions(
    #
    partnerSubscriptionId: Int!

    #
    partnerLoginId: Int!

    #
    billingFrequencyId: Int!

    # Total hardware quantity with old hardware count + new hardware count.
    hardwareQuantity: Int!

    # Total software quantity with old software count + new software count.
    softwareQuantity: Int!

    # Total Sim quantity with old Sim count + new Sim count.
    simQuantity: Int!

    # Total accessory quantity with old accessory count + new accessory count.
    accessoryQuantity: Int!
  ): Boolean!

  #
  approveOrRejectPartnerSubscription(
    partnerLoginId: Int!
    paymentId: Int!
    partnerSubscriptionId: Int!
    approveOrReject: approveOrReject!
    paidDetails: inputBillingDetails
    paymentMode: paymentMode
    bankName: String
    referenceNumber: String
    accountsRemarks: String
  ): Boolean

  #
  assignSchoolAlertsToClient(
    clientLoginId: Int!
    configAlerts: [configAlerts!]!
  ): Boolean!

  #
  tripCompletion(tripId: Int!): Boolean!

  #
  addOrUpdateClientEmailLimit(loginId: Int!, limit: Int!, count: Int!): Boolean!

  #
  decrementEmailCount(loginId: Int!): Boolean!

  #
  updateDefaultEmailLimitAllLogins: Boolean!

  #
  addSalesPerson(
    personName: String!
    contactNumber: String!
    email: String!
    address: String
    partnerLoginId: Int
    clientLoginId: Int
  ): String!

  #
  updateSalesPerson(
    id: Int!
    personName: String!
    contactNumber: String!
    email: String!
    address: String
    partnerLoginId: Int!
    clientLoginId: Int!
  ): String!

  #
  runBillingDailyCron(customers: String): String!

  # Sync third party api's data
  syncThirdPartyAPIData(
    # Type of script to run
    scriptType: ScriptType!

    # Partner's unique login id
    partnerLoginId: Int

    # Client's unique login id
    clientLoginId: Int
  ): SyncDataResponse!

  #
  addDeviceSimMapping(
    vehicleIdentificationNumber: String!
    deviceSerialNo: String!
    deviceImeiNo: String!
    deviceModel: DeviceModels
    phoneNumber: String!
    simNumber: String!
    serviceProvider: ServiceProviders
    clientLoginId: Int
  ): deviceSimMapped!

  #
  updateDeviceSimMapping(
    vehicleIdentificationNumber: String!
    deviceSerialNo: String
    deviceImeiNo: String
    deviceModel: DeviceModels
    phoneNumber: String
    simNumber: String
    serviceProvider: ServiceProviders
    clientLoginId: Int
    status: Int
  ): Boolean

  #
  updatevehicleIdentificationNumber(
    deviceSerialNo: String!
    vehicleIdentificationNumber: String!
  ): Boolean

  #
  deleteDeviceSimMapping(vehicleIdentificationNumber: String!): Boolean!

  # Add vehicle maintenance data
  addVehicleMaintDetails(maintDetails: VehicleMaintInput!): Boolean!

  # Add icons for client
  addIcon(iconsList: [Icons]!): Boolean!

  # Delete an icon
  deleteIcon(id: Int!): Boolean!

  #
  addClientPids(pidsConfig: [pidConfig!]!): Boolean!

  #
  removeClientPids(clientLoginId: Int!, pid: String!): Boolean!

  #
  setSparePartReplacement(
    sparePartConfigs: [SparePartConfig!]
    clientLoginId: Int
  ): Boolean!

  #
  addEmailTemplate(
    emailTemplateConfigs: [EmailTemplateConfig!]
    clientLoginId: Int!
  ): Boolean!

  #
  addEmailConfig(emailConfigs: [EmailConfig!]): Boolean!

  #
  addEmailIdsFlorAlert(emailId: String!, type: String!, status: Int!): String!

  #
  updateEmailidsForAlerts(
    id: Int!
    emailId: String!
    type: String!
    status: Int
  ): String!

  #
  uploadFile(file: Upload!, vehicleNumber: String!): File!

  #
  addCommonField(
    fieldId: String!
    fieldName: String!
    unit: String
    fieldDescription: String!
    status: Int
  ): Boolean!

  #
  updateCommonField(
    fieldId: String!
    fieldName: String!
    unit: String
    fieldDescription: String!
    status: Int
  ): Boolean!

  #
  addGraphToClient(
    graphName: String!
    graphAxisData: AxisData!
    graphMinThreshold: Int
    graphMaxThreshold: Int
  ): Boolean!

  #
  deleteGraphAPI(id: Int!): Boolean!

  #
  addMultipleTempAlertConfig(
    minTemp: Int!
    maxTemp: Int!
    clientLoginId: Int!
    userLoginId: Int
    uniqueDeviceId: [String!]!
    fromTimestamp: String!
    toTimestamp: String!
    email: String!
    sms: String!
  ): String!

  #
  updateTempAlertConfig(
    id: Int!
    minTemp: Int!
    maxTemp: Int!
    clientLoginId: Int!
    userLoginId: Int
    uniqueDeviceId: String!
    fromTimestamp: String!
    toTimestamp: String!
    email: String
    sms: String
    status: Int!
  ): Boolean!

  #
  addDistrict(name: String!): Boolean!

  #
  addTalukName(name: String!, district_id: Int!): Boolean!

  #
  addVillageName(name: String!, taluk_id: Int!, district_id: Int!): Boolean!

  #
  addPanchayatName(name: String!, taluk_id: Int!, district_id: Int!): Boolean!

  #
  setClientReports(
    clientLoginId: Int!
    selectedReport: [reports!]!
  ): returnMessage!

  #
  activateSim(simDOList: [simDOList!]!): ActivateSimResponse

  #
  shareLiveLocation(
    vin: String!
    shared_by_app_user_id: String!
    map_provider: Maps
    share_name: String
    shared_to_emails: [String!]!
    shared_to_sms: [countryCode_phoneNumber!]!
    shared_to_app_user_ids: [String!]!
    time_to_share_till: String
    destination: [lat_long_destination!]!
  ): ShareLiveLocationResponse

  #
  stopLiveLocation(
    request_id: Int!
    vin: String!
    app_user_id: String
  ): stopLiveLocationResponse

  #
  addEmergencyContacts(
    app_user_id: String!
    vin: String!
    contacts_details: [contacts_detailsRequest]!
  ): addEmergencyContactsResponse

  #
  updateEmergencyContacts(
    app_user_id: String!
    vin: String!
    emergency_contact_id: String!
    emergency_contact_name: String!
    iso_code: ISO_CODES!
    emergency_mobile_number: String!
    email_id: String
  ): updateEmergencyContactsResponse

  #
  deleteEmergencyContacts(
    app_user_id: String!
    vin: String!
    emergency_contact_id: [String!]!
  ): deleteEmergencyContactsResponse

  #
  setOfflineMaps(
    vin: String!
    map1: String
    size1: Float
    map2: String
    size2: Float
  ): ResultDetails

  #
  onboardHomecharger(
    hc_imei: String!
    vin: String!
    primary_bat_a_uid: String!
    primary_bat_b_uid: String!
    secondary_batteries_uid: [secondary_batteries_uid]
  ): onboardHomechargerResponse

  #
  _: String!

  #
  addDomainConfiguration(
    domain: String!
    header: JSON!
    page: JSON
    customPage: Boolean!
    customPageId: String
  ): DomainConfiguration

  #
  updateDomainConfiguration(
    domain: String!
    header: JSON
    page: JSON
    customPage: Boolean
    customPageId: String
  ): Boolean

  #
  addUserConfiguration(
    loginId: Int!
    theme: JSON!
    configuration: JSON!
  ): UserConfigData

  #
  updateUserConfiguration(
    loginId: Int!
    theme: JSON
    configuration: JSON
  ): Boolean

  #
  getPublicUploadURL(fileExtension: String!): UploadFile!

  # Insert a fcmToken,clientLoginId or update FCM settings
  updateClientFcmSettings(input: FcmTokenInput!): ClientFcmToken!

  # Delete fcmToken, clientLoginId from DB
  unregisterClientFcmToken(input: FcmTokenInput!): ClientFcmToken!

  # Insert a fcmToken,clientLoginId or update FCM settings
  updateTheClientFcmSettings(
    #
    fcmToken: String!

    #
    platform: PLATFORM!

    #
    app_user_id: String!

    # enabled is true by default. Setting this false will not send fcm notifications to this client
    enabled: Boolean!
  ): updateTheClientFcmSettingsResponse

  # Delete fcmToken, clientLoginId from DB
  unregisterTheClientFcmToken(
    fcmToken: String!
    platform: PLATFORM!
    app_user_id: String!
  ): unregisterTheClientFcmTokenResponse

  #
  updateAlertViewStatus(
    uniqueId: String!
    alerttype: String!
    from_ts: String!
    view_status: Boolean!
  ): Message

  #
  raiseSOSAlert(vin: String!, app_user_id: String!): RaiseSOSAlertRespone

  #
  stopSoSAlert(
    vin: String!
    app_user_id: String
    event_id: String!
  ): stopSOSAlertResponse

  #
  updateDeviceCommandsTable(
    uniqueId: String!
    command: String!
    device_password: String!
    use_sms: Boolean
  ): Message

  #
  deleteActiveCommand(uniqueId: String!, command: String!): Message_Response

  #
  setCommandsToQueue(
    vin: String
    app_user_id: String
    hc_imei: String
    device_type: deviceTypeEnum!
    command_type: commandTypeEnum!
    commandSource: commandSource_Enum!
    commandArguments: commandArgument!
    sequence_number: String
  ): CommandsToQueueResponse

  #
  setVehicleSettings(
    commandSource: commandSource_Enum
    vin: String!
    app_user_id: String!
    settings: SettingsInput
  ): VehicleCommandResponse

  #
  setHomeChargerSettings(
    commandSource: commandSource_Enum
    vin: String!
    settings: SettingsInputForHomeCharger
  ): setHomeChargerSettingsResponse

  #
  deleteFavoriteLocation(
    # userId will be phone number,taking from simDetails
    fromUserId: String!

    # vehicle Identification Number
    vin: String!

    # placeId length range should be 3 to 255
    placeId: String!
  ): statusMessageRespons

  #
  deleteSharedDestination(
    # userId will be phone number,taking from simDetails
    fromUserId: String!

    # vehicle Identification Number
    vin: String!

    # placeId length range should be 3 to 255
    placeId: String!
  ): statusMessageRespons

  #
  deleteRecentLocation(
    # userId will be phone number,taking from simDetails
    fromUserId: String!

    # vehicle Identification Number
    vin: String!

    # placeId length range should be 3 to 255
    placeId: String!
  ): statusMessageRespons

  #
  editFavoriteLocation(
    # placeId length range should be 3 to 255
    placeId: String!

    # checking uniqueness with vin,userId ,placeId
    user_generated_name: String!

    # userId will be phone number,taking from simDetails
    fromUserId: String!

    # vehicle Identification Number
    vin: String!

    # Location Type: home, work or other.
    location_type: locationTypeEnum
  ): statusMessageRespons

  #
  shareDestination(
    # min:3 and max:200 of locationName
    locationName: String

    # userId will be phone number,taking from simDetails
    fromUserId: String!

    # userId will be phone number,taking from simDetails
    toUserId: String!

    # vehicle Identification Number
    vin: String!

    # placeId length range should be 3 to 255
    placeId: String

    # lat and long of the location
    lat_long: [lat_longRes]!

    # address of the location
    address: String!
  ): statusMessageRespons!

  #
  addFavoriteLocation(
    # min:3 and max:200 of locationName
    locationName: String

    # checking uniqueness with vin,userId ,placeId
    user_generated_name: String!

    # userId will be phone number,taking from simDetails
    fromUserId: String!

    # vehicle Identification Number
    vin: String!

    # lat and long of the location
    lat_long: lat_longRes!

    # placeId length range should be 3 to 255
    placeId: String

    # address of the location
    address: String!

    # Location Type: home, work or other.
    location_type: locationTypeEnum
  ): statusResponse

  #
  addRecentLocation(
    # min:3 and max:200 of locationName
    locationName: String

    # userId will be phone number,taking from simDetails
    fromUserId: String!

    # vehicle Identification Number
    vin: String!

    # lat and long of the location
    lat_long: lat_longRes!

    # placeId length range should be 3 to 255
    placeId: String

    # address of the location
    address: String!
  ): statusResponse

  #
  addRide(
    vin: String!
    app_user_id: String!
    vehicleTypeId: Int!
    travelFileName: String
    vehicleModelName: String
    totalTime: Int
    rideTime: Int
    travelStartDateTime: Int
    travelEndDateTime: Int
    totalTravelledDistance: Float
    topSpeed: Float
    averageSpeed: Float
    travelStatsDownloadLink: String
    travelName: String
    isFavourite: Boolean
    type: Int
    travelMMIDownloadLink: String
    startLocation: String
    endLocation: String
    day: String
    currentRideBestLapTime: Int
    currentRideBestLapNumber: Int
    currentRideTotalLapTime: Int
    currentRideTotalLaps: Int
    literPer100KM: Float
    highestAltitude: Float
    lastFuelStatus: Int
    lowestAltitude: Float
    vehicleAvgSpeed: Float
    distanceToEmpty: Float
    mileage: Float
    odometerReading: Float
    batteryVoltage: Float
    cruisingRange: Int
    vehicleBest0to60: Float
    best0To100: Float
    vehicleTopSpeed: Float
    idleTime: Int
    averageRPM: Float
    topSpeedOverAll: Float
    bestShortestTimeSportMode: Float
    totalDistanceOverAll: Float
    totalDuration: Int
    maxAcceleration: Float
    altitude: Float
    maxDeceleration: Float
    temperature: Float
    isCompleted: Boolean
    bestDeceleration: String
    bestAcceleration: String
    rearTyreMacId: String
    frontTyreBattery: Float
    speedoSWVersion: String
    frontTyrePressure: Float
    frontTyreMacId: String
    rearTyrePressure: Float
    rearTyreBattery: Float
    best0To60: Float
    frontTyreTemperature: Float
    rearTyreTemperature: Float
    totalDistanceStreetMode: Float
    weatherShortDescription: String
    isSportMode: Boolean
    weatherIcon: String
    rideTimeRaceMode: Int
    averageSpeedSportMode: Float
    averageSpeedStreetMode: Float
    totalDistanceRaceMode: Float
    lapDistanceSportMode: Float
    averageSpeedRaceMode: Float
    rideTimeStreetMode: Float
    rideTag: Int
    topSpeedRaceMode: Int
    topSpeedSportMode: Float
    isStreetMode: Boolean
    topRPMRaceMode: Float
    isRaceMode: Boolean
    best0to60RaceMode: Float
    userId274140: String
    topSpeedStreetMode: Float
    weatherTemp: Float
    topRPM: Int
    topRPMStreetMode: Float
    best0to60StreetMode: Float
    averageSpeedOverAll: Float
    modes: [ModesResponse]
    gears: [GearsResponse]
    laps: [LapsResponse]
    tour: TourResponse
  ): addRideResponse

  #
  deleteRide(
    vin: String!
    app_user_id: String!
    vehicleTypeId: Int!
    travelId: Int!
    type: Int!
  ): deleteRideResponse

  #
  updateRide(
    vin: String!
    app_user_id: String!
    vehicleTypeId: Int!
    travelId: Int!
    travelName: String
    isFavourite: Boolean
    type: Int!
  ): updateRideResponse
}

#
input inputDevices {
  #
  deviceSerialNo: String!

  #
  deviceImeiNo: String!
}

#
enum SIMPROVIDER {
  #
  airtel

  #
  idea
}

#
enum DEVICEMODEL {
  #
  TS_101_Basic_Hybrid

  #
  OBD2

  #
  TS101

  #
  S101

  #
  U101

  #
  R101

  #
  TS101_Basic

  #
  TS101_Advance

  #
  S101_PLUS_1

  #
  B101V2

  #
  Bharat_101_1

  #
  RE_CONNECT_1

  #
  RE_CONNECT_2
}

#
enum DEVICEMANUFACTURER {
  #
  iTriangle

  #
  MINDA

  #
  DANLAW

  #
  iTriangledemo
}

#
type deviceResponse {
  #
  deviceNumbers: [deviceData!]!

  #
  simProvider: String!

  #
  deviceModel: String!

  #
  deviceManufacturer: String!
}

#
type deviceData {
  #
  deviceSerialNo: String!

  #
  deviceImeiNo: String!
}

#
type deletedDevice {
  #
  deviceSerialNo: String!

  #
  deviceImeiNo: String!
}

#
enum VEHICLETYPES {
  #
  Car

  #
  Bus

  #
  Bike

  #
  Scooter

  #
  Ambulance

  #
  Truck
}

#
type vehicleDetails {
  #
  deviceManufacturer: String!

  #
  deviceModel: String!

  #
  deviceSerialNo: String!

  #
  deviceImeiNo: String!

  #
  simProvider: String!

  #
  simPhoneNumber: String!

  #
  vehicleNumber: String!

  #
  vehicleMake: String!

  #
  vehicleModel: String!

  #
  vehicleType: String!

  #
  overSpeedLimit: Int!

  #
  averageMileage: Int
}

#
type updatedOnBoardedVehicleDetails {
  #
  deviceSerialNo: String!

  #
  deviceImeiNo: String!

  #
  simPhoneNumber: String!

  #
  vehicleNumber: String!

  #
  vehicleMake: String!

  #
  vehicleModel: String!

  #
  vehicleType: String!

  #
  averageMileage: Int!
}

#
input inputSims {
  #
  phoneNumber: String!
}

#
type simResponse {
  #
  simPhoneNumber: [simData!]!

  #
  simProvider: String!

  #
  deviceModel: String!

  #
  deviceManufacturer: String!
}

#
type simData {
  #
  phoneNumber: String!
}

#
enum STATE {
  #
  Andaman_and_Nicobar_Islands

  #
  Andhra_Pradesh

  #
  Arunachal_Pradesh

  #
  Assam

  #
  Bihar

  #
  Chandigarh

  #
  Dadra_and_Nagar_Haveli

  #
  Daman_and_Diu

  #
  Delhi

  #
  Goa

  #
  Gujarat

  #
  Haryana

  #
  Himachal_Pradesh

  #
  Jammu_and_Kashmir

  #
  Karnataka

  #
  Kerala

  #
  Lakshadweep_Islands

  #
  Madhya_Pradesh

  #
  Maharashtra

  #
  Manipur

  #
  Meghalaya

  #
  Mizoram

  #
  Nagaland

  #
  Orissa

  #
  Pondicherry

  #
  Punjab

  #
  Rajasthan

  #
  Sikkim

  #
  Tamil_Nadu

  #
  Tripura

  #
  Uttar_Pradesh

  #
  West_Bengal
}

#
enum COUNTRY {
  #
  India
}

#
enum TIMEZONE {
  #
  Asia_Kolkata
}

#
type ClientDetailsResponse {
  #
  loginId: Int!

  #
  username: String!

  #
  password: String!

  #
  clientName: String!

  #
  email: String!

  #
  contactPerson: String!

  #
  contactNumber: String!

  #
  address: String!

  #
  aadharNumber: String

  #
  gst: String

  #
  city: String!

  #
  state: String!

  #
  country: String!

  #
  pincode: Int

  #
  panNumber: String

  #
  timezone: String!
}

#
type SubLoginDetails {
  #
  username: String!

  #
  password: String!

  #
  accountType: String!

  #
  subLoginName: String!

  #
  email: String

  #
  contactNumber: String!

  #
  subLoginId: Int!

  #
  roleId: Int!

  #
  groupId: Int!
}

#
type validateTokenResponse {
  #
  status: Int!

  #
  statusMessage: String!
}

#
enum action {
  #
  ACTIVATE

  #
  DEACTIVATE
}

#
enum vehicleStatus {
  #
  PENDING

  #
  APPROVED

  #
  REJECT

  #
  OTP_GENERATED
}

#
enum SupportedVehicleTypes {
  #
  Car

  #
  Bus

  #
  Bike

  #
  Scooter

  #
  Ambulance

  #
  Truck
}

#
type deletedVehicleDetails {
  #
  deviceManufacturer: String!

  #
  deviceModel: String!

  #
  deviceSerialNo: String!

  #
  deviceImeiNo: String!

  #
  simProvider: String!

  #
  simPhoneNumber: String!

  #
  vehicleNumber: String!

  #
  vehicleMake: String

  #
  vehicleModel: String!

  #
  vehicleType: String!
}

#
type updatedVehicleDetails {
  #
  vehicleNumber: String!
}

#
enum DeviceManufacturer {
  #
  iTriangle

  #
  MINDA

  #
  DANLAW
}

#
enum VEHICLE {
  #
  Car

  #
  Bus

  #
  Bike

  #
  Scooter

  #
  Ambulance

  #
  Truck
}

#
type VehicleDetails {
  #
  vehicleId: Int

  #
  deviceManufacturer: String

  #
  deviceModel: String

  #
  deviceSerialNo: String

  #
  deviceImeiNo: String

  #
  serviceProvider: String

  #
  phoneNumber: String

  #
  simNumber: String

  #
  vehicleNumber: String!

  #
  vehicleModel: String!

  #
  vehicleIdentificationNumber: String

  #
  vehicleColour: String
}

#
input PrimaryUserDetailsInput {
  #
  app_user_id: String

  #
  username: String

  #
  email: String

  #
  mobile_number: String

  #
  iso_code: ISO_CODES
}

#
type vehicleDetailsReponse {
  #
  response: VehicleDetailsOnBoard

  #
  status: Int

  #
  statusMessage: String
}

#
type VehicleDetailsOnBoard {
  #
  vehicle_id: String

  #
  vin: String

  #
  imei_number: String

  #
  vehicle_registration_number: String

  #
  vehicle_nick_name: String

  #
  codp_model: String

  #
  description: String

  #
  vehicle_colour: String

  #
  vehicle_type_id: Int

  #
  theme: Int

  #
  variant_id: String

  #
  sim_number: String

  #
  phone_number: String

  #
  sim_provider: String

  #
  sale_date_timestamp: String

  #
  primary_user_details: PrimaryUserDetailsResp
}

#
type PrimaryUserDetailsResp {
  #
  app_user_id: String

  #
  username: String

  #
  email: String

  #
  mobile_number: String

  #
  iso_code: String

  #
  country_code: Int
}

#
type UpdateOnBoardedVehicleResponse {
  #
  vehicleId: Int!

  #
  deviceManufacturer: String!

  #
  deviceModel: String!

  #
  deviceSerialNo: String!

  #
  deviceImeiNo: String!

  #
  phoneNumber: String!

  #
  simNumber: String!

  #
  serviceProvider: String!

  #
  vehicleNumber: String!

  #
  vehicleType: String!

  #
  vehicleModel: String!

  #
  engineNumber: String

  #
  chassisNumber: String
}

#
input AlertConfigInput {
  #
  panicType: Int

  #
  osLimit: Int

  #
  voltage: Float

  #
  areaId: Int

  #
  routeId: Int

  #
  uniqueDeviceId: String!

  #
  duration: Int

  #
  fromTimestamp: String

  #
  toTimestamp: String

  #
  email: String

  #
  sms: String

  #
  haltTime: Int

  #
  idleTime: Int

  #
  fromTime: Int

  #
  toTime: Int

  #
  minTemp: Int

  #
  maxTemp: Int

  # Start reminder FROM timestamp (epoch)
  maintRemindFromTimestamp: Int

  # Remind at distance (in km)
  maintAtDistance: Int

  # Remind at hour
  maintAtHour: Int

  # Remind at timestamp (epoch)
  maintRemindAtTimestamp: Int

  # Flag for recurring reminders
  recurring: Boolean

  #
  runningHrs: Float

  #
  noOfDays: Int

  #
  isAlertEnable: Boolean!

  #
  parametersData: [ParameterData]

  #
  noResponseParameterData: [noResponseParameterData]

  #
  value: Int
}

#
input ParameterData {
  #
  parameter: String

  #
  pid: String

  #
  minValue: Int

  #
  maxValue: Int

  #
  isEnable: Boolean!
}

#
input noResponseParameterData {
  #
  typeOfAlert: String

  #
  duration: Int

  #
  isEnable: Boolean!
}

#
type GROUPALERTS {
  #
  alertType: ALERT!

  #
  alertValue: String

  #
  assignedVehicles: [groupAssignedVehicles!]!

  #
  enabled: Boolean!
}

#
type groupAssignedVehicles {
  #
  vehicleNumber: String!
}

#
input ALERTINPUT {
  #
  alertType: ALERT!

  #
  alertValue: String

  #
  enabled: Boolean!
}

#
type setConditionalAlertConfigResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  alertParameters: [AlertParameters]
}

#
type overSpeedResponse {
  #
  status: Int!

  #
  statusMessage: String!
}

#
input FeatureRoleAssigns {
  #
  featureId: Int!

  #
  permission: String!
}

#
type Response {
  #
  code: String

  #
  message: String
}

#
type groupDetails {
  #
  groupId: Int!

  #
  groupName: String!
}

#
type updatedGroupDet {
  #
  groupId: Int!

  #
  groupName: String!
}

#
type deletedGroup {
  #
  groupId: Int!
}

#
input VehicleNumList {
  #
  vehicleNum: String!
}

#
type assignDetails {
  #
  groupId: Int!

  #
  vehicleList: [VehicleNumLists!]!
}

#
type VehicleNumLists {
  #
  vehicleNum: String!
}

#
input VehicleListInput {
  #
  vehicleId: Int!
}

#
input FeatureRoleAssignInput {
  #
  featureId: Int!

  #
  permission: String!
}

#
enum approveOrReject {
  #
  APPROVED

  #
  REJECTED
}

#
input inputBillingDetails {
  #
  simBill: inputBillAmount

  #
  hardwareBill: inputBillAmount

  #
  softwareBill: inputBillAmount

  #
  accessoryBill: inputBillAmount
}

#
input inputBillAmount {
  #
  amountWithGST: Int!

  #
  expectedDateTime: String

  #
  accountsRemrks: String
}

#
enum paymentMode {
  #
  NONE

  #
  ONLINE

  #
  CASH

  #
  DD

  #
  CHEQUE
}

#
type areaResult {
  #
  id: Int!

  #
  areaName: String!

  #
  clientLoginId: Int!
}

#
type addAreaResponse {
  #
  areaId: Int!

  #
  areaName: String!

  #
  geoJson: String!
}

#
enum areaType {
  #
  Circle

  #
  Polygon
}

#
input lat_Long {
  #
  lat: String!

  #
  long: String!
}

#
type editedAreaResponse {
  #
  areaId: Int!

  #
  areaName: String!

  #
  geoJson: String!
}

#
type DeletedAreaGeoFence {
  #
  areaId: Int!

  #
  areaName: String!
}

#
type DetetedGeoFenceResponse {
  #
  status: Int!

  #
  statusMessage: String!
}

#
input AreaEdit {
  #
  areaName: String!

  #
  areaTypeId: Int!

  #
  geoJson: String!

  #
  geoPosition: String!
}

#
type AreaUpdationStatus {
  #
  status: Boolean!

  #
  reason: [SubTrip]

  #
  message: String
}

#
input vehicleNum {
  #
  vehicleNumber: String!
}

#
type AOI_Status {
  #
  areaId: Int!

  #
  vehicleList: [vehicleNumber]
}

#
type vehicleNumber {
  #
  vehicleNumber: String
}

#
type deAssign_STATUS {
  #
  AreaId: Int!

  #
  vehicleLists: [vehicleNumber]
}

#
enum geofenceType {
  #
  circular

  #
  polygon
}

#
type geofenceResponse {
  #
  geofenceid: Int

  #
  status: Int!

  #
  statusMessage: String
}

#
input CircularGeofences {
  # circle_lat_Long must be provided
  circularPosition: circle_lat_Long

  # radius must be <=50 and >= 10000
  radius: Int
}

#
input circle_lat_Long {
  # valid latitude must be provided
  lat: String!

  # valid longitude must be provided
  long: String!
}

#
input PolygonGeofences {
  # Valid lat_Long must be provide
  coordinates: [lat_Long!]

  # Valid lat-long must provided
  polygonPosition: polygon_lat_Long
}

#
input polygon_lat_Long {
  # Valid latitude must be provided
  lat: String!

  # Valid longitude must be provided
  long: String!
}

#
type geofenceResponses {
  #
  geofenceid: Int

  #
  status: Int!

  #
  statusMessage: String
}

#
enum editType {
  #
  circular

  #
  polygon
}

#
type editGeofenceOldResponse {
  #
  geofenceid: Int

  #
  status: Int!

  #
  statusMessage: String
}

#
type editGeofenceResponse {
  #
  geofenceid: Int

  #
  status: Int!

  #
  statusMessage: String

  #
  created_timestamp: String

  #
  updated_timestamp: String
}

#
type RemoveGeofenceResponse {
  #
  geofenceid: Int!

  #
  status: Int!

  #
  statusMessage: String!
}

#
type AddVehicleToGeofenceResponse {
  #
  status: Int!

  #
  statusMessage: String!

  #
  response: [RemarkRespnse]
}

#
type RemarkRespnse {
  #
  vin: String

  #
  remarks: String!
}

#
type RemoveVehicleFromGeofenceResponse {
  #
  status: Int!

  #
  statusMessage: String!

  #
  response: [RemarkRespnse]
}

#
type secondaryUserResponse {
  #
  status: Int!

  #
  statusMessage: String!

  #
  user_details: userDetailsResponse
}

#
type userDetailsResponse {
  #
  vin: String!

  #
  secondary_app_user_id: String!

  #
  user_name: String!

  #
  email: String

  #
  mobile_number: String!

  #
  iso_code: String!

  #
  country_code: Int
}

#
type removeSecondaryUsersResponse {
  #
  status: Int

  #
  statusMessage: String
}

#
type updateUserDetailsResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  user_details: updateUserDetails
}

#
type updateUserDetails {
  #
  app_user_id: String

  #
  user_name: String

  #
  email: String

  #
  iso_code: String

  #
  country_code: Int

  #
  mobile_number: String!
}

#
type updatePrimaryUserResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  user_details: userDetails
}

#
type userDetails {
  #
  app_user_id: String

  #
  user_name: String

  #
  email: String

  #
  iso_code: String

  #
  country_code: Int

  #
  mobile_number: String!
}

#
type updateVinDetailsResponce {
  #
  status: Int

  #
  statusMessage: String

  #
  updatedDetails: updatedDetailsResponse
}

#
type updatedDetailsResponse {
  #
  vin: String!

  #
  vehicle_nick_name: String

  #
  sale_date: String

  #
  vehicle_registration_number: String

  #
  description: String

  #
  vehicle_colour: String

  #
  imei_number: String

  #
  phone_number: String

  #
  sim_number: String

  #
  variant_id: String
}

#
type CommandStatusResponse {
  #
  status: Int

  #
  statusMessage: String
}

#
input RouteEdit {
  #
  areaName: String!

  #
  geoJson: String!

  #
  routeDetail: String!
}

#
type RouteUpdationStatus {
  #
  status: Boolean!

  #
  reason: [SubTrip]

  #
  message: String
}

#
input uniqueDeviceIdListInput {
  #
  uniqueDeviceId: String!
}

#
input uniqueAccessoryIdListInput {
  #
  uniqueAccessoryId: String!
}

#
input simListInput {
  #
  simNumber: String!
}

#
input GeoJsonInput {
  #
  name: String!

  #
  geoJson: String!

  #
  areaType: String!
}

#
input areaIds {
  # Geo fence unique id
  areaId: Int!
}

# Geo fence details
input geoFenceWithHalt {
  # Geo fence unique id
  areaId: Int!

  # halt time in seconds
  haltTime: Int!
}

#
type TripUpdationStatus {
  #
  status: Boolean!

  #
  reason: SubTrip

  #
  message: String
}

#
input TripEdit {
  #
  fromTimestamp: String!

  #
  toTimestamp: String!

  #
  scheduleFromTimestamp: String!

  #
  scheduleToTimestamp: String!

  #
  schedule: Int!

  #
  email: [String]

  #
  sms: [String]

  #
  tolerance: Int!

  #
  tripName: String!
}

# Location input
input InputLocation {
  # Latitude
  lat: Float!

  # Longitude
  lng: Float!
}

# Students stop details
input StudentStops {
  # List of student's id for stop
  studentIds: [Int!]!

  # Area id
  areaId: Int!
}

#
input RouteDetailInput {
  #
  capacity: Int!

  #
  aoiOrder: [String!]!

  #
  aoiOrderObject: [AreaDetailInput!]!

  #
  id: Int!

  #
  load: Int!

  #
  name: String!

  #
  vehicleNumber: String!

  #
  uniqueId: String!

  #
  route: String!

  #
  distance: String!

  #
  duration: String!
}

#
input AreaDetailInput {
  #
  pointId: Int

  #
  coordinates: String!

  #
  name: String!

  #
  geoJson: String!

  #
  students: [String!]!

  #
  type: String!

  #
  areaShapeId: Int!
}

#
input ScheduledDaysList {
  #
  scheduledDays: [String!]!
}

#
input FileUploadInput {
  #
  uploadFor: String!

  #
  bucketName: String!

  #
  fileName: String!

  #
  operationType: String
}

#
input CommonInput {
  #
  clientLoginId: Int

  #
  partnerLoginId: Int

  #
  superAdminLoginId: Int

  #
  manufacturerId: Int

  #
  manufacturerCode: String

  #
  deviceModelId: Int

  #
  serviceProviderId: Int

  #
  accessoryTypeId: Int

  #
  purchaseRequestId: Int

  #
  userLoginId: Int

  #
  resellerLoginId: Int

  #
  groupId: Int

  #
  planId: Int

  #
  subscriptionId: Int

  #
  partnerSubscriptionId: Int

  # Flag to check if trip history needs to be kept or not
  keepOldTripsHistory: Boolean

  #
  fuelInputs: FuelInputs
}

#
input FuelInputs {
  #
  vehicleId: Int

  #
  fuelSensorType: String

  #
  minTankCapacity: Int

  #
  minValue: Int

  #
  maxTankCapacity: Int

  #
  maxValue: Int

  #
  fuelUserType: Int

  #
  refuelThreshold: Int

  #
  drainThreshold: Float

  #
  medianFilter: Int

  #
  pfPerMin: Float

  #
  pilferageTolerance: Float

  #
  minimumPilferageDuration: Float

  #
  totalFuelTank: Int
}

#
type FileUploadResponse {
  #
  totalExcelDataRecords: Int!

  #
  totalDuplicateRecords: Int!

  #
  successfullyUploaded: Int!

  #
  failedToUpload: Int!

  #
  failedUploadList: String!
}

#
input AssignDeviceModelToReseller {
  #
  deviceModelId: Int!
}

#
input AssignLicenseTypeToReseller {
  #
  licenseTypeId: Int
}

#
input LicenseTypeRequest {
  #
  licenseTypeId: Int!

  #
  quantity: Int!

  #
  assignedQuantity: Int!

  #
  finalPrice: Int

  #
  gst: Float

  #
  totalPrice: Int
}

#
input DeviceModelRequest {
  #
  deviceModelId: Int!

  #
  quantity: Int!

  #
  assignedQuantity: Int!

  #
  finalPrice: Int

  #
  gst: Float

  #
  totalPrice: Int
}

#
input processedDeviceList {
  #
  deviceModelId: Int!

  #
  uniqueDeviceId: String!
}

#
input processedLicenseTypeList {
  #
  licenseTypeId: Int!

  #
  approvedQuantity: Int!
}

#
input licenseListInput {
  #
  resellerLicenseInventoryId: Int!

  #
  licenseExpiryTime: String!

  #
  licenseExpiryPeriod: Int

  #
  quantity: Int!
}

#
enum smsGateways {
  #
  GUPSHUP

  #
  SMSINFINY

  #
  ETECH_KEYS

  #
  BOSCH_SMS_API
}

#
enum PaymentType {
  #
  FUll_PAYMENT

  #
  PARTIAL_PAYMENT
}

#
input configAlerts {
  #
  alertId: Int!

  #
  smsAlert: Boolean!

  #
  emailAlert: Boolean!
}

# Type of script to run
enum ScriptType {
  # Sync student data i.e. Name, contact number bla bla
  SYNC_STUDENT_DATA

  # Sync route data
  SYNC_ROUTE

  # Sync AOI data
  SYNC_AOI
}

#
type SyncDataResponse {
  # Success/Failure message
  message: String
}

# Input for vehicle maintenance
input VehicleMaintInput {
  # Vehicle unique id
  vehicleId: Int!

  # Start reminder FROM timestamp (epoch)
  maintRemindFromTimestamp: Int!

  # Remind at distance (in km)
  maintAtDistance: Int

  # Remind at hour
  maintAtHour: Int

  # Remind at timestamp (epoch)
  maintRemindAtTimestamp: Int

  # List of emails to send maintenance reminder
  emails: [String]

  # Flag for recurring reminders
  sms: [String]

  # Flag for recurring reminders
  recurring: Boolean!
}

#
input Icons {
  #
  loginId: Int

  # Icon category. Ex. Report or Analytics
  iconCategory: String!

  # Icon sub-category. Ex. idle-run-ratio or consolidated
  iconSubCategory: String!

  # Icon name, like cosolidated, idle-run-ratio
  iconName: String!
}

#
input pidConfig {
  #
  clientLoginId: Int!

  #
  pid: String!

  #
  parameter: String!
}

#
input SparePartConfig {
  #
  toBeDeleted: Boolean!

  #
  uniqueDeviceId: String!

  #
  sparePartNumber: String!

  #
  sparePartName: String!

  #
  description: String

  #
  replacedPartNumber: String!

  #
  replacedBy: String!

  #
  replacedDate: Int!
}

#
input EmailTemplateConfig {
  #
  toBeDeleted: Boolean!

  #
  template: String

  #
  emailSub: String

  #
  sms: String

  #
  alertName: String
}

#
input EmailConfig {
  #
  toBeDeleted: Boolean!

  #
  user: String!

  #
  pass: String!

  #
  host: String!

  #
  clientLoginId: Int!
}

# The `Upload` scalar type represents a file upload.
scalar Upload

#
input AxisData {
  #
  X: X_Axis_Data

  #
  Y: Y_Axis_Data
}

#
input X_Axis_Data {
  #
  axis: String!

  #
  values: FieldInput!
}

#
input FieldInput {
  #
  fieldId: String!

  #
  fieldName: String!

  #
  unit: String!
}

#
input Y_Axis_Data {
  #
  axis: String!

  #
  values: [FieldInput!]
}

#
input reports {
  #
  name: String!

  #
  reportId: Int!

  #
  enable: Boolean!
}

#
type returnMessage {
  #
  message: String!

  #
  code: Int!
}

#
input simDOList {
  #
  mobileNO: String!

  #
  planDO: planCode!
}

#
input planCode {
  #
  planCode: PLANCODE!
}

#
enum PLANCODE {
  #
  PKG_28796
}

#
type ActivateSimResponse {
  #
  orderCount: Int

  #
  successCount: Int

  #
  failureCount: Int

  #
  inProgressCount: Int

  #
  rejectedCount: Int

  #
  orderInitiateDate: String

  #
  statusMessage: String

  #
  errorItemsCount: Int

  #
  orderCompletionTime: String

  #
  requestedOrderItems: Int

  #
  statusCode: String
}

#
enum Maps {
  #
  HERE

  #
  GOOGLE

  #
  OSM
}

#
input countryCode_phoneNumber {
  #
  iso_code: ISO_CODES!

  #
  mobile_number: String!
}

#
input lat_long_destination {
  #
  lat: String!

  #
  long: String!
}

#
type ShareLiveLocationResponse {
  #
  shared_details: ShareLiveLocationData

  #
  status: Int

  #
  statusMessage: String
}

#
type ShareLiveLocationData {
  #
  request_Id: Int!

  #
  shared_link: String!

  #
  created_timestamp: String!

  #
  expiry_timestamp: String!

  #
  share_name: String

  #
  shared_to_emails: [String]

  #
  shared_to_sms: [isoCode_phoneNumber_resp]

  #
  shared_to_app_users_ids: [String]

  #
  time_to_share_till_timestamp: String!

  #
  destination: [lat_long_resp]
}

#
type isoCode_phoneNumber_resp {
  #
  iso_code: String!

  #
  country_code: Int

  #
  mobile_number: String!
}

#
type lat_long_resp {
  #
  lat: String!

  #
  long: String!
}

#
type stopLiveLocationResponse {
  #
  status: Int

  #
  statusMessage: String
}

#
input contacts_detailsRequest {
  #
  emergency_contact_name: String!

  #
  iso_code: ISO_CODES!

  #
  emergency_mobile_number: String!

  #
  email_id: String
}

#
type addEmergencyContactsResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  app_user_id: String

  #
  vin: String

  #
  contacts_details: [contacts_detailsResponse]
}

#
type contacts_detailsResponse {
  #
  emergency_contact_id: Int!

  #
  iso_code: String!

  #
  country_code: Int

  #
  emergency_contact_name: String!

  #
  emergency_mobile_number: String!

  #
  email_id: String
}

#
type updateEmergencyContactsResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  contacts_details: updateContacts_detailsResponse
}

#
type updateContacts_detailsResponse {
  #
  emergency_contact_id: Int!

  #
  app_user_id: String!

  #
  iso_code: String!

  #
  country_code: Int

  #
  vin: String!

  #
  emergency_contact_name: String

  #
  emergency_mobile_number: String!

  #
  email_id: String
}

#
type deleteEmergencyContactsResponse {
  #
  status: Int

  #
  statusMessage: String
}

#
type ResultDetails {
  #
  status: Int

  #
  statusMessage: String
}

#
input secondary_batteries_uid {
  #
  bat_uids: String
}

#
type onboardHomechargerResponse {
  #
  status: Int!

  #
  statusMessage: String!
}

#
type UploadFile {
  #
  bucketName: String!

  #
  filename: String!

  #
  publicUploadURL: String!
}

#
input FcmTokenInput {
  #
  fcmToken: String!

  #
  platform: PLATFORM!

  # enabled is true by default. Setting this false will not send fcm notifications to this client
  enabled: Boolean
}

#
enum PLATFORM {
  #
  ANDROID

  #
  IOS

  #
  WEB
}

#
type ClientFcmToken {
  #
  clientLoginId: Int!

  #
  fcmToken: String!

  #
  platform: PLATFORM!

  #
  enabled: Boolean!
}

#
type updateTheClientFcmSettingsResponse {
  #
  status: Int!

  #
  statusMessage: String!
}

#
type unregisterTheClientFcmTokenResponse {
  #
  status: Int!

  #
  statusMessage: String!
}

#
type Message {
  #
  message: String!
}

#
type RaiseSOSAlertRespone {
  #
  sos_alert_details: sos_alert_Data

  #
  status: Int!

  #
  statusMessage: String!
}

#
type sos_alert_Data {
  #
  vin: String

  #
  app_user_id: String

  #
  event_id: String

  #
  start_timestamp: String

  #
  expire_timestamp: String

  #
  alert_completed: Boolean!
}

#
type stopSOSAlertResponse {
  #
  status: Int

  #
  statusMessage: String
}

#
type Message_Response {
  #
  message: Message_Enum
}

#
enum Message_Enum {
  #
  NO_ACTIVE_COMMAND_FOUND

  #
  SUCCESS

  #
  FAILED
}

#
enum deviceTypeEnum {
  #
  vehicle

  #
  homecharger
}

#
enum commandTypeEnum {
  #
  SET

  #
  GET
}

#
enum commandSource_Enum {
  #
  SRV

  #
  APP

  #
  CLS
}

#
input commandArgument {
  #
  numberOfCommands: Int!

  #
  commandName: [commandNames!]!

  #
  commandInputs: commandInput!
}

#
enum commandNames {
  # vehicle
  OVERST

  #
  APN

  #
  HBFREQ

  #
  ACAL

  #
  RASHT

  #
  HBT

  #
  HAT

  #
  TRIPOFD

  #
  TLBATT

  #
  IMMOB

  #
  MQTTCONN

  #
  MQTTCRED

  #
  CRASH

  #
  FALL

  #
  THEFT

  # homeCharger
  HOMEDOCKID

  #
  STOPCH

  #
  BATUID

  #
  STOPCHLIMIT

  #
  UPDSEC

  #
  SPEEDCH
}

#
input commandInput {
  #
  OVERST: overstInputs

  #
  APN: apnInputs

  #
  HBFREQ: hbfInputs

  #
  ACAL: acalInputs

  #
  RASHT: accInputs

  #
  HBT: accInputs

  #
  HAT: accInputs

  #
  TRIPOFD: tripofdInputs

  #
  TLBATT: tlbattInputs

  #
  IMMOB: immobInputs

  #
  HOMEDOCKID: homeDockInputs

  #
  STOPCH: stopChInputs

  #
  BATUID: homeDockInputs

  #
  STOPCHLIMIT: stopChLimitInput

  #
  MQTTCONN: mqttConnInputs

  #
  MQTTCRED: mqttCredInputs

  #
  CRASH: crashInputs

  #
  FALL: fallInputs

  #
  THEFT: theftInputs

  #
  UPDSEC: updsecInputs

  #
  SPEEDCH: speedChInputs
}

#
input overstInputs {
  #
  speedLimit: Int!

  #
  duration: Int!
}

#
input apnInputs {
  #
  apn: String!
}

#
input hbfInputs {
  #
  duration: Int!
}

#
input acalInputs {
  #
  accX: Int!

  #
  accY: Int!

  #
  accZ: Int!

  #
  tiltAngle: Int!
}

#
input accInputs {
  #
  accX: Int!

  #
  accY: Int!

  #
  accZ: Int!
}

#
input tripofdInputs {
  #
  duration: Int!
}

#
input tlbattInputs {
  #
  percentage: Int!
}

#
input immobInputs {
  #
  immob: Int!
}

#
input homeDockInputs {
  #
  id: String!
}

#
input stopChInputs {
  #
  on: stopCh_Enum!
}

#
enum stopCh_Enum {
  #
  ON
}

#
input stopChLimitInput {
  #
  socLimit: Int!
}

#
input mqttConnInputs {
  #
  ip_value: String!

  #
  tls_port: String!

  #
  mqtt_topic: String!
}

#
input mqttCredInputs {
  #
  user_name: String!

  #
  password: String!
}

#
input crashInputs {
  #
  speed: Int!

  #
  tiltAngle: Int!

  #
  crashWhatsAppNotificationEnabled: Boolean

  #
  crashEmailNotificationEnabled: Boolean

  #
  crashSmsNotificationEnabled: Boolean
}

#
input fallInputs {
  #
  tiltAngle: Int!

  #
  fallWhatsAppNotificationEnabled: Boolean

  #
  fallEmailNotificationEnabled: Boolean

  #
  fallSmsNotificationEnabled: Boolean
}

#
input theftInputs {
  #
  thresholdDistance: Int!

  #
  pdop: Int!

  #
  satelliteNo: Int!

  #
  theftWhatsAppNotificationEnabled: Boolean

  #
  theftEmailNotificationEnabled: Boolean

  #
  theftSmsNotificationEnabled: Boolean
}

#
input updsecInputs {
  #
  addUpdateRemove: Int!
}

#
input speedChInputs {
  #
  limit: speedChEnum!
}

#
type CommandsToQueueResponse {
  #
  status: Int!

  #
  statusMessage: String!
}

#
input SettingsInput {
  #
  OVERST: overspeedInputs

  #
  APN: apnInputs

  #
  HBFREQ: hbfInputs

  #
  ACAL: acalInputs

  #
  RASHT: accInputs

  #
  HBT: accInputs

  #
  HAT: accInputs

  #
  TRIPOFD: tripofdInputs

  #
  TLBATT: tlbattInputs

  #
  IMMOB: immobInputs

  #
  CRASH: crashInputs

  #
  FALL: fallInputs

  #
  THEFT: theftInputs
}

#
input overspeedInputs {
  #
  alertsEnabled: Boolean!

  #
  speedLimit: Int

  #
  duration: Int

  #
  overstWhatsAppNotificationEnabled: Boolean

  #
  overstEmailNotificationEnabled: Boolean

  #
  overstSmsNotificationEnabled: Boolean
}

#
type VehicleCommandResponse {
  #
  status: Int!

  #
  statusMessage: String!
}

#
input SettingsInputForHomeCharger {
  #
  APN: apnInputs

  #
  HBFREQ: hbfInputs

  #
  ACAL: acalInputs

  #
  HOMEDOCKID: homeDockInputs

  #
  STOPCH: stopChInputs

  #
  BATUID: batUidInputs

  #
  STOPCHLIMIT: stopChLimitInputs

  #
  SPEEDCH: speedChInputs
}

#
input batUidInputs {
  #
  id: String!
}

#
input stopChLimitInputs {
  #
  alertsEnabled: Boolean!

  #
  socLimit: Int!

  #
  whatsAppNotificationEnabled: Boolean

  #
  emailNotificationEnabled: Boolean

  #
  smsNotificationEnabled: Boolean
}

#
type setHomeChargerSettingsResponse {
  #
  status: Int

  #
  statusMessage: String
}

#
type statusMessageRespons {
  #
  status: Int

  #
  statusMessage: String
}

#
enum locationTypeEnum {
  #
  home

  #
  work

  #
  other
}

#
input lat_longRes {
  #
  lat: Float

  #
  long: Float
}

#
type statusResponse {
  #
  location: locationResponse

  #
  status: Int

  #
  statusMessage: String
}

#
type locationResponse {
  #
  location_id: Int

  #
  placeId: String
}

#
input ModesResponse {
  #
  modeTypeId: Int

  #
  modeStartDateTime: Int

  #
  modeEndDateTime: Int

  #
  totalDistanceCovered: Float

  #
  totalDuration: Int
}

#
input GearsResponse {
  #
  gearNumber: Int

  #
  gearStartDateTime: Int

  #
  gearEndDateTime: Int

  #
  totalDuration: Int

  #
  totalDistanceCovered: Float

  #
  averageSpeed: Float

  #
  averageUpshiftSpeed: Float

  #
  averageDownshiftSpeed: Float

  #
  averageRPM: Float

  #
  averageUpshiftRPM: Float

  #
  averageDownshiftRPM: Float
}

#
input LapsResponse {
  #
  lapNumber: Int

  #
  lapTime: Int

  #
  lapDistance: Float
}

#
input TourResponse {
  #
  tourId: Int

  #
  tourName: String!

  #
  tourStartLocation: String!

  #
  tourEndLocation: String!

  #
  totalDuration: Int!

  #
  totalDistance: Float!

  #
  isDeleted: Boolean!

  #
  isTourEnded: Boolean!

  #
  tourStartDateTime: Int!

  #
  tourEndDateTime: Int!

  #
  mileage: Float!

  #
  literPer100KM: Float!

  #
  highestAltitude: Float!

  #
  lowestAltitude: Float!

  #
  topSpeed: Float!

  #
  averageSpeed: Float!

  #
  isFavourite: Boolean!

  #
  tourMMIDownloadLink: String
}

#
type addRideResponse {
  #
  status: Int

  #
  statusMessage: String

  #
  data: dataResponse
}

#
type dataResponse {
  #
  travelId: Int

  #
  vin: String!

  #
  app_user_id: String!

  #
  vehicleTypeId: Int!

  #
  travelFileName: String

  #
  vehicleModelName: String

  #
  totalTime: Int

  #
  rideTime: Int

  #
  travelStartDateTime: String

  #
  travelEndDateTime: String

  #
  totalTravelledDistance: Float

  #
  topSpeed: Float

  #
  averageSpeed: Float

  #
  travelStatsDownloadLink: String

  #
  travelName: String

  #
  isFavourite: Boolean

  #
  type: Int

  #
  travelMMIDownloadLink: String

  #
  startLocation: String

  #
  endLocation: String

  #
  day: String

  #
  currentRideBestLapTime: Int

  #
  currentRideBestLapNumber: Int

  #
  currentRideTotalLapTime: Int

  #
  currentRideTotalLaps: Int

  #
  literPer100KM: Float

  #
  highestAltitude: Float

  #
  lastFuelStatus: Int

  #
  lowestAltitude: Float

  #
  vehicleAvgSpeed: Float

  #
  distanceToEmpty: Float

  #
  mileage: Float

  #
  odometerReading: Float

  #
  batteryVoltage: Float

  #
  cruisingRange: Int

  #
  vehicleBest0to60: Float

  #
  best0To100: Float

  #
  vehicleTopSpeed: Float

  #
  idleTime: Int

  #
  averageRPM: Float

  #
  topSpeedOverAll: Float

  #
  bestShortestTimeSportMode: Float

  #
  totalDistanceOverAll: Float

  #
  totalDuration: Int

  #
  maxAcceleration: Float

  #
  altitude: Float

  #
  maxDeceleration: Float

  #
  temperature: Float

  #
  isCompleted: Boolean

  #
  bestDeceleration: String

  #
  bestAcceleration: String

  #
  rearTyreMacId: String

  #
  frontTyreBattery: Float

  #
  speedoSWVersion: String

  #
  frontTyrePressure: Float

  #
  frontTyreMacId: String

  #
  rearTyrePressure: Float

  #
  rearTyreBattery: Float

  #
  best0To60: Float

  #
  frontTyreTemperature: Float

  #
  rearTyreTemperature: Float

  #
  totalDistanceStreetMode: Float

  #
  weatherShortDescription: String

  #
  isSportMode: Boolean

  #
  weatherIcon: String

  #
  rideTimeRaceMode: Int

  #
  averageSpeedSportMode: Float

  #
  averageSpeedStreetMode: Float

  #
  totalDistanceRaceMode: Float

  #
  lapDistanceSportMode: Float

  #
  averageSpeedRaceMode: Float

  #
  rideTimeStreetMode: Float

  #
  rideTag: Int

  #
  topSpeedRaceMode: Int

  #
  topSpeedSportMode: Float

  #
  isStreetMode: Boolean

  #
  topRPMRaceMode: Float

  #
  isRaceMode: Boolean

  #
  best0to60RaceMode: Float

  #
  userId274140: String

  #
  topSpeedStreetMode: Float

  #
  weatherTemp: Float

  #
  topRPM: Int

  #
  topRPMStreetMode: Float

  #
  best0to60StreetMode: Float

  #
  averageSpeedOverAll: Float

  #
  insertDate: String

  #
  modes: [ModesResponseData]

  #
  gears: [GearsResponseData]

  #
  laps: [LapsResponseData]

  #
  tour: TourResponseData
}

#
type deleteRideResponse {
  #
  status: Int

  #
  statusMessage: String
}

#
type updateRideResponse {
  #
  status: Int

  #
  statusMessage: String
}

type Subscription {
  #
  tvsmDeviceLiveTracking(vin: String!): [LiveTrackingDataResponse]

  #
  deviceLiveTracking(
    deviceId: String!
    snapToRoad: Boolean
  ): [LiveTrackingData!]!

  #
  deviceLiveTrackingWithAdditionalStatuses(
    deviceId: String!
    snapToRoad: Boolean
  ): [LiveTrackingData!]!

  #
  rmsLiveTrackingWithAdditionalStatuses(
    deviceId: String!
    snapToRoad: Boolean
  ): [LiveTrackingData!]!

  #
  wppLiveTrackingWithAdditionalStatuses(
    deviceId: String!
    snapToRoad: Boolean
  ): [LiveTrackingData!]!

  #
  allAlertsForClient(clientId: Int!): AlertData

  #
  getLiveAlerts(deviceId: String): AlertData!
}

#
type LiveTrackingDataResponse {
  #
  userId: String

  #
  timestamp: String

  #
  unitid: String

  #
  odometer: Float

  #
  vin: String

  #
  latitude: Float

  #
  longitude: Float

  #
  isLiveLocation: Boolean

  #
  lastValidTimestamp: String

  #
  last_incognito_off_latitude: Float

  #
  last_incognito_off_longitude: Float

  #
  last_incognito_off_address: String

  #
  last_incognito_off_timestamp: String

  #
  idlingStatus: Boolean

  #
  haltStatus: Boolean

  #
  isOverspeed: Boolean

  #
  speed: Float

  #
  extBatVol: Float

  #
  heading: Float

  #
  main_voltage: Float

  #
  ignition: Float

  #
  panic_button: Float

  #
  immobilizer: Float

  #
  datetime_pkt: String

  #
  soc: Int

  #
  odometer_can: Float

  #
  speed_can: Float

  #
  isPrimaryBattery: Boolean

  #
  charging_status: Int

  #
  isNoGps: Boolean

  #
  address: String

  #
  ignition_status: Int

  #
  driving_mode: Float

  #
  can_modified: String

  #
  can_modified_epoch: String

  #
  time_to_charge_completion: Int

  #
  incognito_mode: String

  #
  co2Saved: Float

  #
  regen_status: Float

  #
  regen_energy: Float

  #
  ev_range: ev_range_details

  #
  tyre_pressure: tyre_pressure_details

  #
  package_version: String

  #
  trees_offset: Float

  #
  is_sos: Boolean

  #
  is_tow: Boolean

  #
  is_crash: Boolean

  #
  is_fall: Boolean

  #
  regen_level: Float

  #
  imeiNo: String

  #
  serviceProvider: String

  #
  bat_a_uid: String

  #
  bat_b_uid: String

  #
  handleBar_status: String
}

#
type ev_range_details {
  #
  dte_eco: Float

  #
  dte_power: Float

  #
  dte_street: Float

  #
  Xtl: Float

  #
  Xtr: Float

  #
  Xnc: Float
}

#
type tyre_pressure_details {
  #
  front: String

  #
  rear: String
}

#
type LiveTrackingData {
  #
  timestamp: String

  #
  latitude: Float!

  #
  longitude: Float!

  #
  gpsStatus: String

  #
  satellites: Int

  #
  idlingStatus: Boolean

  #
  haltStatus: Boolean

  #
  isOverspeed: Boolean

  #
  isHA: Boolean

  #
  isHB: Boolean

  #
  isPrimaryBattery: Boolean

  #
  isNoGps: Boolean

  #
  address: String

  #
  speed: Float

  #
  extBatVol: Float

  #
  plusCode: String

  #
  event_flag: String

  #
  gpsSignal: Int

  #
  standAlone: Boolean

  #
  revenue: Boolean

  #
  operational_WPPs: Boolean

  #
  nonOperational_WPPs: Boolean

  #
  dispensing: Boolean

  #
  notDispensing: Boolean

  #
  tdsActive: Boolean

  #
  tdsInActive: Boolean
}

#
type AlertData {
  #
  clientid: Int!

  #
  uniqueid: String!

  #
  alerttype: String!

  #
  alertvalue: String

  #
  from_ts: String!

  #
  to_ts: String

  #
  server_ts: String!

  #
  areaandroute: String

  #
  lat: Float

  #
  lng: Float

  #
  to_lat: Float

  #
  to_lng: Float

  #
  alert_completed: Boolean!

  #
  view_status: Boolean!

  #
  pluscode: String

  #
  address: String

  #
  vehicleNumber: String

  #
  type: String
}

#
type AlertConfigObj {
  #
  refuel: [AlertConfig]

  #
  pilferage: [AlertConfig]
}

#
type ASSIGNEDVEHICLES {
  #
  vehicleNumber: String!

  #
  speedSensorType: String

  #
  speedLimit: Int

  #
  vehicleModel: String

  #
  vehicleType: String

  #
  deviceUniqueId_fk: String
}

#
enum billingModes {
  #
  PREPAID

  #
  POSTPAID
}

#
enum CacheControlScope {
  #
  PUBLIC

  #
  PRIVATE
}

#
enum Category {
  #
  REPORTS

  #
  ANAlYTICS
}

#
input CircularGeofencesforEdit {
  # circle_lat_Long must be provided
  circularPosition: circle_lat_Long

  # radius must be <=50 and >= 10000
  radius: Int
}

#
type creditNotes {
  #
  type: String!

  #
  needToPay: Int!

  #
  expectedTime: String!

  #
  accountsRemrks: String

  #
  paymentMasterId: Int!

  #
  clientLoginId: Int!

  #
  createdAt: String

  #
  updatedAt: String

  #
  status: Int
}

#
type driverWeightsForClient {
  #
  overspeed: Float!

  #
  harseAcceleration: Float!

  #
  harseBreaking: Float!

  #
  harseControl: Float!
}

#
input driverWeightsForClientInput {
  #
  overspeed: Float!

  #
  harseAcceleration: Float!

  #
  harseBreaking: Float!

  #
  harseControl: Float!
}

#
type ExtBatteryAlertConfig {
  #
  id: Int!

  #
  voltage: Float!

  #
  clientLoginId: Int!

  #
  uniqueDeviceId: String!

  #
  fromTimestamp: String!

  #
  toTimestamp: String!

  #
  email: String

  #
  sms: String

  #
  isEmailEnable: Boolean!

  #
  isSMSEnable: Boolean!
}

#
type FallAlertConfig {
  #
  id: Int!

  #
  clientLoginId: Int!

  #
  uniqueDeviceId: String!

  #
  fromTimestamp: String!

  #
  toTimestamp: String!

  #
  email: String

  #
  sms: String

  #
  isEmailEnable: Boolean!

  #
  isSMSEnable: Boolean!
}

#
type GeofenceAlertConfig {
  #
  id: Int!

  #
  areaId: Int!

  #
  clientLoginId: Int!

  #
  uniqueDeviceId: String!

  #
  fromTimestamp: String!

  #
  toTimestamp: String!

  #
  email: String

  #
  sms: String

  #
  isEmailEnable: Boolean!

  #
  isSMSEnable: Boolean!
}

#
type HaltAlertConfig {
  #
  id: Int!

  #
  panicType: Int!

  #
  clientLoginId: Int!

  #
  uniqueDeviceId: String!

  #
  fromTimestamp: String!

  #
  toTimestamp: String!

  #
  email: String

  #
  sms: String

  #
  isEmailEnable: Boolean!

  #
  isSMSEnable: Boolean!
}

#
type IdleAlertConfig {
  #
  id: Int!

  #
  panicType: Int!

  #
  clientLoginId: Int!

  #
  uniqueDeviceId: String!

  #
  fromTimestamp: String!

  #
  toTimestamp: String!

  #
  email: String

  #
  sms: String

  #
  isEmailEnable: Boolean!

  #
  isSMSEnable: Boolean!
}

#
type IntBatteryVoltageAlertConfig {
  #
  id: Int!

  #
  clientLoginId: Int!

  #
  uniqueDeviceId: String!

  #
  fromTimestamp: String!

  #
  toTimestamp: String!

  #
  email: String

  #
  sms: String

  #
  isEmailEnable: Boolean!

  #
  isSMSEnable: Boolean!
}

#
type NoDispenseAlertConfig {
  #
  id: Int!

  #
  clientLoginId: Int!

  #
  uniqueDeviceId: String!

  #
  fromTimestamp: String!

  #
  toTimestamp: String!

  #
  email: String

  #
  sms: String

  #
  isEmailEnable: Boolean!

  #
  isSMSEnable: Boolean!
}

#
type NoResponseAlertConfig {
  #
  id: Int!

  #
  clientLoginId: Int!

  #
  uniqueDeviceId: String!

  #
  fromTimestamp: String!

  #
  toTimestamp: String!

  #
  email: String

  #
  sms: String

  #
  isEmailEnable: Boolean!

  #
  isSMSEnable: Boolean!
}

#
type OverSpeedAlertConfig {
  #
  id: Int!

  #
  osLimit: Int!

  #
  clientLoginId: Int!

  #
  uniqueDeviceId: String!

  #
  fromTimestamp: String!

  #
  toTimestamp: String!

  #
  email: String

  #
  sms: String

  #
  isEmailEnable: Boolean!

  #
  isSMSEnable: Boolean!
}

#
type PanicAlertConfig {
  #
  id: Int!

  #
  panicType: Int!

  #
  clientLoginId: Int!

  #
  uniqueDeviceId: String!

  #
  fromTimestamp: String!

  #
  toTimestamp: String!

  #
  email: String

  #
  sms: String

  #
  isEmailEnable: Boolean!

  #
  isSMSEnable: Boolean!
}

#
type PartnerDetails {
  #
  id: Int!

  #
  name: String

  #
  address: String

  #
  gstNumber: String

  #
  email: String
}

#
enum paymentType {
  #
  FULLPAYMENT

  #
  CREDITNOTE
}

#
enum PLANS {
  #
  Enterprise
}

#
input PolygonGeofencesforEdit {
  # Valid lat_Long must be provide
  coordinates: [lat_Long!]

  # Valid lat-long must provided
  polygonPosition: polygon_lat_Long
}

#
type PulloutAlertConfig {
  #
  id: Int!

  #
  clientLoginId: Int!

  #
  uniqueDeviceId: String!

  #
  fromTimestamp: String!

  #
  toTimestamp: String!

  #
  email: String

  #
  sms: String

  #
  isEmailEnable: Boolean!

  #
  isSMSEnable: Boolean!
}

#
type RoutefenceAlertConfig {
  #
  id: Int!

  #
  clientLoginId: Int!

  #
  uniqueDeviceId: String!

  #
  routeId: Int!

  #
  fromTimestamp: String!

  #
  toTimestamp: String!

  #
  email: String

  #
  sms: String

  #
  isEmailEnable: Boolean!

  #
  isSMSEnable: Boolean!
}

#
type sendSmsAndEmail {
  #
  sentResult: String!
}

#
enum SENSOR {
  #
  GPS

  #
  odemeter
}

#
enum simStatus {
  #
  INITIAL

  #
  ACTIVE

  #
  SAFE_CUSTODY

  #
  ACTIVATED_ON_TEST_MODE

  #
  IN_PROGRESS

  #
  SUSPENDED

  #
  TEMP_DISCONNECT

  #
  ACTIVE_AND_SAFE_CUSTODY

  #
  ACTIVE_AND_TEMP_DISCONNECT

  #
  ACTIVE_AND_INITIAL
}

#
type TempAlertConfig {
  #
  id: Int!

  #
  minTemp: Int!

  #
  maxTemp: Int!

  #
  clientLoginId: Int!

  #
  userLoginId: Int

  #
  uniqueDeviceId: String!

  #
  fromTimestamp: String!

  #
  toTimestamp: String!

  #
  email: String

  #
  sms: String

  #
  isEmailEnable: Boolean!

  #
  isSMSEnable: Boolean!
}

#
input toLoginId {
  #
  toLoginId: Int!
}

#
type TowAlertConfig {
  #
  id: Int!

  #
  clientLoginId: Int!

  #
  uniqueDeviceId: String!

  #
  fromTimestamp: String!

  #
  toTimestamp: String!

  #
  email: String

  #
  sms: String

  #
  isEmailEnable: Boolean!

  #
  isSMSEnable: Boolean!
}

# Type of trips
enum TypeOfTrip {
  #
  PICKUP

  #
  DROP
}

#
type usersResponse {
  #
  app_user_id: String!

  #
  user_name: String!

  #
  email: String!

  #
  country_code: Int!

  #
  iso_code: String!

  #
  mobile_number: String!

  #
  user_type: String!
}

#
enum userType {
  #
  PRIMARY

  #
  SECONDARY
}

#
input vehicles {
  #
  VehicleNumbers: String!
}

#
type SnappedCoordinate {
  #
  lat: Float!

  #
  lng: Float!

  #
  idx: Int
}

#
enum aggregation_period {
  #
  day

  #
  month

  #
  week

  #
  all
}

#
type alarmsList {
  #
  lat: String

  #
  lng: String

  #
  time: String

  #
  alertType: String

  #
  alertData: String
}

#
type Change {
  #
  percentage: Float
}

#
type dtcList {
  #
  lat: String

  #
  lng: String

  #
  dtcCode: String

  #
  dtcDescription: String

  #
  criticality: String
}

#
type leaderBoard {
  #
  driverName: String

  #
  driverScore: String
}

#
enum Metric {
  #
  FLEET_DISTANCE

  #
  FLEET_UTILIZATION

  #
  FLEET_SCORE

  #
  TIME_OF_DAY_MOST_RUNNING

  #
  TIME_OF_DAY_MOST_IDLING

  #
  TIME_OF_DAY_MOST_HALTED

  #
  MOST_RUNNING_VEHICLE

  #
  MOST_IDLE_VEHICLE

  #
  MOST_HALTED_VEHICLE

  #
  MOST_NO_GPS_VEHICLE

  #
  MOST_OFFLINE_VEHICLE

  #
  RUNNING_TIME

  #
  HALT_TIME

  #
  IDLING_TIME
}

#
type PreProcessedData {
  #
  uniqueid: String

  #
  vehicleNumber: String

  #
  clientLoginId: Int

  #
  groupName: String

  #
  category: Int

  #
  reportType: String

  #
  startTime: String

  #
  endTime: String

  #
  startAddress: String

  #
  endAddress: String

  #
  totalDist: Float

  #
  totalRunningTime: Float

  #
  totalHaltTime: Float

  #
  totalHaCount: Int

  #
  totalHbCount: Int

  #
  avgSpeed: Float

  #
  maxSpeed: Float

  #
  totalIdlingTime: Float

  #
  totalOsDist: Float

  #
  totalDayDriveTime: Float

  #
  totalNightDriveTime: Float

  #
  driverName: String

  #
  totalScore: Float

  #
  totalIgOnTime: Float

  #
  totalIgOffTime: Float

  #
  totalOverspeedTime: Float
}

#
type RMSWppData {
  #
  wppId: String

  #
  location: String
}

#
type WPPSummary {
  #
  village: String

  #
  wppId: String

  #
  minCansDispensed: Int

  #
  maxCansDispensed: Int

  #
  totalCans: Int

  #
  averageTds: Float

  #
  minTds: Float

  #
  maxTds: Float
}

#
input commandArgumentsResponse {
  #
  vin: [String]

  #
  userId: [String]

  #
  numberOfCommands: Int

  #
  commandName: [String]

  #
  commandInputs: [String]
}

#
type cloudsObj {
  #
  name: String

  #
  value: String
}

#
type coordCityObj {
  #
  lon: Float

  #
  lat: Float
}

#
type CurrentCityObj {
  #
  id: String

  #
  name: String

  #
  coord: coordCityObj

  #
  country: String

  #
  timezone: String

  #
  sun: sunCurrObj
}

#
type sunCurrObj {
  #
  rise: String

  #
  set: String
}

#
type Currtemperature {
  #
  value: String

  #
  min: String

  #
  max: String

  #
  unit: String
}

#
type currWeatherObj {
  #
  number: String

  #
  value: String

  #
  icon: String
}

#
type directionObj {
  #
  value: String

  #
  unit: String

  #
  name: String
}

#
type fore_clouds {
  #
  value: String

  #
  all: String

  #
  unit: String
}

#
type fore_feels_like {
  #
  unit: String

  #
  value: String
}

#
type fore_humidity {
  #
  unit: String

  #
  value: String
}

#
type fore_pressure {
  #
  unit: String

  #
  value: String
}

#
type fore_visibility {
  #
  value: String
}

#
type forecastObj {
  #
  time: foreCastTime

  #
  symbol: foreCastsymbol

  #
  precipitation: forePrecipitation

  #
  windDirection: windDirectionObj

  #
  windSpeed: windSpeedObj

  #
  windGust: windGustObj

  #
  temperature: temperatureObj

  #
  feels_like: fore_feels_like

  #
  pressure: fore_pressure

  #
  humidity: fore_humidity

  #
  clouds: fore_clouds

  #
  visibility: fore_visibility
}

#
type foreCastTime {
  #
  from: String

  #
  to: String
}

#
type foreCastsymbol {
  #
  number: String

  #
  name: String

  #
  var: String
}

#
type forePrecipitation {
  #
  value: String

  #
  unit: String

  #
  type: String

  #
  probability: String
}

#
type windDirectionObj {
  #
  deg: String

  #
  code: String

  #
  name: String
}

#
type windSpeedObj {
  #
  mps: String

  #
  unit: String

  #
  name: String
}

#
type windGustObj {
  #
  gust: String

  #
  unit: String
}

#
type temperatureObj {
  #
  unit: String

  #
  value: String

  #
  min: String

  #
  max: String
}

#
type lastupdateObj {
  #
  value: String
}

#
type precipitationObj {
  #
  value: String

  #
  mode: String
}

#
type speedObj {
  #
  value: String

  #
  code: String

  #
  name: String
}

#
type windCurrent {
  #
  speed: speedObj

  #
  direction: directionObj
}

#
type CumulativeLastNRidesResponse {
  #
  best0to60: Float

  #
  bikeTopSpeed: Float

  #
  max_engine_rpm: Int

  #
  mileage: Float
}

#
type lastRidesResponse {
  #
  travelId: Int

  #
  user_id: Int

  #
  travelFileName: String

  #
  trip_start_time: Float

  #
  trip_end_time: Float

  #
  bestShortestTimeSportMode: Float

  #
  topSpeedOverAll: Float

  #
  averageSpeedOverAll: Float

  #
  max_engine_rpm: Int

  #
  avg_engine_rpm: Int

  #
  trip_duration: Int

  #
  totalDistanceOverAll: Float

  #
  mileage: Float
}

#
input OtherRideParametersResponse {
  #
  literPer100KM: Float

  #
  highestAltitude: Float

  #
  lastFuelStatus: Int

  #
  lowestAltitude: Float

  #
  vehicleAvgSpeed: Float

  #
  DistanceToEmpty: Float

  #
  mileage: Float

  #
  odometerReading: Float

  #
  batteryVoltage: Float

  #
  cruisingRange: Int

  #
  vehicleBest0to60: Float

  #
  best0To100: Float

  #
  vehicleTopSpeed: Float

  #
  IdleTime: Int

  #
  AverageRPM: Float

  #
  TopSpeedOverAll: Float

  #
  BestShortestTimeSportMode: Float

  #
  TotalDistanceOverAll: Float

  #
  TotalDuration: Int

  #
  maxAcceleration: Float

  #
  altitude: Float

  #
  tourId: Int

  #
  maxDeceleration: Float

  #
  temperature: Float

  #
  IsCompleted: Boolean

  #
  BestDeceleration: String

  #
  BestAcceleration: String

  #
  RearTyreMacId: String

  #
  frontTyreBattery: Float

  #
  speedoSwVersion: String

  #
  frontTyrePressure: Float

  #
  FrontTyreMacId: String

  #
  rearTyrePressure: Float

  #
  rearTyreBattery: Float

  #
  best0To60: Float

  #
  frontTyreTemperature: Float

  #
  rearTyreTemperature: Float
}

#
type OtherRideParametersResponseData {
  #
  literPer100KM: Float

  #
  highestAltitude: Float

  #
  lastFuelStatus: Int

  #
  lowestAltitude: Float

  #
  vehicleAvgSpeed: Float

  #
  DistanceToEmpty: Float

  #
  mileage: Float

  #
  odometerReading: Float

  #
  batteryVoltage: Float

  #
  cruisingRange: Int

  #
  vehicleBest0to60: Float

  #
  best0To100: Float

  #
  vehicleTopSpeed: Float

  #
  IdleTime: Int

  #
  AverageRPM: Float

  #
  TopSpeedOverAll: Float

  #
  BestShortestTimeSportMode: Float

  #
  TotalDistanceOverAll: Float

  #
  TotalDuration: Int

  #
  maxAcceleration: Float

  #
  altitude: Float

  #
  tourId: Int

  #
  maxDeceleration: Float

  #
  temperature: Float

  #
  IsCompleted: Boolean

  #
  BestDeceleration: String

  #
  BestAcceleration: String

  #
  RearTyreMacId: String

  #
  frontTyreBattery: Float

  #
  speedoSwVersion: String

  #
  frontTyrePressure: Float

  #
  FrontTyreMacId: String

  #
  rearTyrePressure: Float

  #
  rearTyreBattery: Float

  #
  best0To60: Float

  #
  frontTyreTemperature: Float

  #
  rearTyreTemperature: Float
}
